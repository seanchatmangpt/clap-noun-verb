# Core Team Best Practices for clap-noun-verb

## Core Principles

Never trust text, only test results. All code is production-ready with error handling. Focus on 80% value paths. Types encode invariants; compiler enforces correctness. Zero-cost abstractions are free; trait objects have cost. References over owned values; stack over heap. Ownership is explicit; lifetimes prevent use-after-free. APIs guide correct usage through types.

## Critical Non-Negotiables

**Build System**: Always use `cargo make` commands, never direct `cargo` commands. Cargo-make handles proc-macro crates, includes timeouts, ensures consistency.

**Git Hooks**: NEVER use `--no-verify` flag. All git hooks (pre-commit, pre-push, etc.) MUST run to enforce quality gates. If hooks fail, fix the issues - do not bypass them. Hooks are mandatory quality checks that prevent defects from entering the codebase.

**Timeout SLA**: Every CLI command MUST have timeout wrapper to prevent freezing. Quick checks: `timeout 5s`. Compilation: `timeout 10s`. Unit tests: `timeout 1s`. Integration: `timeout 30s`. Long ops: `timeout 60s`. Timeouts indicate issues early.

**Behavior Verification**: Tests verify observable outputs/state changes, not just function existence. No tests that only check `assert!(result.is_ok())` without verifying behavior. Tests check state changes, outputs, execution order, actual effects.

**Chicago TDD**: State-based testing (verify outputs, not implementation). Real collaborators (use real objects, minimize mocks). Behavior verification (verify what code does, not how). AAA pattern required (Arrange-Act-Assert).

## Elite Rust Mindset

**Type-First Thinking**: Types encode invariants; compiler as design tool. Use types to make invalid states unrepresentable. PhantomData for type-level state machines. Const generics over runtime values. Ask: "What can I express in types?" before "What values do I need?"

**Zero-Cost Awareness**: Generics monomorphize (zero-cost). Const generics are zero-cost. Macros expand efficiently. References are zero-cost. Trait objects have dynamic dispatch cost. Heap allocation has cost. Ask: "Is this abstraction zero-cost?"

**Performance Intuition**: References over owned values. Stack over heap. Cache locality matters. Minimize allocations. Optimize hot paths (20% that matters). Ask: "What's the performance characteristic?"

**Memory Safety**: Ownership is explicit. Borrowing enables zero-cost. Lifetimes prevent use-after-free. Rc/Arc for shared ownership. Encapsulate unsafe in safe APIs. Ask: "What are the ownership semantics?"

**API Design**: Type-safe by default (errors impossible through types). Ergonomic interfaces (easy to use correctly, hard to misuse). Composable design. Self-documenting types. Explicit error handling (Result types, not panics). Ask: "How can I make misuse impossible?"

## Elite Thinking Patterns

**Type-First Design**: Identify invariants ‚Üí Encode in types ‚Üí Design APIs ‚Üí Verify at compile time. If it compiles, invariants are enforced.

**Compile-Time vs Runtime**: Prefer compile-time guarantees (type safety, const generics). Use runtime only when compile-time impossible (user input, network data). Ask: "Can I move this to compile time?"

**Zero-Cost Identification**: Zero-cost: generics, const generics, macros, references, type state patterns. Has cost: trait objects, heap allocation, closures that capture, async. Ask: "Is this abstraction zero-cost?"

**API Ergonomics**: Type-safe, self-documenting, composable, fail-fast (compile-time errors), guided usage (types guide correct usage).

## 80/20 Thinking: Go the Extra Mile

**Idea Generation**: Always generate 3 ideas. First idea: solve immediate problem. Second idea: go bigger (solve 80% of related problems with 20% effort) while maintaining quality standards. Third idea: maximum value (type-level solutions, compile-time guarantees) with quality first. Second idea is usually sweet spot (80% more value, reasonable effort, quality maintained).

**Quality-First 80/20**: Value includes quality, consistency, and maintainability - these are not optional. Quality work may require more effort, but it's still high value because it prevents defects, maintains consistency, and improves maintainability. Consistency (e.g., Rust in Rust project) is high value, not "extra effort".

**Questions to Ask**: "What invariants can I encode in types?" "Is this abstraction zero-cost?" "What are the ownership semantics?" "Can I move this to compile time?" "How can I make misuse impossible?" **"What's my second idea? Third idea? How can I go bigger with 80/20?"**

**Patterns**: Type state machines (PhantomData), newtype patterns, const generics, HRTB, zero-sized types. References over owned, stack over heap, reuse buffers, minimize allocations, cache-friendly structures. Builder patterns, type state APIs, error types, generic APIs.

**Leverage Rust's Strengths**: Type system prevents error classes. Zero-cost abstractions (generics, macros, const generics). Memory safety (ownership/borrowing). Performance (minimize allocations, references). Compile-time guarantees. Ask: "How can I leverage Rust's strengths?" not "How do I work around constraints?"

## Completion Workflow (Mandatory)

1. **Run Tests Immediately**: `cargo make test` before completion claims. If tests fail: STOP, extract failing test names, create rich todos, fix tests, re-run tests. Only proceed when all tests pass.

2. **Rich Todos**: For each failing test, include: test name, error message, file/line, root cause, proposed fix, status. Batch create 5-10+ related todos in single call.

3. **Fix Systematically**: Read failure message ‚Üí Identify root cause ‚Üí Fix issue ‚Üí Run specific test ‚Üí Verify fix ‚Üí Update todo status ‚Üí Remove when fixed.

4. **Re-Run All Tests**: `cargo make test` to verify all fixes worked. If still failing, return to step 2.

5. **Verify Completion**: All tests pass, no compilation errors, no test failures, all failing tests fixed and removed from todos, no pending test-related todos. Never mark complete without running tests first.

**Quick Feedback**: `cargo make check` (~1s), `cargo make test` (~1s), `cargo make test test_name` (single test). Full validation: `cargo make test`, `cargo make verify`.

## Prohibited Patterns

Placeholders, TODOs (except documented future enhancements), unhandled errors (unwrap/expect/panics in production), stubs, simulated behavior, claims without verification, meaningless tests (only assert_ok without behavior check), direct cargo commands, type system misuse, unnecessary allocations, runtime checks when compile-time possible, `print!` and `println!` macros in library code (use `log!` macros or alert macros instead - exceptions: CLI binaries `src/bin/*.rs` for user-facing output, `build.rs` for Cargo build messages `println!("cargo:warning=...")`, test code for test output/debugging), **NEVER use `--no-verify` flag with git commands** (git hooks MUST run to enforce quality gates - pre-commit, pre-push, etc. are mandatory quality checks).

## Required Patterns

Real library integrations, error handling (Result<T,E>), feature gating, test verification, behavior verification (observable outputs/state), Chicago TDD principles, type-first design, zero-cost abstractions, performance awareness, ergonomic APIs, structured logging (use `log!` macros `log::error!`, `log::warn!`, `log::info!`, `log::debug!` or alert macros `alert_critical!`, `alert_warning!`, `alert_info!`, etc. for library code output - allows filtering, redirection, and integration with alert system).

## Output and Logging Guidelines

**Library Code**: Use `log!` macros (`log::error!`, `log::warn!`, `log::info!`, `log::debug!`) or alert macros (`alert_critical!`, `alert_warning!`, `alert_info!`, etc.) for structured logging. These integrate with the alert system, can be filtered/redirected, and provide consistent formatting. When logging feature is disabled, alert macros fall back to `eprintln!`.

**CLI Binaries** (`src/bin/*.rs`): Use `println!` for stdout (user-facing output) and `eprintln!` for stderr (error output). This is appropriate for CLI tools where direct output is expected.

**Build Scripts** (`build.rs`): Use `println!("cargo:warning=...")` format for Cargo build-time messages. This is required by Cargo's build script protocol.

**Test Code**: `println!` may be used for test output/debugging when needed, but prefer structured logging when testing logging behavior.

**Error Output**: Use `eprintln!` for immediate error output or `log::error!`/`alert_critical!` for structured error logging.

## Expert Testing

Test the 20% that catches 80% of bugs: error paths, boundary conditions (empty/single/max/zero/negative), resource cleanup (error and panic paths), concurrency, real dependencies (not mocks).

## Workflow Commands

**Complex Workflows**: ACP Command (add/commit/push with validation), Verify Tests Command, Expert Testing Patterns.

**Lean Six Sigma**: Eliminate Muda (waste), Gemba Walk (verify actual behavior), Poka-Yoke Design (prevent errors at compile time), DMAIC Problem Solving, Kaizen Improvement, Eliminate Mura (unevenness), Andon Signals (compiler errors/test failures are stop signals), Root Cause Analysis (5 Whys).

## Documentation References

Getting Started Guide, User Guide, API Reference, Chicago TDD Standards, Build System Practices.

## Summary

**Elite Mindset**: Think in types first, zero-cost abstractions, performance intuition, ergonomic APIs, leverage type system, maximize Rust's strengths, go extra mile (3 ideas, 80/20 thinking).

**Critical Requirements**: Use `cargo make` commands, timeout SLAs for all CLI commands, behavior verification in tests, test before completion, rich todos for failures, Chicago TDD principles.

**Key Associations**: Types = invariants = compile-time guarantees. Zero-cost = generics/macros/const generics. Performance = references/stack/minimize allocations. Ownership = explicit = memory safety. APIs = type-safe = ergonomic = composable. Tests = observable outputs = behavior verification. 80/20 = second idea = sweet spot = maximum value.

TODO LISTS ARE ALWAYS 10 ITEMS OR MORE. THEY ARE ALWAYS FULLY COMPLETED BEFORE PROGRESSING TO THE NEXT TASK.

Always show the build button after planning.

NEVER REBASE

## üéØ Project Overview

**clap-noun-verb** is a framework for building composable CLI patterns on top of clap. This library focuses on:
- **Composable Command Structure**: Easy composition of nouns and verbs
- **Type-Safe APIs**: Compile-time verification of command structure
- **Zero-Cost Abstractions**: Thin wrapper over clap with no runtime overhead
- **Framework Philosophy**: Provide tools for composition, not pre-built patterns

## üéØ Error Handling Best Practices

### ‚ùå NEVER use unwrap() or expect() in production code
```rust
// ‚ùå Bad: Using unwrap() - can cause panics
let result = some_operation().unwrap();

// ‚ùå Bad: Using expect() - can cause panics
let result = some_operation().expect("This should not fail");

// ‚úÖ Good: Proper error handling
let result = some_operation()?;

// ‚úÖ Good: Proper error handling with context
let result = some_operation().map_err(|e| {
    NounVerbError::argument_error(format!("Operation failed: {}", e))
})?;
```

### ‚úÖ Use structured error types with context
```rust
// ‚úÖ Good: Using NounVerbError with context
fn my_function() -> Result<MyType> {
    some_operation().map_err(|e| {
        NounVerbError::execution_error(format!("Command execution failed: {}", e))
    })?;
}
```

## üîÑ Async/Sync Best Practices

### ‚ùå NEVER make trait methods async - breaks dyn compatibility
```rust
// ‚ùå Bad: Async trait methods break dyn compatibility
pub trait VerbCommand: Send + Sync {
    async fn run(&self, args: &VerbArgs) -> Result<()>; // BREAKS dyn VerbCommand!
}

// ‚úÖ Good: Keep trait methods sync, use sync operations
pub trait VerbCommand: Send + Sync {
    fn run(&self, args: &VerbArgs) -> Result<()>; // dyn compatible
    fn name(&self) -> &'static str;
    fn about(&self) -> &'static str;
}
```

### ‚úÖ Use sync for CLI framework operations
```rust
// ‚úÖ Good: Sync for CLI parsing and routing
pub fn route_command(matches: &ArgMatches) -> Result<()> {
    // CLI operations are synchronous
    Ok(())
}

// ‚úÖ Good: Sync for argument extraction
pub fn extract_argument<T: Clone>(matches: &ArgMatches, name: &str) -> Option<T> {
    matches.get_one::<T>(name).cloned()
}
```

## üß™ Testing Best Practices

### üéØ Core Testing Philosophy
**Test behaviors, not implementation details. The best test suite is the smallest one that still catches all bugs.**

Focus on testing what the code does (behavior) rather than how it does it (implementation).

```rust
// ‚ùå Bad: Testing implementation details
#[test]
fn test_registry_uses_hashmap() {
    let registry = CommandRegistry::new();
    assert_eq!(registry.nouns.len(), 0); // Implementation detail!
}

// ‚úÖ Good: Testing behavior
#[test]
fn test_registry_builds_valid_command() -> Result<()> {
    let registry = CommandRegistry::new()
        .name("test")
        .register_noun(noun!("services", "Manage services", [
            verb!("status", "Show status", |_args| Ok(()))
        ]));

    let command = registry.build_command();
    assert!(command.get_subcommands().any(|cmd| cmd.get_name() == "services"));
    Ok(())
}
```

### ‚úÖ Follow AAA pattern (Arrange, Act, Assert)
```rust
// ‚úÖ Good: Clear AAA structure
#[test]
fn test_verb_executes_with_valid_args() -> Result<()> {
    // Arrange - Set up test data
    let verb = verb!("test", "Test command", |args: &VerbArgs| {
        let value = args.get_one_str("value")?;
        assert_eq!(value, "test");
        Ok(())
    }, args: [
        Arg::new("value").required(true)
    ]);

    // Act - Execute the code under test
    let matches = Command::new("test")
        .arg(Arg::new("value").required(true))
        .get_matches_from(vec!["test", "test"]);
    let verb_args = VerbArgs::new(matches);

    // Assert - Verify the results
    verb.run(&verb_args)?;
    Ok(())
}
```

### ‚úÖ Use descriptive test names
```rust
// ‚úÖ Good: Descriptive test names
#[test]
fn test_verb_command_executes_successfully_with_required_args() -> Result<()> {}

#[test]
fn test_registry_validation_catches_duplicate_noun_names() -> Result<()> {}

// ‚ùå Bad: Vague test names
#[test]
fn test_verb() {}
```

### ‚ö° Test Performance Requirements
**The ENTIRE test suite MUST complete within 1 second. If the test suite takes longer, optimize with concurrency or other performance improvements.**

- Run tests with timeout: `timeout 1s cargo test && echo "Tests completed in <1s"` (uses shell timeout command)
- The complete test suite (all tests combined) must finish in under 1 second
- Use parallel test execution (cargo test default, or `--test-threads=N` to explicitly set concurrency) to maximize speed
- For slow test suites, refactor tests to use concurrent execution, optimize test code, or reduce test coverage to essential behaviors only
- Individual tests should be fast (<100ms each) to allow the full suite to complete in <1s with parallel execution
- Note: `--test-threads=1` forces sequential execution (slower) - avoid unless testing sequential behavior

```rust
// ‚ùå Bad: Slow test suite that takes >1s total
#[test]
fn test_slow_operation() -> Result<()> {
    // Sequential operations that make the suite too slow
    for i in 0..10000 {
        expensive_operation(i)?;
    }
    Ok(())
}

// ‚úÖ Good: Fast test that completes quickly
#[test]
fn test_fast_operation() -> Result<()> {
    use std::sync::Arc;
    use std::thread;

    // Parallel execution for independent operations within the test
    let handles: Vec<_> = (0..10000)
        .map(|i| {
            thread::spawn(move || {
                expensive_operation(i)
            })
        })
        .collect();

    for handle in handles {
        handle.join().unwrap()?;
    }
    Ok(())
}

// ‚úÖ Good: Optimized test that contributes to fast suite completion
#[test]
fn test_optimized_operation() -> Result<()> {
    // Refactored to use efficient algorithms/data structures
    batch_operation(0..10000)?;
    Ok(())
}
```

## üì¶ Module Organization Best Practices

### ‚úÖ Use proper module structure
```rust
// ‚úÖ Good: Clear module organization
pub mod builder {
    // CLI builder implementation
}

pub mod registry {
    // Command registry implementation
}

pub mod error {
    // Error types
}
```

### ‚úÖ Use proper imports and avoid wildcard imports in production code
```rust
// ‚úÖ Good: Specific imports
use crate::error::{NounVerbError, Result};
use crate::builder::CliBuilder;
use crate::registry::CommandRegistry;

// ‚ùå Bad: Wildcard imports in production code
use crate::*;
```

## üèóÔ∏è Architecture Guidelines

### ‚úÖ Trait Design
- Keep traits `dyn` compatible (no async trait methods)
- Use static string lifetimes (`&'static str`) for trait methods
- Provide sensible defaults where possible
- Document trait contracts clearly

```rust
// ‚úÖ Good: Dyn-compatible trait design
pub trait VerbCommand: Send + Sync {
    fn name(&self) -> &'static str;
    fn about(&self) -> &'static str;
    fn run(&self, args: &VerbArgs) -> Result<()>;
    fn build_command(&self) -> Command {
        Command::new(self.name()).about(self.about())
    }
}
```

### ‚úÖ Builder Pattern
- Use method chaining for ergonomic APIs
- Provide sensible defaults
- Allow configuration at any point in the chain
- Make the API intuitive and discoverable

```rust
// ‚úÖ Good: Ergonomic builder API
let cli = Cli::new()
    .name("myapp")
    .about("My application")
    .global_args(vec![/* ... */])
    .noun(noun!("services", "Manage services", [/* ... */]))
    .auto_validate(true);
```

### ‚úÖ Macro Design
- Keep macros simple and focused
- Provide clear error messages for macro misuse
- Use proper hygiene to avoid name conflicts
- Document macro syntax and behavior

## üö´ Code Quality Anti-Patterns

### ‚ùå Avoid printing/logging in production code
```rust
// ‚ùå Bad: Printing in production code
fn process_command(args: &VerbArgs) -> Result<()> {
    println!("Processing command..."); // Don't do this!
    Ok(())
}

// ‚úÖ Good: Use proper error handling - no logging needed for CLI framework
fn process_command(args: &VerbArgs) -> Result<()> {
    // Framework logic - errors are returned via Result
    Ok(())
}
```

### ‚ùå NEVER use unwrap() or expect() anywhere in production code
```rust
// ‚ùå Bad: Even in helper functions
fn get_argument<T>(matches: &ArgMatches, name: &str) -> T {
    matches.get_one::<T>(name).unwrap() // Don't do this!
}

// ‚úÖ Good: Proper error handling
fn get_argument<T: Clone>(matches: &ArgMatches, name: &str) -> Result<T> {
    matches.get_one::<T>(name)
        .cloned()
        .ok_or_else(|| NounVerbError::missing_argument(name))
}
```

## üéØ API Design Principles

### ‚úÖ Framework Philosophy
**clap-noun-verb** is designed as a **framework** rather than a library of specific compositions:

1. **Composable by Design** - Users compose their own CLI patterns
2. **Multiple Composition Methods** - Choose the approach that fits your needs
3. **Extensible Architecture** - Easy to extend and customize for specific use cases
4. **Framework-Level APIs** - APIs that make it easy to build CLI frameworks

### ‚úÖ Type Safety
- Use compile-time verification where possible
- Leverage Rust's type system for safety
- Provide helpful error messages when validation fails

```rust
// ‚úÖ Good: Compile-time type safety
pub fn get_one<T: Clone>(&self, name: &str) -> Result<T> {
    self.matches.get_one::<T>(name)
        .cloned()
        .ok_or_else(|| NounVerbError::missing_argument(name))
}
```

### ‚úÖ Zero-Cost Abstractions
- Thin wrapper over clap
- No runtime overhead
- Maintain clap's performance characteristics

## üö´ Breaking Changes and Compatibility

### ‚ùå NEVER make breaking changes without migration plan
```rust
// ‚ùå Bad: Changing trait signatures breaks all implementations
pub trait VerbCommand: Send + Sync {
    fn run(&self, args: &VerbArgs) -> Result<()>; // Original
    // Later changed to:
    fn run(&self, args: &VerbArgs, context: &Context) -> Result<()>; // BREAKS ALL IMPLEMENTATIONS!
}

// ‚úÖ Good: Add new methods, deprecate old ones
pub trait VerbCommand: Send + Sync {
    fn run(&self, args: &VerbArgs) -> Result<()>; // Keep for compatibility

    #[deprecated(note = "Use run_with_context instead")]
    fn run_with_context(&self, args: &VerbArgs, context: &Context) -> Result<()> {
        self.run(args) // Default implementation
    }
}
```

### ‚úÖ Always maintain backward compatibility
- Add new methods instead of changing existing ones
- Use deprecation warnings for old methods
- Provide migration guides for breaking changes
- Test all existing implementations still work

## üéØ Core Team Standards Summary

1. **Error Handling**: Never use `.unwrap()` or `.expect()` in production code. Always use proper `Result<T, E>` types with meaningful error messages.

2. **Trait Design**: Keep traits `dyn` compatible. Use sync methods in traits. No async trait methods.

3. **Breaking Changes**: Never make breaking changes without migration plan. Maintain backward compatibility.

4. **Testing**: Follow AAA pattern, use descriptive names, proper test functions, and test behaviors not implementation.

5. **Code Quality**: Proper module organization, avoid wildcard imports, use structured error types, no false positives.

6. **API Design**: Framework philosophy - composable, extensible, type-safe, zero-cost abstractions.

7. **Performance**: Thin wrapper over clap, maintain clap's performance characteristics.

8. **Documentation**: Comprehensive documentation with examples for all public APIs.

## ‚úÖ Definition of Done - Core Team Standards

### Before any code is considered complete, ALL of these must be true:

1. **‚úÖ Compilation**: Code compiles without errors or warnings
2. **‚úÖ No unwrap()/expect()**: Zero usage of unwrap() or expect() in production code
3. **‚úÖ Trait Compatibility**: All traits remain `dyn` compatible (no async trait methods)
4. **‚úÖ Backward Compatibility**: No breaking changes without migration plan
5. **‚úÖ All Tests Pass**: Every test in the codebase passes
6. **‚úÖ Test Performance**: The ENTIRE test suite completes in <1 second (use concurrency or optimization if needed)
7. **‚úÖ No Linting Errors**: Zero linting errors or warnings
8. **‚úÖ Proper Error Handling**: All functions use Result types with meaningful errors
9. **‚úÖ API Design**: Follows framework philosophy - composable and extensible
10. **‚úÖ Documentation**: All public APIs have documentation with examples

### Validation Checklist:
- [ ] `cargo make test` passes completely
- [ ] `timeout 1s cargo make test && echo "Tests completed in <1s"` passes (entire test suite completes in <1s with parallel execution)
- [ ] `cargo make lint` shows no warnings
- [ ] No `unwrap()` or `expect()` in production code
- [ ] All traits are `dyn` compatible
- [ ] No breaking changes to public APIs
- [ ] All error paths use proper Result types
- [ ] All public APIs have documentation with examples
- [ ] Entire test suite completes in <1s (add concurrency or optimization if needed)

### If ANY of these fail, the code is NOT ready for production.

## ü§ñ AI Code Generation Guidelines

### ‚úÖ Generate production-ready code for clap-noun-verb
```rust
// ‚úÖ Good: Real implementations with proper error handling
pub fn register_noun(&mut self, noun: Box<dyn NounCommand>) -> Result<()> {
    let name = noun.name();
    if self.nouns.contains_key(name) {
        return Err(NounVerbError::invalid_structure(
            format!("Duplicate noun name: {}", name)
        ));
    }
    self.nouns.insert(name.to_string(), noun);
    Ok(())
}

// ‚úÖ Good: Proper argument extraction
pub fn get_one_str(&self, name: &str) -> Result<String> {
    self.matches.get_one::<String>(name)
        .cloned()
        .ok_or_else(|| NounVerbError::missing_argument(name))
}
```

### ‚úÖ Code Generation Checklist
Before generating any code file, ensure:
- [ ] No `unimplemented!()`, `todo!()`, or `panic!()` macros in production code
- [ ] No `.unwrap()` or `.expect()` - use proper error handling
- [ ] All functions return `Result<T>` types
- [ ] All traits are `dyn` compatible
- [ ] Code compiles without warnings
- [ ] Passes `cargo clippy` checks
- [ ] All public APIs have documentation with examples
- [ ] Follows framework philosophy (composable, extensible)

## üìö Documentation Standards

### ‚úÖ Public API Documentation
All public types, traits, and functions must have comprehensive documentation:

```rust
/// A builder for creating composable CLI applications.
///
/// This builder allows you to construct CLI applications using the
/// noun-verb pattern, where commands follow the structure `noun verb`
/// (e.g., `services status`, `collector up`).
///
/// # Example
///
/// ```rust,no_run
/// use clap_noun_verb::{Cli, noun, verb, VerbArgs, Result};
///
/// fn main() -> Result<()> {
///     let cli = Cli::new()
///         .name("myapp")
///         .noun(noun!("services", "Manage services", [
///             verb!("status", "Show status", |_args: &VerbArgs| Ok(())),
///         ]));
///     cli.run()
/// }
/// ```
pub struct CliBuilder {
    // ...
}
```

### ‚úÖ Trait Documentation
Traits should document their contracts and provide usage examples:

```rust
/// A command that represents a noun (group of verbs).
///
/// Nouns are the first level of the noun-verb pattern (e.g., `services`,
/// `collector`). Each noun contains one or more verbs that can be executed.
///
/// # Example
///
/// ```rust,no_run
/// use clap_noun_verb::{NounCommand, VerbCommand, VerbArgs, Result};
///
/// struct MyNoun;
///
/// impl NounCommand for MyNoun {
///     fn name(&self) -> &'static str { "mynoun" }
///     fn about(&self) -> &'static str { "My noun command" }
///     fn verbs(&self) -> Vec<Box<dyn VerbCommand>> { vec![] }
/// }
/// ```
pub trait NounCommand: Send + Sync {
    // ...
}
```

These rules ensure FAANG-level code quality, reliability, and maintainability while following the framework's composable design philosophy.





