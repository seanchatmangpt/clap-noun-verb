{
    "sourceFile": "docs/book/src/porting-commands.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1762032999870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762033034105,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -206,131 +206,52 @@\n     ]),\n ])\n ```\n \n-#### Complete AI Commands Example\n+#### Complete AI Commands Example (v3.0.0)\n \n-Here's the complete AI noun with all verbs:\n+Here's the complete AI noun with all verbs using attribute macros:\n \n ```rust,no_run\n-use clap_noun_verb::{noun, run_cli, verb, VerbArgs, Result};\n-use clap::Arg;\n+use clap_noun_verb_macros::{noun, verb};\n+use clap_noun_verb::Result;\n+use serde::Serialize;\n \n-fn main() -> Result<()> {\n-    run_cli(|cli| {\n-        cli.name(\"ggen\")\n-            .about(\"Rust Template Generator with Frontmatter & RDF Support\")\n-            .noun(noun!(\"ai\", \"AI-powered generation\", [\n-                verb!(\"project\", \"Generate complete projects\", |args: &VerbArgs| {\n-                    let name = args.get_one_str(\"name\")?;\n-                    let description = args.get_one_str_opt(\"description\");\n-                    let rust = args.is_flag_set(\"rust\");\n-                    handle_ai_project(name, description, rust)?;\n-                    Ok(())\n-                }, args: [\n-                    Arg::new(\"name\").required(true),\n-                    Arg::new(\"description\"),\n-                    Arg::new(\"rust\").long(\"rust\"),\n-                ]),\n-    verb!(\"generate\", \"Generate templates from descriptions\", |args: &VerbArgs| {\n-        let description = args.get_one_str(\"description\")?;\n-        let output = args.get_one_str_opt(\"output\");\n-        \n-        // Generate template content\n-        let template_content = format!(\n-            \"// Generated template\\n// Description: {}\\n\\nTemplate code here...\\n\",\n-            description\n-        );\n-        \n-        // Write to output file or stdout\n-        if let Some(output_path) = output {\n-            use std::fs;\n-            fs::write(&output_path, &template_content)\n-                .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-                    format!(\"Failed to write output file: {}\", e)\n-                ))?;\n-            println!(\"✓ Template written to: {}\", output_path);\n-        } else {\n-            println!(\"{}\", template_content);\n-        }\n-        \n-        Ok(())\n-    }, args: [\n-                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n-                    Arg::new(\"output\").short('o').long(\"output\"),\n-                ]),\n-                verb!(\"graph\", \"Generate RDF ontologies\", |args: &VerbArgs| {\n-                    let description = args.get_one_str(\"description\")?;\n-                    let output = args.get_one_str_opt(\"output\");\n-                    // Generate RDF/Turtle content\n-        let rdf_content = format!(\n-            r#\"@prefix ex: <http://example.org/> .\n-@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n+#[derive(Serialize)]\n+struct ProjectOutput {\n+    name: String,\n+    description: Option<String>,\n+    rust: bool,\n+}\n \n-# Generated ontology\n-# Description: {}\n+#[noun(\"ai\", \"AI-powered generation\")]\n+#[verb(\"project\")]\n+fn ai_project(name: String, description: Option<String>, rust: bool) -> Result<ProjectOutput> {\n+    // Arguments automatically inferred: --name (required), --description (optional), --rust (flag)\n+    Ok(ProjectOutput { name, description, rust })\n+}\n \n-ex:ontology rdf:type ex:KnowledgeGraph ;\n-    ex:description \"{}\" .\n-\"#, description, description\n-        );\n-        \n-        // Write to output file or stdout\n-        if let Some(output_path) = output {\n-            use std::fs;\n-            fs::write(&output_path, rdf_content)\n-                .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-                    format!(\"Failed to write RDF file: {}\", e)\n-                ))?;\n-            println!(\"✓ RDF ontology written to: {}\", output_path);\n-        } else {\n-            println!(\"{}\", rdf_content);\n-        }\n-                    Ok(())\n-                }, args: [\n-                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n-                    Arg::new(\"output\").short('o').long(\"output\"),\n-                ]),\n-                verb!(\"sparql\", \"Generate SPARQL queries\", |args: &VerbArgs| {\n-                    let description = args.get_one_str(\"description\")?;\n-                    let graph = args.get_one_str(\"graph\")?;\n-                    let output = args.get_one_str_opt(\"output\");\n-                    // Generate SPARQL query\n-        let sparql_query = format!(\n-            r#\"# Generated SPARQL query\n-# Description: {}\n-# Graph: {}\n+#[verb(\"generate\")]\n+fn ai_generate(description: String, output: Option<String>) -> Result<String> {\n+    // --description (required), --output (optional)\n+    Ok(format!(\"Template generated: {}\", description))\n+}\n \n-PREFIX ex: <http://example.org/>\n-SELECT ?subject ?predicate ?object\n-WHERE {{\n-    GRAPH <{}> {{\n-        ?subject ?predicate ?object .\n-    }}\n-}}\n-\"#, description, graph, graph\n-        );\n-        \n-        // Write to output file or stdout\n-        if let Some(output_path) = output {\n-            use std::fs;\n-            fs::write(&output_path, sparql_query)\n-                .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-                    format!(\"Failed to write SPARQL file: {}\", e)\n-                ))?;\n-            println!(\"✓ SPARQL query written to: {}\", output_path);\n-        } else {\n-            println!(\"{}\", sparql_query);\n-        }\n-                    Ok(())\n-                }, args: [\n-                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n-                    Arg::new(\"graph\").short('g').long(\"graph\").required(true),\n-                    Arg::new(\"output\").short('o').long(\"output\"),\n-                ]),\n-            ]))\n-    })\n+#[verb(\"graph\")]\n+fn ai_graph(description: String, output: Option<String>) -> Result<String> {\n+    // --description (required), --output (optional)\n+    Ok(format!(\"RDF graph generated: {}\", description))\n }\n+\n+#[verb(\"sparql\")]\n+fn ai_sparql(description: String, graph: String, output: Option<String>) -> Result<String> {\n+    // --description (required), --graph (required), --output (optional)\n+    Ok(format!(\"SPARQL query generated: {} for graph: {}\", description, graph))\n+}\n+\n+fn main() -> Result<()> {\n+    clap_noun_verb::run() // Auto-discovers all commands!\n+}\n ```\n \n ### AI graph command\n \n"
                },
                {
                    "date": 1762033470872,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -229,21 +229,22 @@\n     // Arguments automatically inferred: --name (required), --description (optional), --rust (flag)\n     Ok(ProjectOutput { name, description, rust })\n }\n \n-#[verb(\"generate\")]\n+#[verb(\"generate\", \"ai\")]\n fn ai_generate(description: String, output: Option<String>) -> Result<String> {\n     // --description (required), --output (optional)\n+    // Note: Second arg to #[verb] is the noun name (\"ai\")\n     Ok(format!(\"Template generated: {}\", description))\n }\n \n-#[verb(\"graph\")]\n+#[verb(\"graph\", \"ai\")]\n fn ai_graph(description: String, output: Option<String>) -> Result<String> {\n     // --description (required), --output (optional)\n     Ok(format!(\"RDF graph generated: {}\", description))\n }\n \n-#[verb(\"sparql\")]\n+#[verb(\"sparql\", \"ai\")]\n fn ai_sparql(description: String, graph: String, output: Option<String>) -> Result<String> {\n     // --description (required), --graph (required), --output (optional)\n     Ok(format!(\"SPARQL query generated: {} for graph: {}\", description, graph))\n }\n"
                },
                {
                    "date": 1762033514288,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,820 @@\n+# Porting Commands Step-by-Step\n+\n+This chapter provides detailed examples of porting each command group from regular clap to clap-noun-verb, with before/after comparisons.\n+\n+## Porting AI commands\n+\n+The AI commands are perfect candidates for the noun-verb pattern. They all share the `ai` prefix and perform related actions.\n+\n+### AI project command\n+\n+#### Before (Regular clap)\n+\n+```rust,no_run\n+use clap::{Parser, Subcommand, Arg};\n+\n+#[derive(Parser)]\n+struct Cli {\n+    #[command(subcommand)]\n+    command: Commands,\n+}\n+\n+#[derive(Subcommand)]\n+enum Commands {\n+    Ai {\n+        #[command(subcommand)]\n+        command: AiCommands,\n+    },\n+}\n+\n+#[derive(Subcommand)]\n+enum AiCommands {\n+    Project {\n+        name: String,\n+        description: Option<String>,\n+        #[arg(long)]\n+        rust: bool,\n+    },\n+}\n+\n+fn main() {\n+    let cli = Cli::parse();\n+    match cli.command {\n+        Commands::Ai { command } => match command {\n+            AiCommands::Project { name, description, rust } => {\n+                handle_ai_project(name, description, rust);\n+            }\n+            // ... other commands\n+        },\n+        // ... other commands\n+    }\n+}\n+\n+fn handle_ai_project(name: String, description: Option<String>, rust: bool) {\n+    println!(\"Generating AI project: {}\", name);\n+    if let Some(desc) = description {\n+        println!(\"Description: {}\", desc);\n+    }\n+    if rust {\n+        println!(\"Generating Rust project structure...\");\n+    }\n+    println!(\"Project '{}' generated successfully!\", name);\n+}\n+```\n+\n+#### After (clap-noun-verb v3.0.0)\n+\n+```rust,no_run\n+use clap_noun_verb_macros::{noun, verb};\n+use clap_noun_verb::Result;\n+use serde::Serialize;\n+\n+#[derive(Serialize)]\n+struct ProjectOutput {\n+    name: String,\n+    description: Option<String>,\n+    rust: bool,\n+}\n+\n+#[noun(\"ai\", \"AI-powered generation\")]\n+#[verb(\"project\")]\n+fn ai_project(name: String, description: Option<String>, rust: bool) -> Result<ProjectOutput> {\n+    // Arguments automatically inferred from function signature\n+    handle_ai_project(name.clone(), description.clone(), rust)?;\n+    Ok(ProjectOutput { name, description, rust })\n+}\n+\n+fn handle_ai_project(name: String, description: Option<String>, rust: bool) -> Result<()> {\n+    use std::fs;\n+    use std::path::PathBuf;\n+    \n+    println!(\"Generating AI project: {}\", name);\n+    \n+    // Create project directory\n+    let project_dir = PathBuf::from(&name);\n+    fs::create_dir_all(&project_dir)\n+        .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n+            format!(\"Failed to create project directory: {}\", e)\n+        ))?;\n+    \n+    // Write project description if provided\n+    if let Some(desc) = description {\n+        let desc_file = project_dir.join(\"DESCRIPTION.txt\");\n+        fs::write(&desc_file, format!(\"Project: {}\\nDescription: {}\", name, desc))\n+            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n+                format!(\"Failed to write description file: {}\", e)\n+            ))?;\n+    }\n+    \n+    // Generate Rust project structure if requested\n+    if rust {\n+        let cargo_toml = project_dir.join(\"Cargo.toml\");\n+        fs::write(&cargo_toml, format!(\n+            r#\"[package]\n+name = \"{}\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\"#, name\n+        )).map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n+            format!(\"Failed to create Cargo.toml: {}\", e)\n+        ))?;\n+        \n+        let src_dir = project_dir.join(\"src\");\n+        fs::create_dir_all(&src_dir)?;\n+        \n+        let main_rs = src_dir.join(\"main.rs\");\n+        fs::write(&main_rs, \"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\\n\")?;\n+    }\n+    \n+    println!(\"✓ Project '{}' generated successfully!\", name);\n+    Ok(())\n+}\n+```\n+\n+#### Key Changes\n+\n+1. **Eliminated nested enums**: No need for `Commands` and `AiCommands` enums\n+2. **Co-located handler**: Handler is defined inline with the command\n+3. **Type-safe argument extraction**: `get_one_str()` returns `Result<String>`, preventing panics\n+4. **Cleaner structure**: Related commands grouped together\n+\n+### AI generate command\n+\n+#### Before (Regular clap)\n+\n+```rust,no_run\n+#[derive(Subcommand)]\n+enum AiCommands {\n+    // ...\n+    Generate {\n+        #[arg(short, long)]\n+        description: String,\n+        #[arg(short, long)]\n+        output: Option<String>,\n+    },\n+}\n+\n+fn main() {\n+    // ...\n+    match command {\n+        AiCommands::Generate { description, output } => {\n+            handle_ai_generate(description, output);\n+        }\n+        // ...\n+    }\n+}\n+```\n+\n+#### After (clap-noun-verb)\n+\n+```rust,no_run\n+noun!(\"ai\", \"AI-powered generation\", [\n+    // ... project verb\n+    verb!(\"generate\", \"Generate templates from descriptions\", |args: &VerbArgs| {\n+        let description = args.get_one_str(\"description\")?;\n+        let output = args.get_one_str_opt(\"output\");\n+        \n+        // Generate template content\n+        let template_content = format!(\n+            \"// Generated template\\n// Description: {}\\n\\nTemplate code here...\\n\",\n+            description\n+        );\n+        \n+        // Write to output file or stdout\n+        if let Some(output_path) = output {\n+            use std::fs;\n+            fs::write(&output_path, &template_content)\n+                .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n+                    format!(\"Failed to write output file: {}\", e)\n+                ))?;\n+            println!(\"✓ Template written to: {}\", output_path);\n+        } else {\n+            println!(\"{}\", template_content);\n+        }\n+        \n+        Ok(())\n+    }, args: [\n+        Arg::new(\"description\")\n+            .short('d')\n+            .long(\"description\")\n+            .required(true)\n+            .help(\"Template description\"),\n+        Arg::new(\"output\")\n+            .short('o')\n+            .long(\"output\")\n+            .help(\"Output file path\"),\n+    ]),\n+])\n+```\n+\n+#### Complete AI Commands Example (v3.0.0)\n+\n+Here's the complete AI noun with all verbs using attribute macros:\n+\n+```rust,no_run\n+use clap_noun_verb_macros::{noun, verb};\n+use clap_noun_verb::Result;\n+use serde::Serialize;\n+\n+#[derive(Serialize)]\n+struct ProjectOutput {\n+    name: String,\n+    description: Option<String>,\n+    rust: bool,\n+}\n+\n+#[noun(\"ai\", \"AI-powered generation\")]\n+#[verb(\"project\")]\n+fn ai_project(name: String, description: Option<String>, rust: bool) -> Result<ProjectOutput> {\n+    // Arguments automatically inferred: --name (required), --description (optional), --rust (flag)\n+    Ok(ProjectOutput { name, description, rust })\n+}\n+\n+#[verb(\"generate\", \"ai\")]\n+fn ai_generate(description: String, output: Option<String>) -> Result<String> {\n+    // --description (required), --output (optional)\n+    // Note: Second arg to #[verb] is the noun name (\"ai\")\n+    Ok(format!(\"Template generated: {}\", description))\n+}\n+\n+#[verb(\"graph\", \"ai\")]\n+fn ai_graph(description: String, output: Option<String>) -> Result<String> {\n+    // --description (required), --output (optional)\n+    Ok(format!(\"RDF graph generated: {}\", description))\n+}\n+\n+#[verb(\"sparql\", \"ai\")]\n+fn ai_sparql(description: String, graph: String, output: Option<String>) -> Result<String> {\n+    // --description (required), --graph (required), --output (optional)\n+    Ok(format!(\"SPARQL query generated: {} for graph: {}\", description, graph))\n+}\n+\n+fn main() -> Result<()> {\n+    clap_noun_verb::run() // Auto-discovers all commands!\n+}\n+```\n+\n+### AI graph command\n+\n+Similar pattern to `generate`, but for RDF graph generation:\n+\n+```rust,no_run\n+verb!(\"graph\", \"Generate RDF ontologies\", |args: &VerbArgs| {\n+    let description = args.get_one_str(\"description\")?;\n+    let output = args.get_one_str_opt(\"output\");\n+    \n+    // Generate RDF/Turtle content\n+    let rdf_content = format!(\n+        r#\"@prefix ex: <http://example.org/> .\n+@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n+\n+# Generated ontology\n+# Description: {}\n+\n+ex:ontology rdf:type ex:KnowledgeGraph ;\n+    ex:description \"{}\" .\n+\"#, description, description\n+    );\n+    \n+    // Write to output file or stdout\n+    if let Some(output_path) = output {\n+        use std::fs;\n+        fs::write(&output_path, rdf_content)\n+            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n+                format!(\"Failed to write RDF file: {}\", e)\n+            ))?;\n+        println!(\"✓ RDF ontology written to: {}\", output_path);\n+    } else {\n+        println!(\"{}\", rdf_content);\n+    }\n+    \n+    Ok(())\n+}, args: [\n+    Arg::new(\"description\").short('d').long(\"description\").required(true),\n+    Arg::new(\"output\").short('o').long(\"output\"),\n+]),\n+```\n+\n+### AI sparql command\n+\n+Includes an additional required `graph` argument:\n+\n+```rust,no_run\n+verb!(\"sparql\", \"Generate SPARQL queries\", |args: &VerbArgs| {\n+    let description = args.get_one_str(\"description\")?;\n+    let graph = args.get_one_str(\"graph\")?;\n+    let output = args.get_one_str_opt(\"output\");\n+    \n+    // Generate SPARQL query\n+    let sparql_query = format!(\n+        r#\"# Generated SPARQL query\n+# Description: {}\n+# Graph: {}\n+\n+PREFIX ex: <http://example.org/>\n+SELECT ?subject ?predicate ?object\n+WHERE {{\n+    GRAPH <{}> {{\n+        ?subject ?predicate ?object .\n+    }}\n+}}\n+\"#, description, graph, graph\n+    );\n+    \n+    // Write to output file or stdout\n+    if let Some(output_path) = output {\n+        use std::fs;\n+        fs::write(&output_path, sparql_query)\n+            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n+                format!(\"Failed to write SPARQL file: {}\", e)\n+            ))?;\n+        println!(\"✓ SPARQL query written to: {}\", output_path);\n+    } else {\n+        println!(\"{}\", sparql_query);\n+    }\n+    \n+    Ok(())\n+}, args: [\n+    Arg::new(\"description\").short('d').long(\"description\").required(true),\n+    Arg::new(\"graph\").short('g').long(\"graph\").required(true),\n+    Arg::new(\"output\").short('o').long(\"output\"),\n+]),\n+```\n+\n+## Porting marketplace commands\n+\n+Marketplace commands manage template packages. They naturally group under a `marketplace` noun.\n+\n+### Search command\n+\n+#### Before (Regular clap)\n+\n+```rust,no_run\n+#[derive(Subcommand)]\n+enum Commands {\n+    // ...\n+    Search {\n+        query: String,\n+    },\n+}\n+\n+fn main() {\n+    match cli.command {\n+        Commands::Search { query } => {\n+            handle_search(query);\n+        }\n+        // ...\n+    }\n+}\n+```\n+\n+#### After (clap-noun-verb)\n+\n+```rust,no_run\n+noun!(\"marketplace\", \"Template marketplace\", [\n+    verb!(\"search\", \"Find packages\", |args: &VerbArgs| {\n+        let query = args.get_one_str(\"query\")?;\n+        // Search marketplace packages (simulated)\n+        println!(\"Searching marketplace for: '{}'\", query);\n+        println!(\"\");\n+        println!(\"Found packages:\");\n+        println!(\"  1. io.ggen.rust.axum - Rust Axum web framework template\");\n+        println!(\"  2. io.ggen.rust.cli - Rust CLI application template\");\n+        println!(\"  3. io.ggen.python.flask - Python Flask web application\");\n+        println!(\"\");\n+        println!(\"Use 'ggen marketplace add <package>' to install a package\");\n+        Ok(())\n+    }, args: [\n+        Arg::new(\"query\").required(true).help(\"Search query\"),\n+    ]),\n+])\n+```\n+\n+### Add command\n+\n+```rust,no_run\n+verb!(\"add\", \"Install package\", |args: &VerbArgs| {\n+    let package = args.get_one_str(\"package\")?;\n+    // Install package from marketplace\n+    println!(\"Installing package: {}\", package);\n+    \n+    // In real implementation, download and install package\n+    use std::path::PathBuf;\n+    let package_dir = PathBuf::from(\"~/.ggen/packages\").join(&package);\n+    println!(\"  Package location: {}\", package_dir.display());\n+    println!(\"✓ Package '{}' installed successfully\", package);\n+    Ok(())\n+}, args: [\n+    Arg::new(\"package\").required(true).help(\"Package name (e.g., io.ggen.rust.axum)\"),\n+]),\n+```\n+\n+### List command\n+\n+```rust,no_run\n+verb!(\"list\", \"List installed packages\", |args: &VerbArgs| {\n+    // List installed packages\n+    println!(\"Installed packages:\");\n+    println!(\"  io.ggen.rust.axum - v1.2.0\");\n+    println!(\"  io.ggen.rust.cli - v2.0.1\");\n+    println!(\"\");\n+    println!(\"Use 'ggen marketplace update' to update packages\");\n+    Ok(())\n+}),\n+```\n+\n+### Update command\n+\n+```rust,no_run\n+verb!(\"update\", \"Update packages\", |args: &VerbArgs| {\n+    // Update installed packages\n+    println!(\"Checking for package updates...\");\n+    println!(\"  io.ggen.rust.axum: v1.2.0 -> v1.3.0 (update available)\");\n+    println!(\"  io.ggen.rust.cli: v2.0.1 -> v2.0.1 (up to date)\");\n+    println!(\"\");\n+    println!(\"✓ Package update check complete\");\n+    Ok(())\n+}),\n+```\n+\n+#### Complete Marketplace Commands Example\n+\n+```rust,no_run\n+noun!(\"marketplace\", \"Template marketplace\", [\n+    verb!(\"search\", \"Find packages\", |args: &VerbArgs| {\n+        let query = args.get_one_str(\"query\")?;\n+        // Search marketplace packages (simulated)\n+        println!(\"Searching marketplace for: '{}'\", query);\n+        println!(\"\");\n+        println!(\"Found packages:\");\n+        println!(\"  1. io.ggen.rust.axum - Rust Axum web framework template\");\n+        println!(\"  2. io.ggen.rust.cli - Rust CLI application template\");\n+        println!(\"  3. io.ggen.python.flask - Python Flask web application\");\n+        println!(\"\");\n+        println!(\"Use 'ggen marketplace add <package>' to install a package\");\n+        Ok(())\n+    }, args: [\n+        Arg::new(\"query\").required(true),\n+    ]),\n+    verb!(\"add\", \"Install package\", |args: &VerbArgs| {\n+        let package = args.get_one_str(\"package\")?;\n+        \n+        // Install package from marketplace\n+        println!(\"Installing package: {}\", package);\n+        \n+        // In real implementation, download and install package\n+        use std::path::PathBuf;\n+        let package_dir = PathBuf::from(\"~/.ggen/packages\").join(&package);\n+        println!(\"  Package location: {}\", package_dir.display());\n+        println!(\"✓ Package '{}' installed successfully\", package);\n+        \n+        Ok(())\n+    }, args: [\n+        Arg::new(\"package\").required(true),\n+    ]),\n+    verb!(\"list\", \"List installed packages\", |args: &VerbArgs| {\n+        // List installed packages\n+        println!(\"Installed packages:\");\n+        println!(\"  io.ggen.rust.axum - v1.2.0\");\n+        println!(\"  io.ggen.rust.cli - v2.0.1\");\n+        println!(\"\");\n+        println!(\"Use 'ggen marketplace update' to update packages\");\n+        \n+        Ok(())\n+    }),\n+    verb!(\"update\", \"Update packages\", |args: &VerbArgs| {\n+        // Update installed packages\n+        println!(\"Checking for package updates...\");\n+        println!(\"  io.ggen.rust.axum: v1.2.0 -> v1.3.0 (update available)\");\n+        println!(\"  io.ggen.rust.cli: v2.0.1 -> v2.0.1 (up to date)\");\n+        println!(\"\");\n+        println!(\"✓ Package update check complete\");\n+        \n+        Ok(())\n+    }),\n+])\n+```\n+\n+## Porting template commands\n+\n+If ggen has template-specific commands (separate from AI generation), they can be grouped under a `template` noun:\n+\n+```rust,no_run\n+noun!(\"template\", \"Template operations\", [\n+    verb!(\"generate\", \"Generate from template\", |args: &VerbArgs| {\n+        let template = args.get_one_str(\"template\")?;\n+        let vars = args.get_many_opt::<String>(\"vars\");\n+        handle_template_generate(template, vars)?;\n+        Ok(())\n+    }, args: [\n+        Arg::new(\"template\").required(true),\n+        Arg::new(\"vars\").long(\"vars\").num_args(1..),\n+    ]),\n+    verb!(\"validate\", \"Validate template\", |args: &VerbArgs| {\n+        let template = args.get_one_str(\"template\")?;\n+        handle_template_validate(template)?;\n+        Ok(())\n+    }, args: [\n+        Arg::new(\"template\").required(true),\n+    ]),\n+    verb!(\"list\", \"List templates\", |args: &VerbArgs| {\n+        handle_template_list()?;\n+        Ok(())\n+    }),\n+])\n+```\n+\n+## Handling global arguments\n+\n+Global arguments (like `--verbose` and `--config`) are available to all verbs through `VerbArgs`.\n+\n+### Before (Regular clap)\n+\n+```rust,no_run\n+#[derive(Parser)]\n+struct Cli {\n+    #[arg(short, long, action = clap::ArgAction::Count)]\n+    verbose: u8,\n+    \n+    #[arg(short, long)]\n+    config: Option<String>,\n+    \n+    #[command(subcommand)]\n+    command: Commands,\n+}\n+\n+fn main() {\n+    let cli = Cli::parse();\n+    // Pass verbose/config to handlers manually\n+}\n+```\n+\n+### After (clap-noun-verb)\n+\n+```rust,no_run\n+use clap::Arg;\n+\n+run_cli(|cli| {\n+    cli.name(\"ggen\")\n+        .global_args(vec![\n+            Arg::new(\"verbose\")\n+                .short('v')\n+                .long(\"verbose\")\n+                .action(clap::ArgAction::Count)\n+                .help(\"Increase verbosity\"),\n+            Arg::new(\"config\")\n+                .short('c')\n+                .long(\"config\")\n+                .value_name(\"FILE\")\n+                .help(\"Configuration file\"),\n+        ])\n+        .noun(noun!(\"ai\", \"AI-powered generation\", [\n+            verb!(\"project\", \"Generate complete projects\", |args: &VerbArgs| {\n+                // Access global arguments\n+                let verbose = args.get_global_flag_count(\"verbose\");\n+                let config = args.get_global_str(\"config\");\n+                \n+                // Access verb-specific arguments\n+                let name = args.get_one_str(\"name\")?;\n+                \n+                if verbose > 1 {\n+                    println!(\"[DEBUG] Config: {:?}\", config);\n+                }\n+                \n+                // Project generation logic would go here\n+                println!(\"Generating project: {} (verbose: {}, config: {:?})\", name, verbose, config);\n+                Ok(())\n+            }, args: [\n+                Arg::new(\"name\").required(true),\n+            ]),\n+        ]))\n+})\n+```\n+\n+### Using Global Arguments in Handlers\n+\n+All verbs can access global arguments:\n+\n+```rust,no_run\n+verb!(\"generate\", \"Generate templates\", |args: &VerbArgs| {\n+    // Verb-specific\n+    let description = args.get_one_str(\"description\")?;\n+    \n+    // Global arguments\n+    let verbose = args.get_global_flag_count(\"verbose\");\n+    let config = args.get_global_str(\"config\");\n+    \n+    if verbose > 0 {\n+        println!(\"[Verbose] Generating: {}\", description);\n+    }\n+    \n+    if let Some(config_file) = config {\n+        load_config(config_file)?;\n+    }\n+    \n+    // Generate template content\n+    let template_content = format!(\n+        \"// Generated template\\n// Description: {}\\n\\nTemplate code here...\\n\",\n+        description\n+    );\n+    \n+    // Write to output file or stdout\n+    if let Some(output_path) = output {\n+        use std::fs;\n+        fs::write(&output_path, template_content)\n+            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n+                format!(\"Failed to write output file: {}\", e)\n+            ))?;\n+        println!(\"✓ Template written to: {}\", output_path);\n+    } else {\n+        println!(\"{}\", template_content);\n+    }\n+    \n+    Ok(())\n+})\n+```\n+\n+## Complete Example\n+\n+Here's a complete example combining all command groups:\n+\n+```rust,no_run\n+use clap_noun_verb::{noun, run_cli, verb, VerbArgs, Result};\n+use clap::Arg;\n+\n+fn main() -> Result<()> {\n+    run_cli(|cli| {\n+        cli.name(\"ggen\")\n+            .about(\"Rust Template Generator with Frontmatter & RDF Support\")\n+            .version(env!(\"CARGO_PKG_VERSION\"))\n+            .global_args(vec![\n+                Arg::new(\"verbose\")\n+                    .short('v')\n+                    .long(\"verbose\")\n+                    .action(clap::ArgAction::Count)\n+                    .help(\"Increase verbosity\"),\n+                Arg::new(\"config\")\n+                    .short('c')\n+                    .long(\"config\")\n+                    .value_name(\"FILE\")\n+                    .help(\"Configuration file\"),\n+            ])\n+            .noun(noun!(\"ai\", \"AI-powered generation\", [\n+                verb!(\"project\", \"Generate complete projects\", |args: &VerbArgs| {\n+                    let name = args.get_one_str(\"name\")?;\n+                    let description = args.get_one_str_opt(\"description\");\n+                    let rust = args.is_flag_set(\"rust\");\n+                    // Use the complete implementation shown below\n+                    // This calls the full handle_ai_project function\n+                    handle_ai_project(name, description, rust, args)?;\n+                    Ok(())\n+                }, args: [\n+                    Arg::new(\"name\").required(true),\n+                    Arg::new(\"description\"),\n+                    Arg::new(\"rust\").long(\"rust\"),\n+                ]),\n+                verb!(\"generate\", \"Generate templates from descriptions\", |args: &VerbArgs| {\n+                    let description = args.get_one_str(\"description\")?;\n+                    let output = args.get_one_str_opt(\"output\");\n+                    handle_ai_generate(description, output, args)?;\n+                    Ok(())\n+                }, args: [\n+                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n+                    Arg::new(\"output\").short('o').long(\"output\"),\n+                ]),\n+                verb!(\"graph\", \"Generate RDF ontologies\", |args: &VerbArgs| {\n+                    let description = args.get_one_str(\"description\")?;\n+                    let output = args.get_one_str_opt(\"output\");\n+                    handle_ai_graph(description, output, args)?;\n+                    Ok(())\n+                }, args: [\n+                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n+                    Arg::new(\"output\").short('o').long(\"output\"),\n+                ]),\n+                verb!(\"sparql\", \"Generate SPARQL queries\", |args: &VerbArgs| {\n+                    let description = args.get_one_str(\"description\")?;\n+                    let graph = args.get_one_str(\"graph\")?;\n+                    let output = args.get_one_str_opt(\"output\");\n+                    handle_ai_sparql(description, graph, output, args)?;\n+                    Ok(())\n+                }, args: [\n+                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n+                    Arg::new(\"graph\").short('g').long(\"graph\").required(true),\n+                    Arg::new(\"output\").short('o').long(\"output\"),\n+                ]),\n+            ]))\n+            .noun(noun!(\"marketplace\", \"Template marketplace\", [\n+                verb!(\"search\", \"Find packages\", |args: &VerbArgs| {\n+                    let query = args.get_one_str(\"query\")?;\n+                    handle_search(query, args)?;\n+                    Ok(())\n+                }, args: [\n+                    Arg::new(\"query\").required(true),\n+                ]),\n+                verb!(\"add\", \"Install package\", |args: &VerbArgs| {\n+                    let package = args.get_one_str(\"package\")?;\n+                    handle_add(package, args)?;\n+                    Ok(())\n+                }, args: [\n+                    Arg::new(\"package\").required(true),\n+                ]),\n+                verb!(\"list\", \"List installed packages\", |args: &VerbArgs| {\n+                    handle_list(args)?;\n+                    Ok(())\n+                }),\n+                verb!(\"update\", \"Update packages\", |args: &VerbArgs| {\n+                    handle_update(args)?;\n+                    Ok(())\n+                }),\n+            ]))\n+    })\n+}\n+\n+// Handler functions receive VerbArgs for global argument access\n+fn handle_ai_project(name: String, description: Option<String>, rust: bool, args: &VerbArgs) -> Result<()> {\n+    use std::fs;\n+    use std::path::PathBuf;\n+    \n+    let verbose = args.get_global_flag_count(\"verbose\");\n+    let config = args.get_global_str(\"config\");\n+    \n+    if verbose > 0 {\n+        println!(\"[Verbose level {}] Starting project generation\", verbose);\n+        println!(\"  Project name: {}\", name);\n+        if let Some(ref desc) = description {\n+            println!(\"  Description: {}\", desc);\n+        }\n+        println!(\"  Rust project: {}\", rust);\n+        if let Some(ref cfg) = config {\n+            println!(\"  Using config: {}\", cfg);\n+        }\n+    }\n+    \n+    // Load config if provided\n+    if let Some(config_file) = config {\n+        // In real implementation, load and parse config file\n+        if verbose > 1 {\n+            println!(\"[DEBUG] Loading config from: {}\", config_file);\n+        }\n+    }\n+    \n+    // Create project directory\n+    let project_dir = PathBuf::from(&name);\n+    if verbose > 0 {\n+        println!(\"Creating project directory: {}\", project_dir.display());\n+    }\n+    \n+    fs::create_dir_all(&project_dir)\n+        .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n+            format!(\"Failed to create project directory: {}\", e)\n+        ))?;\n+    \n+    // Write project description if provided\n+    if let Some(desc) = description {\n+        let desc_file = project_dir.join(\"DESCRIPTION.txt\");\n+        fs::write(&desc_file, format!(\"Project: {}\\nDescription: {}\", name, desc))\n+            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n+                format!(\"Failed to write description file: {}\", e)\n+            ))?;\n+        \n+        if verbose > 0 {\n+            println!(\"✓ Wrote description file\");\n+        }\n+    }\n+    \n+    // Generate Rust project structure if requested\n+    if rust {\n+        let cargo_toml = project_dir.join(\"Cargo.toml\");\n+        fs::write(&cargo_toml, format!(\n+            r#\"[package]\n+name = \"{}\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\"#, name\n+        )).map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n+            format!(\"Failed to create Cargo.toml: {}\", e)\n+        ))?;\n+        \n+        let src_dir = project_dir.join(\"src\");\n+        fs::create_dir_all(&src_dir)?;\n+        \n+        let main_rs = src_dir.join(\"main.rs\");\n+        fs::write(&main_rs, \"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\\n\")?;\n+        \n+        if verbose > 0 {\n+            println!(\"✓ Created Rust project structure\");\n+        }\n+    }\n+    \n+    println!(\"✓ Project '{}' generated successfully!\", name);\n+    Ok(())\n+}\n+```\n+\n+## Next Steps\n+\n+Now that you've seen how to port commands, learn about:\n+\n+1. [Advanced Patterns](advanced-patterns.md) - Nested commands, custom implementations, and more\n+2. [Testing and Validation](testing-validation.md) - How to test your ported CLI\n+\n"
                },
                {
                    "date": 1762033622682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -817,824 +817,4 @@\n \n 1. [Advanced Patterns](advanced-patterns.md) - Nested commands, custom implementations, and more\n 2. [Testing and Validation](testing-validation.md) - How to test your ported CLI\n \n-# Porting Commands Step-by-Step\n-\n-This chapter provides detailed examples of porting each command group from regular clap to clap-noun-verb, with before/after comparisons.\n-\n-## Porting AI commands\n-\n-The AI commands are perfect candidates for the noun-verb pattern. They all share the `ai` prefix and perform related actions.\n-\n-### AI project command\n-\n-#### Before (Regular clap)\n-\n-```rust,no_run\n-use clap::{Parser, Subcommand, Arg};\n-\n-#[derive(Parser)]\n-struct Cli {\n-    #[command(subcommand)]\n-    command: Commands,\n-}\n-\n-#[derive(Subcommand)]\n-enum Commands {\n-    Ai {\n-        #[command(subcommand)]\n-        command: AiCommands,\n-    },\n-}\n-\n-#[derive(Subcommand)]\n-enum AiCommands {\n-    Project {\n-        name: String,\n-        description: Option<String>,\n-        #[arg(long)]\n-        rust: bool,\n-    },\n-}\n-\n-fn main() {\n-    let cli = Cli::parse();\n-    match cli.command {\n-        Commands::Ai { command } => match command {\n-            AiCommands::Project { name, description, rust } => {\n-                handle_ai_project(name, description, rust);\n-            }\n-            // ... other commands\n-        },\n-        // ... other commands\n-    }\n-}\n-\n-fn handle_ai_project(name: String, description: Option<String>, rust: bool) {\n-    println!(\"Generating AI project: {}\", name);\n-    if let Some(desc) = description {\n-        println!(\"Description: {}\", desc);\n-    }\n-    if rust {\n-        println!(\"Generating Rust project structure...\");\n-    }\n-    println!(\"Project '{}' generated successfully!\", name);\n-}\n-```\n-\n-#### After (clap-noun-verb v3.0.0)\n-\n-```rust,no_run\n-use clap_noun_verb_macros::{noun, verb};\n-use clap_noun_verb::Result;\n-use serde::Serialize;\n-\n-#[derive(Serialize)]\n-struct ProjectOutput {\n-    name: String,\n-    description: Option<String>,\n-    rust: bool,\n-}\n-\n-#[noun(\"ai\", \"AI-powered generation\")]\n-#[verb(\"project\")]\n-fn ai_project(name: String, description: Option<String>, rust: bool) -> Result<ProjectOutput> {\n-    // Arguments automatically inferred from function signature\n-    handle_ai_project(name.clone(), description.clone(), rust)?;\n-    Ok(ProjectOutput { name, description, rust })\n-}\n-\n-fn handle_ai_project(name: String, description: Option<String>, rust: bool) -> Result<()> {\n-    use std::fs;\n-    use std::path::PathBuf;\n-    \n-    println!(\"Generating AI project: {}\", name);\n-    \n-    // Create project directory\n-    let project_dir = PathBuf::from(&name);\n-    fs::create_dir_all(&project_dir)\n-        .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-            format!(\"Failed to create project directory: {}\", e)\n-        ))?;\n-    \n-    // Write project description if provided\n-    if let Some(desc) = description {\n-        let desc_file = project_dir.join(\"DESCRIPTION.txt\");\n-        fs::write(&desc_file, format!(\"Project: {}\\nDescription: {}\", name, desc))\n-            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-                format!(\"Failed to write description file: {}\", e)\n-            ))?;\n-    }\n-    \n-    // Generate Rust project structure if requested\n-    if rust {\n-        let cargo_toml = project_dir.join(\"Cargo.toml\");\n-        fs::write(&cargo_toml, format!(\n-            r#\"[package]\n-name = \"{}\"\n-version = \"0.1.0\"\n-edition = \"2021\"\n-\"#, name\n-        )).map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-            format!(\"Failed to create Cargo.toml: {}\", e)\n-        ))?;\n-        \n-        let src_dir = project_dir.join(\"src\");\n-        fs::create_dir_all(&src_dir)?;\n-        \n-        let main_rs = src_dir.join(\"main.rs\");\n-        fs::write(&main_rs, \"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\\n\")?;\n-    }\n-    \n-    println!(\"✓ Project '{}' generated successfully!\", name);\n-    Ok(())\n-}\n-```\n-\n-#### Key Changes\n-\n-1. **Eliminated nested enums**: No need for `Commands` and `AiCommands` enums\n-2. **Co-located handler**: Handler is defined inline with the command\n-3. **Type-safe argument extraction**: `get_one_str()` returns `Result<String>`, preventing panics\n-4. **Cleaner structure**: Related commands grouped together\n-\n-### AI generate command\n-\n-#### Before (Regular clap)\n-\n-```rust,no_run\n-#[derive(Subcommand)]\n-enum AiCommands {\n-    // ...\n-    Generate {\n-        #[arg(short, long)]\n-        description: String,\n-        #[arg(short, long)]\n-        output: Option<String>,\n-    },\n-}\n-\n-fn main() {\n-    // ...\n-    match command {\n-        AiCommands::Generate { description, output } => {\n-            handle_ai_generate(description, output);\n-        }\n-        // ...\n-    }\n-}\n-```\n-\n-#### After (clap-noun-verb)\n-\n-```rust,no_run\n-noun!(\"ai\", \"AI-powered generation\", [\n-    // ... project verb\n-    verb!(\"generate\", \"Generate templates from descriptions\", |args: &VerbArgs| {\n-        let description = args.get_one_str(\"description\")?;\n-        let output = args.get_one_str_opt(\"output\");\n-        \n-        // Generate template content\n-        let template_content = format!(\n-            \"// Generated template\\n// Description: {}\\n\\nTemplate code here...\\n\",\n-            description\n-        );\n-        \n-        // Write to output file or stdout\n-        if let Some(output_path) = output {\n-            use std::fs;\n-            fs::write(&output_path, &template_content)\n-                .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-                    format!(\"Failed to write output file: {}\", e)\n-                ))?;\n-            println!(\"✓ Template written to: {}\", output_path);\n-        } else {\n-            println!(\"{}\", template_content);\n-        }\n-        \n-        Ok(())\n-    }, args: [\n-        Arg::new(\"description\")\n-            .short('d')\n-            .long(\"description\")\n-            .required(true)\n-            .help(\"Template description\"),\n-        Arg::new(\"output\")\n-            .short('o')\n-            .long(\"output\")\n-            .help(\"Output file path\"),\n-    ]),\n-])\n-```\n-\n-#### Complete AI Commands Example (v3.0.0)\n-\n-Here's the complete AI noun with all verbs using attribute macros:\n-\n-```rust,no_run\n-use clap_noun_verb_macros::{noun, verb};\n-use clap_noun_verb::Result;\n-use serde::Serialize;\n-\n-#[derive(Serialize)]\n-struct ProjectOutput {\n-    name: String,\n-    description: Option<String>,\n-    rust: bool,\n-}\n-\n-#[noun(\"ai\", \"AI-powered generation\")]\n-#[verb(\"project\")]\n-fn ai_project(name: String, description: Option<String>, rust: bool) -> Result<ProjectOutput> {\n-    // Arguments automatically inferred: --name (required), --description (optional), --rust (flag)\n-    Ok(ProjectOutput { name, description, rust })\n-}\n-\n-#[verb(\"generate\", \"ai\")]\n-fn ai_generate(description: String, output: Option<String>) -> Result<String> {\n-    // --description (required), --output (optional)\n-    // Note: Second arg to #[verb] is the noun name (\"ai\")\n-    Ok(format!(\"Template generated: {}\", description))\n-}\n-\n-#[verb(\"graph\", \"ai\")]\n-fn ai_graph(description: String, output: Option<String>) -> Result<String> {\n-    // --description (required), --output (optional)\n-    Ok(format!(\"RDF graph generated: {}\", description))\n-}\n-\n-#[verb(\"sparql\", \"ai\")]\n-fn ai_sparql(description: String, graph: String, output: Option<String>) -> Result<String> {\n-    // --description (required), --graph (required), --output (optional)\n-    Ok(format!(\"SPARQL query generated: {} for graph: {}\", description, graph))\n-}\n-\n-fn main() -> Result<()> {\n-    clap_noun_verb::run() // Auto-discovers all commands!\n-}\n-```\n-\n-### AI graph command\n-\n-Similar pattern to `generate`, but for RDF graph generation:\n-\n-```rust,no_run\n-verb!(\"graph\", \"Generate RDF ontologies\", |args: &VerbArgs| {\n-    let description = args.get_one_str(\"description\")?;\n-    let output = args.get_one_str_opt(\"output\");\n-    \n-    // Generate RDF/Turtle content\n-    let rdf_content = format!(\n-        r#\"@prefix ex: <http://example.org/> .\n-@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n-\n-# Generated ontology\n-# Description: {}\n-\n-ex:ontology rdf:type ex:KnowledgeGraph ;\n-    ex:description \"{}\" .\n-\"#, description, description\n-    );\n-    \n-    // Write to output file or stdout\n-    if let Some(output_path) = output {\n-        use std::fs;\n-        fs::write(&output_path, rdf_content)\n-            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-                format!(\"Failed to write RDF file: {}\", e)\n-            ))?;\n-        println!(\"✓ RDF ontology written to: {}\", output_path);\n-    } else {\n-        println!(\"{}\", rdf_content);\n-    }\n-    \n-    Ok(())\n-}, args: [\n-    Arg::new(\"description\").short('d').long(\"description\").required(true),\n-    Arg::new(\"output\").short('o').long(\"output\"),\n-]),\n-```\n-\n-### AI sparql command\n-\n-Includes an additional required `graph` argument:\n-\n-```rust,no_run\n-verb!(\"sparql\", \"Generate SPARQL queries\", |args: &VerbArgs| {\n-    let description = args.get_one_str(\"description\")?;\n-    let graph = args.get_one_str(\"graph\")?;\n-    let output = args.get_one_str_opt(\"output\");\n-    \n-    // Generate SPARQL query\n-    let sparql_query = format!(\n-        r#\"# Generated SPARQL query\n-# Description: {}\n-# Graph: {}\n-\n-PREFIX ex: <http://example.org/>\n-SELECT ?subject ?predicate ?object\n-WHERE {{\n-    GRAPH <{}> {{\n-        ?subject ?predicate ?object .\n-    }}\n-}}\n-\"#, description, graph, graph\n-    );\n-    \n-    // Write to output file or stdout\n-    if let Some(output_path) = output {\n-        use std::fs;\n-        fs::write(&output_path, sparql_query)\n-            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-                format!(\"Failed to write SPARQL file: {}\", e)\n-            ))?;\n-        println!(\"✓ SPARQL query written to: {}\", output_path);\n-    } else {\n-        println!(\"{}\", sparql_query);\n-    }\n-    \n-    Ok(())\n-}, args: [\n-    Arg::new(\"description\").short('d').long(\"description\").required(true),\n-    Arg::new(\"graph\").short('g').long(\"graph\").required(true),\n-    Arg::new(\"output\").short('o').long(\"output\"),\n-]),\n-```\n-\n-## Porting marketplace commands\n-\n-Marketplace commands manage template packages. They naturally group under a `marketplace` noun.\n-\n-### Search command\n-\n-#### Before (Regular clap)\n-\n-```rust,no_run\n-#[derive(Subcommand)]\n-enum Commands {\n-    // ...\n-    Search {\n-        query: String,\n-    },\n-}\n-\n-fn main() {\n-    match cli.command {\n-        Commands::Search { query } => {\n-            handle_search(query);\n-        }\n-        // ...\n-    }\n-}\n-```\n-\n-#### After (clap-noun-verb)\n-\n-```rust,no_run\n-noun!(\"marketplace\", \"Template marketplace\", [\n-    verb!(\"search\", \"Find packages\", |args: &VerbArgs| {\n-        let query = args.get_one_str(\"query\")?;\n-        // Search marketplace packages (simulated)\n-        println!(\"Searching marketplace for: '{}'\", query);\n-        println!(\"\");\n-        println!(\"Found packages:\");\n-        println!(\"  1. io.ggen.rust.axum - Rust Axum web framework template\");\n-        println!(\"  2. io.ggen.rust.cli - Rust CLI application template\");\n-        println!(\"  3. io.ggen.python.flask - Python Flask web application\");\n-        println!(\"\");\n-        println!(\"Use 'ggen marketplace add <package>' to install a package\");\n-        Ok(())\n-    }, args: [\n-        Arg::new(\"query\").required(true).help(\"Search query\"),\n-    ]),\n-])\n-```\n-\n-### Add command\n-\n-```rust,no_run\n-verb!(\"add\", \"Install package\", |args: &VerbArgs| {\n-    let package = args.get_one_str(\"package\")?;\n-    // Install package from marketplace\n-    println!(\"Installing package: {}\", package);\n-    \n-    // In real implementation, download and install package\n-    use std::path::PathBuf;\n-    let package_dir = PathBuf::from(\"~/.ggen/packages\").join(&package);\n-    println!(\"  Package location: {}\", package_dir.display());\n-    println!(\"✓ Package '{}' installed successfully\", package);\n-    Ok(())\n-}, args: [\n-    Arg::new(\"package\").required(true).help(\"Package name (e.g., io.ggen.rust.axum)\"),\n-]),\n-```\n-\n-### List command\n-\n-```rust,no_run\n-verb!(\"list\", \"List installed packages\", |args: &VerbArgs| {\n-    // List installed packages\n-    println!(\"Installed packages:\");\n-    println!(\"  io.ggen.rust.axum - v1.2.0\");\n-    println!(\"  io.ggen.rust.cli - v2.0.1\");\n-    println!(\"\");\n-    println!(\"Use 'ggen marketplace update' to update packages\");\n-    Ok(())\n-}),\n-```\n-\n-### Update command\n-\n-```rust,no_run\n-verb!(\"update\", \"Update packages\", |args: &VerbArgs| {\n-    // Update installed packages\n-    println!(\"Checking for package updates...\");\n-    println!(\"  io.ggen.rust.axum: v1.2.0 -> v1.3.0 (update available)\");\n-    println!(\"  io.ggen.rust.cli: v2.0.1 -> v2.0.1 (up to date)\");\n-    println!(\"\");\n-    println!(\"✓ Package update check complete\");\n-    Ok(())\n-}),\n-```\n-\n-#### Complete Marketplace Commands Example\n-\n-```rust,no_run\n-noun!(\"marketplace\", \"Template marketplace\", [\n-    verb!(\"search\", \"Find packages\", |args: &VerbArgs| {\n-        let query = args.get_one_str(\"query\")?;\n-        // Search marketplace packages (simulated)\n-        println!(\"Searching marketplace for: '{}'\", query);\n-        println!(\"\");\n-        println!(\"Found packages:\");\n-        println!(\"  1. io.ggen.rust.axum - Rust Axum web framework template\");\n-        println!(\"  2. io.ggen.rust.cli - Rust CLI application template\");\n-        println!(\"  3. io.ggen.python.flask - Python Flask web application\");\n-        println!(\"\");\n-        println!(\"Use 'ggen marketplace add <package>' to install a package\");\n-        Ok(())\n-    }, args: [\n-        Arg::new(\"query\").required(true),\n-    ]),\n-    verb!(\"add\", \"Install package\", |args: &VerbArgs| {\n-        let package = args.get_one_str(\"package\")?;\n-        \n-        // Install package from marketplace\n-        println!(\"Installing package: {}\", package);\n-        \n-        // In real implementation, download and install package\n-        use std::path::PathBuf;\n-        let package_dir = PathBuf::from(\"~/.ggen/packages\").join(&package);\n-        println!(\"  Package location: {}\", package_dir.display());\n-        println!(\"✓ Package '{}' installed successfully\", package);\n-        \n-        Ok(())\n-    }, args: [\n-        Arg::new(\"package\").required(true),\n-    ]),\n-    verb!(\"list\", \"List installed packages\", |args: &VerbArgs| {\n-        // List installed packages\n-        println!(\"Installed packages:\");\n-        println!(\"  io.ggen.rust.axum - v1.2.0\");\n-        println!(\"  io.ggen.rust.cli - v2.0.1\");\n-        println!(\"\");\n-        println!(\"Use 'ggen marketplace update' to update packages\");\n-        \n-        Ok(())\n-    }),\n-    verb!(\"update\", \"Update packages\", |args: &VerbArgs| {\n-        // Update installed packages\n-        println!(\"Checking for package updates...\");\n-        println!(\"  io.ggen.rust.axum: v1.2.0 -> v1.3.0 (update available)\");\n-        println!(\"  io.ggen.rust.cli: v2.0.1 -> v2.0.1 (up to date)\");\n-        println!(\"\");\n-        println!(\"✓ Package update check complete\");\n-        \n-        Ok(())\n-    }),\n-])\n-```\n-\n-## Porting template commands\n-\n-If ggen has template-specific commands (separate from AI generation), they can be grouped under a `template` noun:\n-\n-```rust,no_run\n-noun!(\"template\", \"Template operations\", [\n-    verb!(\"generate\", \"Generate from template\", |args: &VerbArgs| {\n-        let template = args.get_one_str(\"template\")?;\n-        let vars = args.get_many_opt::<String>(\"vars\");\n-        handle_template_generate(template, vars)?;\n-        Ok(())\n-    }, args: [\n-        Arg::new(\"template\").required(true),\n-        Arg::new(\"vars\").long(\"vars\").num_args(1..),\n-    ]),\n-    verb!(\"validate\", \"Validate template\", |args: &VerbArgs| {\n-        let template = args.get_one_str(\"template\")?;\n-        handle_template_validate(template)?;\n-        Ok(())\n-    }, args: [\n-        Arg::new(\"template\").required(true),\n-    ]),\n-    verb!(\"list\", \"List templates\", |args: &VerbArgs| {\n-        handle_template_list()?;\n-        Ok(())\n-    }),\n-])\n-```\n-\n-## Handling global arguments\n-\n-Global arguments (like `--verbose` and `--config`) are available to all verbs through `VerbArgs`.\n-\n-### Before (Regular clap)\n-\n-```rust,no_run\n-#[derive(Parser)]\n-struct Cli {\n-    #[arg(short, long, action = clap::ArgAction::Count)]\n-    verbose: u8,\n-    \n-    #[arg(short, long)]\n-    config: Option<String>,\n-    \n-    #[command(subcommand)]\n-    command: Commands,\n-}\n-\n-fn main() {\n-    let cli = Cli::parse();\n-    // Pass verbose/config to handlers manually\n-}\n-```\n-\n-### After (clap-noun-verb)\n-\n-```rust,no_run\n-use clap::Arg;\n-\n-run_cli(|cli| {\n-    cli.name(\"ggen\")\n-        .global_args(vec![\n-            Arg::new(\"verbose\")\n-                .short('v')\n-                .long(\"verbose\")\n-                .action(clap::ArgAction::Count)\n-                .help(\"Increase verbosity\"),\n-            Arg::new(\"config\")\n-                .short('c')\n-                .long(\"config\")\n-                .value_name(\"FILE\")\n-                .help(\"Configuration file\"),\n-        ])\n-        .noun(noun!(\"ai\", \"AI-powered generation\", [\n-            verb!(\"project\", \"Generate complete projects\", |args: &VerbArgs| {\n-                // Access global arguments\n-                let verbose = args.get_global_flag_count(\"verbose\");\n-                let config = args.get_global_str(\"config\");\n-                \n-                // Access verb-specific arguments\n-                let name = args.get_one_str(\"name\")?;\n-                \n-                if verbose > 1 {\n-                    println!(\"[DEBUG] Config: {:?}\", config);\n-                }\n-                \n-                // Project generation logic would go here\n-                println!(\"Generating project: {} (verbose: {}, config: {:?})\", name, verbose, config);\n-                Ok(())\n-            }, args: [\n-                Arg::new(\"name\").required(true),\n-            ]),\n-        ]))\n-})\n-```\n-\n-### Using Global Arguments in Handlers\n-\n-All verbs can access global arguments:\n-\n-```rust,no_run\n-verb!(\"generate\", \"Generate templates\", |args: &VerbArgs| {\n-    // Verb-specific\n-    let description = args.get_one_str(\"description\")?;\n-    \n-    // Global arguments\n-    let verbose = args.get_global_flag_count(\"verbose\");\n-    let config = args.get_global_str(\"config\");\n-    \n-    if verbose > 0 {\n-        println!(\"[Verbose] Generating: {}\", description);\n-    }\n-    \n-    if let Some(config_file) = config {\n-        load_config(config_file)?;\n-    }\n-    \n-    // Generate template content\n-    let template_content = format!(\n-        \"// Generated template\\n// Description: {}\\n\\nTemplate code here...\\n\",\n-        description\n-    );\n-    \n-    // Write to output file or stdout\n-    if let Some(output_path) = output {\n-        use std::fs;\n-        fs::write(&output_path, template_content)\n-            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-                format!(\"Failed to write output file: {}\", e)\n-            ))?;\n-        println!(\"✓ Template written to: {}\", output_path);\n-    } else {\n-        println!(\"{}\", template_content);\n-    }\n-    \n-    Ok(())\n-})\n-```\n-\n-## Complete Example\n-\n-Here's a complete example combining all command groups:\n-\n-```rust,no_run\n-use clap_noun_verb::{noun, run_cli, verb, VerbArgs, Result};\n-use clap::Arg;\n-\n-fn main() -> Result<()> {\n-    run_cli(|cli| {\n-        cli.name(\"ggen\")\n-            .about(\"Rust Template Generator with Frontmatter & RDF Support\")\n-            .version(env!(\"CARGO_PKG_VERSION\"))\n-            .global_args(vec![\n-                Arg::new(\"verbose\")\n-                    .short('v')\n-                    .long(\"verbose\")\n-                    .action(clap::ArgAction::Count)\n-                    .help(\"Increase verbosity\"),\n-                Arg::new(\"config\")\n-                    .short('c')\n-                    .long(\"config\")\n-                    .value_name(\"FILE\")\n-                    .help(\"Configuration file\"),\n-            ])\n-            .noun(noun!(\"ai\", \"AI-powered generation\", [\n-                verb!(\"project\", \"Generate complete projects\", |args: &VerbArgs| {\n-                    let name = args.get_one_str(\"name\")?;\n-                    let description = args.get_one_str_opt(\"description\");\n-                    let rust = args.is_flag_set(\"rust\");\n-                    // Use the complete implementation shown below\n-                    // This calls the full handle_ai_project function\n-                    handle_ai_project(name, description, rust, args)?;\n-                    Ok(())\n-                }, args: [\n-                    Arg::new(\"name\").required(true),\n-                    Arg::new(\"description\"),\n-                    Arg::new(\"rust\").long(\"rust\"),\n-                ]),\n-                verb!(\"generate\", \"Generate templates from descriptions\", |args: &VerbArgs| {\n-                    let description = args.get_one_str(\"description\")?;\n-                    let output = args.get_one_str_opt(\"output\");\n-                    handle_ai_generate(description, output, args)?;\n-                    Ok(())\n-                }, args: [\n-                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n-                    Arg::new(\"output\").short('o').long(\"output\"),\n-                ]),\n-                verb!(\"graph\", \"Generate RDF ontologies\", |args: &VerbArgs| {\n-                    let description = args.get_one_str(\"description\")?;\n-                    let output = args.get_one_str_opt(\"output\");\n-                    handle_ai_graph(description, output, args)?;\n-                    Ok(())\n-                }, args: [\n-                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n-                    Arg::new(\"output\").short('o').long(\"output\"),\n-                ]),\n-                verb!(\"sparql\", \"Generate SPARQL queries\", |args: &VerbArgs| {\n-                    let description = args.get_one_str(\"description\")?;\n-                    let graph = args.get_one_str(\"graph\")?;\n-                    let output = args.get_one_str_opt(\"output\");\n-                    handle_ai_sparql(description, graph, output, args)?;\n-                    Ok(())\n-                }, args: [\n-                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n-                    Arg::new(\"graph\").short('g').long(\"graph\").required(true),\n-                    Arg::new(\"output\").short('o').long(\"output\"),\n-                ]),\n-            ]))\n-            .noun(noun!(\"marketplace\", \"Template marketplace\", [\n-                verb!(\"search\", \"Find packages\", |args: &VerbArgs| {\n-                    let query = args.get_one_str(\"query\")?;\n-                    handle_search(query, args)?;\n-                    Ok(())\n-                }, args: [\n-                    Arg::new(\"query\").required(true),\n-                ]),\n-                verb!(\"add\", \"Install package\", |args: &VerbArgs| {\n-                    let package = args.get_one_str(\"package\")?;\n-                    handle_add(package, args)?;\n-                    Ok(())\n-                }, args: [\n-                    Arg::new(\"package\").required(true),\n-                ]),\n-                verb!(\"list\", \"List installed packages\", |args: &VerbArgs| {\n-                    handle_list(args)?;\n-                    Ok(())\n-                }),\n-                verb!(\"update\", \"Update packages\", |args: &VerbArgs| {\n-                    handle_update(args)?;\n-                    Ok(())\n-                }),\n-            ]))\n-    })\n-}\n-\n-// Handler functions receive VerbArgs for global argument access\n-fn handle_ai_project(name: String, description: Option<String>, rust: bool, args: &VerbArgs) -> Result<()> {\n-    use std::fs;\n-    use std::path::PathBuf;\n-    \n-    let verbose = args.get_global_flag_count(\"verbose\");\n-    let config = args.get_global_str(\"config\");\n-    \n-    if verbose > 0 {\n-        println!(\"[Verbose level {}] Starting project generation\", verbose);\n-        println!(\"  Project name: {}\", name);\n-        if let Some(ref desc) = description {\n-            println!(\"  Description: {}\", desc);\n-        }\n-        println!(\"  Rust project: {}\", rust);\n-        if let Some(ref cfg) = config {\n-            println!(\"  Using config: {}\", cfg);\n-        }\n-    }\n-    \n-    // Load config if provided\n-    if let Some(config_file) = config {\n-        // In real implementation, load and parse config file\n-        if verbose > 1 {\n-            println!(\"[DEBUG] Loading config from: {}\", config_file);\n-        }\n-    }\n-    \n-    // Create project directory\n-    let project_dir = PathBuf::from(&name);\n-    if verbose > 0 {\n-        println!(\"Creating project directory: {}\", project_dir.display());\n-    }\n-    \n-    fs::create_dir_all(&project_dir)\n-        .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-            format!(\"Failed to create project directory: {}\", e)\n-        ))?;\n-    \n-    // Write project description if provided\n-    if let Some(desc) = description {\n-        let desc_file = project_dir.join(\"DESCRIPTION.txt\");\n-        fs::write(&desc_file, format!(\"Project: {}\\nDescription: {}\", name, desc))\n-            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-                format!(\"Failed to write description file: {}\", e)\n-            ))?;\n-        \n-        if verbose > 0 {\n-            println!(\"✓ Wrote description file\");\n-        }\n-    }\n-    \n-    // Generate Rust project structure if requested\n-    if rust {\n-        let cargo_toml = project_dir.join(\"Cargo.toml\");\n-        fs::write(&cargo_toml, format!(\n-            r#\"[package]\n-name = \"{}\"\n-version = \"0.1.0\"\n-edition = \"2021\"\n-\"#, name\n-        )).map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n-            format!(\"Failed to create Cargo.toml: {}\", e)\n-        ))?;\n-        \n-        let src_dir = project_dir.join(\"src\");\n-        fs::create_dir_all(&src_dir)?;\n-        \n-        let main_rs = src_dir.join(\"main.rs\");\n-        fs::write(&main_rs, \"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\\n\")?;\n-        \n-        if verbose > 0 {\n-            println!(\"✓ Created Rust project structure\");\n-        }\n-    }\n-    \n-    println!(\"✓ Project '{}' generated successfully!\", name);\n-    Ok(())\n-}\n-```\n-\n-## Next Steps\n-\n-Now that you've seen how to port commands, learn about:\n-\n-1. [Advanced Patterns](advanced-patterns.md) - Nested commands, custom implementations, and more\n-2. [Testing and Validation](testing-validation.md) - How to test your ported CLI\n-\n"
                }
            ],
            "date": 1762032999870,
            "name": "Commit-0",
            "content": "# Porting Commands Step-by-Step\n\nThis chapter provides detailed examples of porting each command group from regular clap to clap-noun-verb, with before/after comparisons.\n\n## Porting AI commands\n\nThe AI commands are perfect candidates for the noun-verb pattern. They all share the `ai` prefix and perform related actions.\n\n### AI project command\n\n#### Before (Regular clap)\n\n```rust,no_run\nuse clap::{Parser, Subcommand, Arg};\n\n#[derive(Parser)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    Ai {\n        #[command(subcommand)]\n        command: AiCommands,\n    },\n}\n\n#[derive(Subcommand)]\nenum AiCommands {\n    Project {\n        name: String,\n        description: Option<String>,\n        #[arg(long)]\n        rust: bool,\n    },\n}\n\nfn main() {\n    let cli = Cli::parse();\n    match cli.command {\n        Commands::Ai { command } => match command {\n            AiCommands::Project { name, description, rust } => {\n                handle_ai_project(name, description, rust);\n            }\n            // ... other commands\n        },\n        // ... other commands\n    }\n}\n\nfn handle_ai_project(name: String, description: Option<String>, rust: bool) {\n    println!(\"Generating AI project: {}\", name);\n    if let Some(desc) = description {\n        println!(\"Description: {}\", desc);\n    }\n    if rust {\n        println!(\"Generating Rust project structure...\");\n    }\n    println!(\"Project '{}' generated successfully!\", name);\n}\n```\n\n#### After (clap-noun-verb v3.0.0)\n\n```rust,no_run\nuse clap_noun_verb_macros::{noun, verb};\nuse clap_noun_verb::Result;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct ProjectOutput {\n    name: String,\n    description: Option<String>,\n    rust: bool,\n}\n\n#[noun(\"ai\", \"AI-powered generation\")]\n#[verb(\"project\")]\nfn ai_project(name: String, description: Option<String>, rust: bool) -> Result<ProjectOutput> {\n    // Arguments automatically inferred from function signature\n    handle_ai_project(name.clone(), description.clone(), rust)?;\n    Ok(ProjectOutput { name, description, rust })\n}\n\nfn handle_ai_project(name: String, description: Option<String>, rust: bool) -> Result<()> {\n    use std::fs;\n    use std::path::PathBuf;\n    \n    println!(\"Generating AI project: {}\", name);\n    \n    // Create project directory\n    let project_dir = PathBuf::from(&name);\n    fs::create_dir_all(&project_dir)\n        .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n            format!(\"Failed to create project directory: {}\", e)\n        ))?;\n    \n    // Write project description if provided\n    if let Some(desc) = description {\n        let desc_file = project_dir.join(\"DESCRIPTION.txt\");\n        fs::write(&desc_file, format!(\"Project: {}\\nDescription: {}\", name, desc))\n            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n                format!(\"Failed to write description file: {}\", e)\n            ))?;\n    }\n    \n    // Generate Rust project structure if requested\n    if rust {\n        let cargo_toml = project_dir.join(\"Cargo.toml\");\n        fs::write(&cargo_toml, format!(\n            r#\"[package]\nname = \"{}\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\"#, name\n        )).map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n            format!(\"Failed to create Cargo.toml: {}\", e)\n        ))?;\n        \n        let src_dir = project_dir.join(\"src\");\n        fs::create_dir_all(&src_dir)?;\n        \n        let main_rs = src_dir.join(\"main.rs\");\n        fs::write(&main_rs, \"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\\n\")?;\n    }\n    \n    println!(\"✓ Project '{}' generated successfully!\", name);\n    Ok(())\n}\n```\n\n#### Key Changes\n\n1. **Eliminated nested enums**: No need for `Commands` and `AiCommands` enums\n2. **Co-located handler**: Handler is defined inline with the command\n3. **Type-safe argument extraction**: `get_one_str()` returns `Result<String>`, preventing panics\n4. **Cleaner structure**: Related commands grouped together\n\n### AI generate command\n\n#### Before (Regular clap)\n\n```rust,no_run\n#[derive(Subcommand)]\nenum AiCommands {\n    // ...\n    Generate {\n        #[arg(short, long)]\n        description: String,\n        #[arg(short, long)]\n        output: Option<String>,\n    },\n}\n\nfn main() {\n    // ...\n    match command {\n        AiCommands::Generate { description, output } => {\n            handle_ai_generate(description, output);\n        }\n        // ...\n    }\n}\n```\n\n#### After (clap-noun-verb)\n\n```rust,no_run\nnoun!(\"ai\", \"AI-powered generation\", [\n    // ... project verb\n    verb!(\"generate\", \"Generate templates from descriptions\", |args: &VerbArgs| {\n        let description = args.get_one_str(\"description\")?;\n        let output = args.get_one_str_opt(\"output\");\n        \n        // Generate template content\n        let template_content = format!(\n            \"// Generated template\\n// Description: {}\\n\\nTemplate code here...\\n\",\n            description\n        );\n        \n        // Write to output file or stdout\n        if let Some(output_path) = output {\n            use std::fs;\n            fs::write(&output_path, &template_content)\n                .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n                    format!(\"Failed to write output file: {}\", e)\n                ))?;\n            println!(\"✓ Template written to: {}\", output_path);\n        } else {\n            println!(\"{}\", template_content);\n        }\n        \n        Ok(())\n    }, args: [\n        Arg::new(\"description\")\n            .short('d')\n            .long(\"description\")\n            .required(true)\n            .help(\"Template description\"),\n        Arg::new(\"output\")\n            .short('o')\n            .long(\"output\")\n            .help(\"Output file path\"),\n    ]),\n])\n```\n\n#### Complete AI Commands Example\n\nHere's the complete AI noun with all verbs:\n\n```rust,no_run\nuse clap_noun_verb::{noun, run_cli, verb, VerbArgs, Result};\nuse clap::Arg;\n\nfn main() -> Result<()> {\n    run_cli(|cli| {\n        cli.name(\"ggen\")\n            .about(\"Rust Template Generator with Frontmatter & RDF Support\")\n            .noun(noun!(\"ai\", \"AI-powered generation\", [\n                verb!(\"project\", \"Generate complete projects\", |args: &VerbArgs| {\n                    let name = args.get_one_str(\"name\")?;\n                    let description = args.get_one_str_opt(\"description\");\n                    let rust = args.is_flag_set(\"rust\");\n                    handle_ai_project(name, description, rust)?;\n                    Ok(())\n                }, args: [\n                    Arg::new(\"name\").required(true),\n                    Arg::new(\"description\"),\n                    Arg::new(\"rust\").long(\"rust\"),\n                ]),\n    verb!(\"generate\", \"Generate templates from descriptions\", |args: &VerbArgs| {\n        let description = args.get_one_str(\"description\")?;\n        let output = args.get_one_str_opt(\"output\");\n        \n        // Generate template content\n        let template_content = format!(\n            \"// Generated template\\n// Description: {}\\n\\nTemplate code here...\\n\",\n            description\n        );\n        \n        // Write to output file or stdout\n        if let Some(output_path) = output {\n            use std::fs;\n            fs::write(&output_path, &template_content)\n                .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n                    format!(\"Failed to write output file: {}\", e)\n                ))?;\n            println!(\"✓ Template written to: {}\", output_path);\n        } else {\n            println!(\"{}\", template_content);\n        }\n        \n        Ok(())\n    }, args: [\n                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n                    Arg::new(\"output\").short('o').long(\"output\"),\n                ]),\n                verb!(\"graph\", \"Generate RDF ontologies\", |args: &VerbArgs| {\n                    let description = args.get_one_str(\"description\")?;\n                    let output = args.get_one_str_opt(\"output\");\n                    // Generate RDF/Turtle content\n        let rdf_content = format!(\n            r#\"@prefix ex: <http://example.org/> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n\n# Generated ontology\n# Description: {}\n\nex:ontology rdf:type ex:KnowledgeGraph ;\n    ex:description \"{}\" .\n\"#, description, description\n        );\n        \n        // Write to output file or stdout\n        if let Some(output_path) = output {\n            use std::fs;\n            fs::write(&output_path, rdf_content)\n                .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n                    format!(\"Failed to write RDF file: {}\", e)\n                ))?;\n            println!(\"✓ RDF ontology written to: {}\", output_path);\n        } else {\n            println!(\"{}\", rdf_content);\n        }\n                    Ok(())\n                }, args: [\n                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n                    Arg::new(\"output\").short('o').long(\"output\"),\n                ]),\n                verb!(\"sparql\", \"Generate SPARQL queries\", |args: &VerbArgs| {\n                    let description = args.get_one_str(\"description\")?;\n                    let graph = args.get_one_str(\"graph\")?;\n                    let output = args.get_one_str_opt(\"output\");\n                    // Generate SPARQL query\n        let sparql_query = format!(\n            r#\"# Generated SPARQL query\n# Description: {}\n# Graph: {}\n\nPREFIX ex: <http://example.org/>\nSELECT ?subject ?predicate ?object\nWHERE {{\n    GRAPH <{}> {{\n        ?subject ?predicate ?object .\n    }}\n}}\n\"#, description, graph, graph\n        );\n        \n        // Write to output file or stdout\n        if let Some(output_path) = output {\n            use std::fs;\n            fs::write(&output_path, sparql_query)\n                .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n                    format!(\"Failed to write SPARQL file: {}\", e)\n                ))?;\n            println!(\"✓ SPARQL query written to: {}\", output_path);\n        } else {\n            println!(\"{}\", sparql_query);\n        }\n                    Ok(())\n                }, args: [\n                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n                    Arg::new(\"graph\").short('g').long(\"graph\").required(true),\n                    Arg::new(\"output\").short('o').long(\"output\"),\n                ]),\n            ]))\n    })\n}\n```\n\n### AI graph command\n\nSimilar pattern to `generate`, but for RDF graph generation:\n\n```rust,no_run\nverb!(\"graph\", \"Generate RDF ontologies\", |args: &VerbArgs| {\n    let description = args.get_one_str(\"description\")?;\n    let output = args.get_one_str_opt(\"output\");\n    \n    // Generate RDF/Turtle content\n    let rdf_content = format!(\n        r#\"@prefix ex: <http://example.org/> .\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n\n# Generated ontology\n# Description: {}\n\nex:ontology rdf:type ex:KnowledgeGraph ;\n    ex:description \"{}\" .\n\"#, description, description\n    );\n    \n    // Write to output file or stdout\n    if let Some(output_path) = output {\n        use std::fs;\n        fs::write(&output_path, rdf_content)\n            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n                format!(\"Failed to write RDF file: {}\", e)\n            ))?;\n        println!(\"✓ RDF ontology written to: {}\", output_path);\n    } else {\n        println!(\"{}\", rdf_content);\n    }\n    \n    Ok(())\n}, args: [\n    Arg::new(\"description\").short('d').long(\"description\").required(true),\n    Arg::new(\"output\").short('o').long(\"output\"),\n]),\n```\n\n### AI sparql command\n\nIncludes an additional required `graph` argument:\n\n```rust,no_run\nverb!(\"sparql\", \"Generate SPARQL queries\", |args: &VerbArgs| {\n    let description = args.get_one_str(\"description\")?;\n    let graph = args.get_one_str(\"graph\")?;\n    let output = args.get_one_str_opt(\"output\");\n    \n    // Generate SPARQL query\n    let sparql_query = format!(\n        r#\"# Generated SPARQL query\n# Description: {}\n# Graph: {}\n\nPREFIX ex: <http://example.org/>\nSELECT ?subject ?predicate ?object\nWHERE {{\n    GRAPH <{}> {{\n        ?subject ?predicate ?object .\n    }}\n}}\n\"#, description, graph, graph\n    );\n    \n    // Write to output file or stdout\n    if let Some(output_path) = output {\n        use std::fs;\n        fs::write(&output_path, sparql_query)\n            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n                format!(\"Failed to write SPARQL file: {}\", e)\n            ))?;\n        println!(\"✓ SPARQL query written to: {}\", output_path);\n    } else {\n        println!(\"{}\", sparql_query);\n    }\n    \n    Ok(())\n}, args: [\n    Arg::new(\"description\").short('d').long(\"description\").required(true),\n    Arg::new(\"graph\").short('g').long(\"graph\").required(true),\n    Arg::new(\"output\").short('o').long(\"output\"),\n]),\n```\n\n## Porting marketplace commands\n\nMarketplace commands manage template packages. They naturally group under a `marketplace` noun.\n\n### Search command\n\n#### Before (Regular clap)\n\n```rust,no_run\n#[derive(Subcommand)]\nenum Commands {\n    // ...\n    Search {\n        query: String,\n    },\n}\n\nfn main() {\n    match cli.command {\n        Commands::Search { query } => {\n            handle_search(query);\n        }\n        // ...\n    }\n}\n```\n\n#### After (clap-noun-verb)\n\n```rust,no_run\nnoun!(\"marketplace\", \"Template marketplace\", [\n    verb!(\"search\", \"Find packages\", |args: &VerbArgs| {\n        let query = args.get_one_str(\"query\")?;\n        // Search marketplace packages (simulated)\n        println!(\"Searching marketplace for: '{}'\", query);\n        println!(\"\");\n        println!(\"Found packages:\");\n        println!(\"  1. io.ggen.rust.axum - Rust Axum web framework template\");\n        println!(\"  2. io.ggen.rust.cli - Rust CLI application template\");\n        println!(\"  3. io.ggen.python.flask - Python Flask web application\");\n        println!(\"\");\n        println!(\"Use 'ggen marketplace add <package>' to install a package\");\n        Ok(())\n    }, args: [\n        Arg::new(\"query\").required(true).help(\"Search query\"),\n    ]),\n])\n```\n\n### Add command\n\n```rust,no_run\nverb!(\"add\", \"Install package\", |args: &VerbArgs| {\n    let package = args.get_one_str(\"package\")?;\n    // Install package from marketplace\n    println!(\"Installing package: {}\", package);\n    \n    // In real implementation, download and install package\n    use std::path::PathBuf;\n    let package_dir = PathBuf::from(\"~/.ggen/packages\").join(&package);\n    println!(\"  Package location: {}\", package_dir.display());\n    println!(\"✓ Package '{}' installed successfully\", package);\n    Ok(())\n}, args: [\n    Arg::new(\"package\").required(true).help(\"Package name (e.g., io.ggen.rust.axum)\"),\n]),\n```\n\n### List command\n\n```rust,no_run\nverb!(\"list\", \"List installed packages\", |args: &VerbArgs| {\n    // List installed packages\n    println!(\"Installed packages:\");\n    println!(\"  io.ggen.rust.axum - v1.2.0\");\n    println!(\"  io.ggen.rust.cli - v2.0.1\");\n    println!(\"\");\n    println!(\"Use 'ggen marketplace update' to update packages\");\n    Ok(())\n}),\n```\n\n### Update command\n\n```rust,no_run\nverb!(\"update\", \"Update packages\", |args: &VerbArgs| {\n    // Update installed packages\n    println!(\"Checking for package updates...\");\n    println!(\"  io.ggen.rust.axum: v1.2.0 -> v1.3.0 (update available)\");\n    println!(\"  io.ggen.rust.cli: v2.0.1 -> v2.0.1 (up to date)\");\n    println!(\"\");\n    println!(\"✓ Package update check complete\");\n    Ok(())\n}),\n```\n\n#### Complete Marketplace Commands Example\n\n```rust,no_run\nnoun!(\"marketplace\", \"Template marketplace\", [\n    verb!(\"search\", \"Find packages\", |args: &VerbArgs| {\n        let query = args.get_one_str(\"query\")?;\n        // Search marketplace packages (simulated)\n        println!(\"Searching marketplace for: '{}'\", query);\n        println!(\"\");\n        println!(\"Found packages:\");\n        println!(\"  1. io.ggen.rust.axum - Rust Axum web framework template\");\n        println!(\"  2. io.ggen.rust.cli - Rust CLI application template\");\n        println!(\"  3. io.ggen.python.flask - Python Flask web application\");\n        println!(\"\");\n        println!(\"Use 'ggen marketplace add <package>' to install a package\");\n        Ok(())\n    }, args: [\n        Arg::new(\"query\").required(true),\n    ]),\n    verb!(\"add\", \"Install package\", |args: &VerbArgs| {\n        let package = args.get_one_str(\"package\")?;\n        \n        // Install package from marketplace\n        println!(\"Installing package: {}\", package);\n        \n        // In real implementation, download and install package\n        use std::path::PathBuf;\n        let package_dir = PathBuf::from(\"~/.ggen/packages\").join(&package);\n        println!(\"  Package location: {}\", package_dir.display());\n        println!(\"✓ Package '{}' installed successfully\", package);\n        \n        Ok(())\n    }, args: [\n        Arg::new(\"package\").required(true),\n    ]),\n    verb!(\"list\", \"List installed packages\", |args: &VerbArgs| {\n        // List installed packages\n        println!(\"Installed packages:\");\n        println!(\"  io.ggen.rust.axum - v1.2.0\");\n        println!(\"  io.ggen.rust.cli - v2.0.1\");\n        println!(\"\");\n        println!(\"Use 'ggen marketplace update' to update packages\");\n        \n        Ok(())\n    }),\n    verb!(\"update\", \"Update packages\", |args: &VerbArgs| {\n        // Update installed packages\n        println!(\"Checking for package updates...\");\n        println!(\"  io.ggen.rust.axum: v1.2.0 -> v1.3.0 (update available)\");\n        println!(\"  io.ggen.rust.cli: v2.0.1 -> v2.0.1 (up to date)\");\n        println!(\"\");\n        println!(\"✓ Package update check complete\");\n        \n        Ok(())\n    }),\n])\n```\n\n## Porting template commands\n\nIf ggen has template-specific commands (separate from AI generation), they can be grouped under a `template` noun:\n\n```rust,no_run\nnoun!(\"template\", \"Template operations\", [\n    verb!(\"generate\", \"Generate from template\", |args: &VerbArgs| {\n        let template = args.get_one_str(\"template\")?;\n        let vars = args.get_many_opt::<String>(\"vars\");\n        handle_template_generate(template, vars)?;\n        Ok(())\n    }, args: [\n        Arg::new(\"template\").required(true),\n        Arg::new(\"vars\").long(\"vars\").num_args(1..),\n    ]),\n    verb!(\"validate\", \"Validate template\", |args: &VerbArgs| {\n        let template = args.get_one_str(\"template\")?;\n        handle_template_validate(template)?;\n        Ok(())\n    }, args: [\n        Arg::new(\"template\").required(true),\n    ]),\n    verb!(\"list\", \"List templates\", |args: &VerbArgs| {\n        handle_template_list()?;\n        Ok(())\n    }),\n])\n```\n\n## Handling global arguments\n\nGlobal arguments (like `--verbose` and `--config`) are available to all verbs through `VerbArgs`.\n\n### Before (Regular clap)\n\n```rust,no_run\n#[derive(Parser)]\nstruct Cli {\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    verbose: u8,\n    \n    #[arg(short, long)]\n    config: Option<String>,\n    \n    #[command(subcommand)]\n    command: Commands,\n}\n\nfn main() {\n    let cli = Cli::parse();\n    // Pass verbose/config to handlers manually\n}\n```\n\n### After (clap-noun-verb)\n\n```rust,no_run\nuse clap::Arg;\n\nrun_cli(|cli| {\n    cli.name(\"ggen\")\n        .global_args(vec![\n            Arg::new(\"verbose\")\n                .short('v')\n                .long(\"verbose\")\n                .action(clap::ArgAction::Count)\n                .help(\"Increase verbosity\"),\n            Arg::new(\"config\")\n                .short('c')\n                .long(\"config\")\n                .value_name(\"FILE\")\n                .help(\"Configuration file\"),\n        ])\n        .noun(noun!(\"ai\", \"AI-powered generation\", [\n            verb!(\"project\", \"Generate complete projects\", |args: &VerbArgs| {\n                // Access global arguments\n                let verbose = args.get_global_flag_count(\"verbose\");\n                let config = args.get_global_str(\"config\");\n                \n                // Access verb-specific arguments\n                let name = args.get_one_str(\"name\")?;\n                \n                if verbose > 1 {\n                    println!(\"[DEBUG] Config: {:?}\", config);\n                }\n                \n                // Project generation logic would go here\n                println!(\"Generating project: {} (verbose: {}, config: {:?})\", name, verbose, config);\n                Ok(())\n            }, args: [\n                Arg::new(\"name\").required(true),\n            ]),\n        ]))\n})\n```\n\n### Using Global Arguments in Handlers\n\nAll verbs can access global arguments:\n\n```rust,no_run\nverb!(\"generate\", \"Generate templates\", |args: &VerbArgs| {\n    // Verb-specific\n    let description = args.get_one_str(\"description\")?;\n    \n    // Global arguments\n    let verbose = args.get_global_flag_count(\"verbose\");\n    let config = args.get_global_str(\"config\");\n    \n    if verbose > 0 {\n        println!(\"[Verbose] Generating: {}\", description);\n    }\n    \n    if let Some(config_file) = config {\n        load_config(config_file)?;\n    }\n    \n    // Generate template content\n    let template_content = format!(\n        \"// Generated template\\n// Description: {}\\n\\nTemplate code here...\\n\",\n        description\n    );\n    \n    // Write to output file or stdout\n    if let Some(output_path) = output {\n        use std::fs;\n        fs::write(&output_path, template_content)\n            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n                format!(\"Failed to write output file: {}\", e)\n            ))?;\n        println!(\"✓ Template written to: {}\", output_path);\n    } else {\n        println!(\"{}\", template_content);\n    }\n    \n    Ok(())\n})\n```\n\n## Complete Example\n\nHere's a complete example combining all command groups:\n\n```rust,no_run\nuse clap_noun_verb::{noun, run_cli, verb, VerbArgs, Result};\nuse clap::Arg;\n\nfn main() -> Result<()> {\n    run_cli(|cli| {\n        cli.name(\"ggen\")\n            .about(\"Rust Template Generator with Frontmatter & RDF Support\")\n            .version(env!(\"CARGO_PKG_VERSION\"))\n            .global_args(vec![\n                Arg::new(\"verbose\")\n                    .short('v')\n                    .long(\"verbose\")\n                    .action(clap::ArgAction::Count)\n                    .help(\"Increase verbosity\"),\n                Arg::new(\"config\")\n                    .short('c')\n                    .long(\"config\")\n                    .value_name(\"FILE\")\n                    .help(\"Configuration file\"),\n            ])\n            .noun(noun!(\"ai\", \"AI-powered generation\", [\n                verb!(\"project\", \"Generate complete projects\", |args: &VerbArgs| {\n                    let name = args.get_one_str(\"name\")?;\n                    let description = args.get_one_str_opt(\"description\");\n                    let rust = args.is_flag_set(\"rust\");\n                    // Use the complete implementation shown below\n                    // This calls the full handle_ai_project function\n                    handle_ai_project(name, description, rust, args)?;\n                    Ok(())\n                }, args: [\n                    Arg::new(\"name\").required(true),\n                    Arg::new(\"description\"),\n                    Arg::new(\"rust\").long(\"rust\"),\n                ]),\n                verb!(\"generate\", \"Generate templates from descriptions\", |args: &VerbArgs| {\n                    let description = args.get_one_str(\"description\")?;\n                    let output = args.get_one_str_opt(\"output\");\n                    handle_ai_generate(description, output, args)?;\n                    Ok(())\n                }, args: [\n                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n                    Arg::new(\"output\").short('o').long(\"output\"),\n                ]),\n                verb!(\"graph\", \"Generate RDF ontologies\", |args: &VerbArgs| {\n                    let description = args.get_one_str(\"description\")?;\n                    let output = args.get_one_str_opt(\"output\");\n                    handle_ai_graph(description, output, args)?;\n                    Ok(())\n                }, args: [\n                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n                    Arg::new(\"output\").short('o').long(\"output\"),\n                ]),\n                verb!(\"sparql\", \"Generate SPARQL queries\", |args: &VerbArgs| {\n                    let description = args.get_one_str(\"description\")?;\n                    let graph = args.get_one_str(\"graph\")?;\n                    let output = args.get_one_str_opt(\"output\");\n                    handle_ai_sparql(description, graph, output, args)?;\n                    Ok(())\n                }, args: [\n                    Arg::new(\"description\").short('d').long(\"description\").required(true),\n                    Arg::new(\"graph\").short('g').long(\"graph\").required(true),\n                    Arg::new(\"output\").short('o').long(\"output\"),\n                ]),\n            ]))\n            .noun(noun!(\"marketplace\", \"Template marketplace\", [\n                verb!(\"search\", \"Find packages\", |args: &VerbArgs| {\n                    let query = args.get_one_str(\"query\")?;\n                    handle_search(query, args)?;\n                    Ok(())\n                }, args: [\n                    Arg::new(\"query\").required(true),\n                ]),\n                verb!(\"add\", \"Install package\", |args: &VerbArgs| {\n                    let package = args.get_one_str(\"package\")?;\n                    handle_add(package, args)?;\n                    Ok(())\n                }, args: [\n                    Arg::new(\"package\").required(true),\n                ]),\n                verb!(\"list\", \"List installed packages\", |args: &VerbArgs| {\n                    handle_list(args)?;\n                    Ok(())\n                }),\n                verb!(\"update\", \"Update packages\", |args: &VerbArgs| {\n                    handle_update(args)?;\n                    Ok(())\n                }),\n            ]))\n    })\n}\n\n// Handler functions receive VerbArgs for global argument access\nfn handle_ai_project(name: String, description: Option<String>, rust: bool, args: &VerbArgs) -> Result<()> {\n    use std::fs;\n    use std::path::PathBuf;\n    \n    let verbose = args.get_global_flag_count(\"verbose\");\n    let config = args.get_global_str(\"config\");\n    \n    if verbose > 0 {\n        println!(\"[Verbose level {}] Starting project generation\", verbose);\n        println!(\"  Project name: {}\", name);\n        if let Some(ref desc) = description {\n            println!(\"  Description: {}\", desc);\n        }\n        println!(\"  Rust project: {}\", rust);\n        if let Some(ref cfg) = config {\n            println!(\"  Using config: {}\", cfg);\n        }\n    }\n    \n    // Load config if provided\n    if let Some(config_file) = config {\n        // In real implementation, load and parse config file\n        if verbose > 1 {\n            println!(\"[DEBUG] Loading config from: {}\", config_file);\n        }\n    }\n    \n    // Create project directory\n    let project_dir = PathBuf::from(&name);\n    if verbose > 0 {\n        println!(\"Creating project directory: {}\", project_dir.display());\n    }\n    \n    fs::create_dir_all(&project_dir)\n        .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n            format!(\"Failed to create project directory: {}\", e)\n        ))?;\n    \n    // Write project description if provided\n    if let Some(desc) = description {\n        let desc_file = project_dir.join(\"DESCRIPTION.txt\");\n        fs::write(&desc_file, format!(\"Project: {}\\nDescription: {}\", name, desc))\n            .map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n                format!(\"Failed to write description file: {}\", e)\n            ))?;\n        \n        if verbose > 0 {\n            println!(\"✓ Wrote description file\");\n        }\n    }\n    \n    // Generate Rust project structure if requested\n    if rust {\n        let cargo_toml = project_dir.join(\"Cargo.toml\");\n        fs::write(&cargo_toml, format!(\n            r#\"[package]\nname = \"{}\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\"#, name\n        )).map_err(|e| clap_noun_verb::NounVerbError::execution_error(\n            format!(\"Failed to create Cargo.toml: {}\", e)\n        ))?;\n        \n        let src_dir = project_dir.join(\"src\");\n        fs::create_dir_all(&src_dir)?;\n        \n        let main_rs = src_dir.join(\"main.rs\");\n        fs::write(&main_rs, \"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\\n\")?;\n        \n        if verbose > 0 {\n            println!(\"✓ Created Rust project structure\");\n        }\n    }\n    \n    println!(\"✓ Project '{}' generated successfully!\", name);\n    Ok(())\n}\n```\n\n## Next Steps\n\nNow that you've seen how to port commands, learn about:\n\n1. [Advanced Patterns](advanced-patterns.md) - Nested commands, custom implementations, and more\n2. [Testing and Validation](testing-validation.md) - How to test your ported CLI\n\n"
        }
    ]
}