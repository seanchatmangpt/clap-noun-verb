{
    "sourceFile": "docs/book/src/getting-started.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1762032999870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762033470881,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,12 +134,13 @@\n /// \n /// # Arguments\n /// * `service` - Service name (required)\n /// * `lines` - Number of lines to show (default: 50)\n-#[verb(\"logs\")]\n+#[verb(\"logs\", \"services\")]\n fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n     // service: String → Required argument --service\n     // lines: Option<usize> → Optional argument --lines\n+    // Note: Second arg to #[verb] is the noun name (\"services\")\n     Ok(Logs {\n         service,\n         lines: lines.unwrap_or(50),\n         entries: vec![],\n"
                }
            ],
            "date": 1762032999870,
            "name": "Commit-0",
            "content": "# Getting Started with Porting\n\nThis chapter covers the initial setup for porting ggen from regular clap to clap-noun-verb, including dependency management and understanding the framework APIs.\n\n## Adding clap-noun-verb dependency\n\n### 1. Update Cargo.toml\n\nAdd `clap-noun-verb` to your `Cargo.toml` dependencies:\n\n```toml\n[dependencies]\nclap = { version = \"4.5\", features = [\"derive\"] }\nclap-noun-verb = \"3.0.0\"\n# ... your other dependencies\n```\n\n### 2. Verify Compatibility\n\nEnsure your `clap` version is compatible with `clap-noun-verb` (requires clap 4.x):\n\n```toml\n[dependencies]\nclap = { version = \"4.5\", features = [\"derive\"] }\nclap-noun-verb = \"3.0.0\"\n```\n\n### 3. Optional: Update Dev Dependencies\n\nIf you have CLI tests, ensure they use compatible versions:\n\n```toml\n[dev-dependencies]\nclap-noun-verb = \"3.0.0\"\n# ... other dev dependencies\n```\n\n## Project structure\n\nA typical clap-noun-verb project structure looks like:\n\n```\nggen/\n├── Cargo.toml\n├── src/\n│   ├── main.rs              # CLI entry point\n│   ├── commands/            # Command implementations\n│   │   ├── mod.rs\n│   │   ├── ai.rs            # AI commands\n│   │   ├── marketplace.rs   # Marketplace commands\n│   │   └── template.rs      # Template commands (if applicable)\n│   ├── handlers/            # Command handlers\n│   │   ├── mod.rs\n│   │   ├── ai_handlers.rs\n│   │   └── marketplace_handlers.rs\n│   └── utils.rs             # Utilities\n└── tests/\n    └── cli_tests.rs         # CLI integration tests\n```\n\n### Alternative Structure (Flat)\n\nFor smaller projects, you might prefer a flatter structure:\n\n```\nggen/\n├── Cargo.toml\n├── src/\n│   ├── main.rs              # CLI entry point with all commands\n│   ├── handlers.rs          # Command handlers\n│   └── utils.rs             # Utilities\n```\n\n### Recommended Approach\n\nFor ggen, we recommend a **modular structure** to keep commands organized:\n\n```\nggen/\n├── Cargo.toml\n├── src/\n│   ├── main.rs              # CLI builder\n│   ├── cli.rs               # CLI structure definition\n│   ├── commands/\n│   │   ├── mod.rs\n│   │   ├── ai.rs\n│   │   └── marketplace.rs\n│   └── handlers/\n│       ├── mod.rs\n│       ├── ai_handlers.rs\n│       └── marketplace_handlers.rs\n```\n\n## Understanding the framework APIs\n\n### Core Types\n\n### Attribute Macros (v3.0.0)\n\nThe recommended approach uses attribute macros:\n\n```rust,no_run\nuse clap_noun_verb_macros::{noun, verb};\nuse clap_noun_verb::Result;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct Status {\n    services: Vec<String>,\n    healthy: bool,\n}\n\n/// Show service status\n#[noun(\"services\", \"Manage services\")]\n#[verb(\"status\")]\nfn show_status() -> Result<Status> {\n    Ok(Status {\n        services: vec![\"api\".to_string()],\n        healthy: true,\n    })\n}\n\nfn main() -> Result<()> {\n    clap_noun_verb::run() // Auto-discovers all commands!\n}\n```\n\n### Type Inference\n\nArguments are automatically inferred from function signatures:\n\n```rust,no_run\n/// Show logs for a service\n/// \n/// # Arguments\n/// * `service` - Service name (required)\n/// * `lines` - Number of lines to show (default: 50)\n#[verb(\"logs\")]\nfn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n    // service: String → Required argument --service\n    // lines: Option<usize> → Optional argument --lines\n    Ok(Logs {\n        service,\n        lines: lines.unwrap_or(50),\n        entries: vec![],\n    })\n}\n```\n\n## Basic concepts\n\n### 1. Nouns Group Related Verbs\n\nNouns are containers for related actions:\n\n```rust,no_run\nnoun!(\"ai\", \"AI-powered generation\", [\n    verb!(\"project\", ...),\n    verb!(\"generate\", ...),\n    verb!(\"graph\", ...),\n])\n```\n\nThis creates:\n- `ggen ai project`\n- `ggen ai generate`\n- `ggen ai graph`\n\n### 2. Verbs Perform Actions\n\nVerbs execute specific actions on nouns:\n\n```rust,no_run\nverb!(\"project\", \"Generate complete projects\", |args: &VerbArgs| {\n    let name = args.get_one_str(\"name\")?;\n    \n    use std::fs;\n    use std::path::PathBuf;\n    \n    let project_dir = PathBuf::from(&name);\n    fs::create_dir_all(&project_dir)?;\n    println!(\"✓ Project '{}' created\", name);\n    \n    Ok(())\n}, args: [\n    Arg::new(\"name\").required(true),\n])\n```\n\n### 3. Arguments Are Type-Safe\n\nExtract arguments with type safety:\n\n```rust,no_run\n|args: &VerbArgs| {\n    let name = args.get_one_str(\"name\")?;  // Required string\n    let rust = args.is_flag_set(\"rust\");   // Flag\n    let output = args.get_one_str_opt(\"output\"); // Optional string\n    Ok(())\n}\n```\n\n### 4. Global Arguments Are Accessible\n\nGlobal arguments are available to all verbs:\n\n```rust,no_run\ncli.global_args(vec![\n    Arg::new(\"verbose\").short('v').long(\"verbose\").action(clap::ArgAction::Count),\n    Arg::new(\"config\").short('c').long(\"config\"),\n])\n.noun(noun!(\"ai\", ..., [\n    verb!(\"project\", ..., |args: &VerbArgs| {\n        let verbose = args.get_global_flag_count(\"verbose\");\n        let config = args.get_global_str(\"config\");\n        // ...\n    }),\n]))\n```\n\n### 5. Error Handling Uses Result\n\nAll handlers return `Result<()>`:\n\n```rust,no_run\nverb!(\"project\", ..., |args: &VerbArgs| -> Result<()> {\n    let name = args.get_one_str(\"name\")?;  // Returns Result<String>\n    // If error, return early with ?\n    do_something()?;\n    Ok(())\n})\n```\n\n### 6. Structure Validation (Optional)\n\nEnable automatic structure validation:\n\n```rust,no_run\ncli.auto_validate(true)\n```\n\nThis catches:\n- Duplicate noun names\n- Empty nouns (no verbs or sub-nouns)\n- Duplicate verb names within a noun\n- Duplicate sub-noun names\n- Verb/sub-noun name conflicts\n\n## Example: Minimal Setup\n\nHere's a minimal example to get started:\n\n```rust,no_run\nuse clap_noun_verb_macros::{noun, verb};\nuse clap_noun_verb::Result;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct Status {\n    services: Vec<String>,\n    healthy: bool,\n}\n\n#[noun(\"services\", \"Manage services\")]\n#[verb(\"status\")]\nfn show_status() -> Result<Status> {\n    Ok(Status {\n        services: vec![\"api\".to_string()],\n        healthy: true,\n    })\n}\n\nfn main() -> Result<()> {\n    clap_noun_verb::run() // Auto-discovers all commands!\n}\n```\n\nThis creates a CLI with:\n```bash\nmyapp services status\n# Output: {\"services\":[\"api\"],\"healthy\":true}\n```\n\n## Next Steps\n\nNow that you understand the basics, you're ready to:\n\n1. [Porting Commands Step-by-Step](porting-commands.md) - Port each command group with detailed examples\n2. [Advanced Patterns](advanced-patterns.md) - Learn advanced techniques for complex scenarios\n\n"
        }
    ]
}