{
    "sourceFile": "docs/book/src/introduction.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762032999870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762032999870,
            "name": "Commit-0",
            "content": "# Introduction\n\nThis guide provides a comprehensive walkthrough for porting the `ggen` CLI application from regular `clap` to the `clap-noun-verb` framework. Whether you're new to `clap-noun-verb` or an experienced Rust developer, this guide will help you understand the porting process step-by-step.\n\n## What is clap-noun-verb?\n\n`clap-noun-verb` is a framework for building composable CLI patterns on top of `clap`. It provides a high-level, ergonomic API that organizes commands using the **noun-verb pattern** (e.g., `services status`, `collector up`), similar to how Python's Typer provides a simpler interface over Click.\n\n### Key Features\n\n- **Composable Command Structure**: Easy composition of nouns and verbs\n- **Framework-Level APIs**: APIs that make it easy to build CLI frameworks\n- **Type-Safe Composition**: Compile-time verification of command structure\n- **Zero-Cost Abstractions**: Thin wrapper over clap with no runtime overhead\n- **Convenience Macros**: Reduce boilerplate with `noun!` and `verb!` macros\n- **Multiple Composition Methods**: Choose the approach that fits your needs\n\n### The Noun-Verb Pattern\n\nThe noun-verb pattern structures commands hierarchically:\n\n```\nmyapp\n├── services\n│   ├── status\n│   ├── logs\n│   └── restart\n├── collector\n│   ├── up\n│   ├── down\n│   └── status\n└── dev\n    ├── test\n    │   ├── run\n    │   └── watch\n    └── lint\n        ├── check\n        └── fix\n```\n\nWhere:\n- **Nouns** are entities or concepts (e.g., `services`, `collector`, `dev`)\n- **Verbs** are actions performed on nouns (e.g., `status`, `logs`, `up`)\n\nThis creates an intuitive, scalable command structure that's easy to understand and extend.\n\n## Why port from regular clap?\n\nWhile `clap` is powerful and flexible, building complex CLI structures with traditional `clap` often results in:\n\n1. **Verbose enum-based structures**: Deeply nested enums and match statements\n2. **Boilerplate code**: Repetitive command definitions and handlers\n3. **Scattered logic**: Command definitions spread across multiple files\n4. **Less intuitive organization**: Commands don't naturally group related functionality\n5. **Harder maintenance**: Adding new commands requires touching multiple places\n\n### Example: Before (Regular clap)\n\n```rust,no_run\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    Ai {\n        #[command(subcommand)]\n        command: AiCommands,\n    },\n    Search { query: String },\n    Add { package: String },\n    List,\n    Update,\n}\n\n#[derive(Subcommand)]\nenum AiCommands {\n    Project {\n        name: String,\n        #[arg(long)]\n        rust: bool,\n    },\n    Generate {\n        #[arg(short, long)]\n        description: String,\n        #[arg(short, long)]\n        output: Option<String>,\n    },\n    Graph {\n        #[arg(short, long)]\n        description: String,\n        #[arg(short, long)]\n        output: Option<String>,\n    },\n    Sparql {\n        #[arg(short, long)]\n        description: String,\n        #[arg(short, long)]\n        graph: String,\n        #[arg(short, long)]\n        output: Option<String>,\n    },\n}\n\nfn main() {\n    let cli = Cli::parse();\n    match cli.command {\n        Commands::Ai { command } => match command {\n            AiCommands::Project { name, rust } => {\n                // Handle ai project\n            }\n            AiCommands::Generate { description, output } => {\n                // Handle ai generate\n            }\n            // ... more matches\n        },\n        Commands::Search { query } => {\n            // Handle search\n        },\n        // ... more matches\n    }\n}\n```\n\n### Example: After (clap-noun-verb v3.0.0)\n\n```rust,no_run\nuse clap_noun_verb_macros::{noun, verb};\nuse clap_noun_verb::Result;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct ProjectOutput {\n    name: String,\n    rust: bool,\n}\n\n#[noun(\"ai\", \"AI-powered generation\")]\n#[verb(\"project\")]\nfn ai_project(name: String, rust: bool) -> Result<ProjectOutput> {\n    // name: String → Required argument --name\n    // rust: bool → Flag --rust\n    Ok(ProjectOutput { name, rust })\n}\n\n#[verb(\"generate\")]\nfn ai_generate(description: String, output: Option<String>) -> Result<String> {\n    Ok(format!(\"Generated: {}\", description))\n}\n\n#[noun(\"marketplace\", \"Template marketplace\")]\n#[verb(\"search\")]\nfn marketplace_search(query: String) -> Result<Vec<String>> {\n    Ok(vec![\"package1\".to_string(), \"package2\".to_string()])\n}\n\n#[verb(\"add\")]\nfn marketplace_add(package: String) -> Result<String> {\n    Ok(format!(\"Added: {}\", package))\n}\n\nfn main() -> Result<()> {\n    clap_noun_verb::run() // Auto-discovers all commands!\n}\n```\n\n### Benefits\n\nThe `clap-noun-verb` approach provides:\n\n- **Cleaner structure**: Commands naturally group by functionality\n- **Less boilerplate**: Macros handle repetitive patterns\n- **Better organization**: Related commands are co-located\n- **Easier to extend**: Adding new verbs to a noun is simple\n- **Type safety**: Compile-time verification of command structure\n- **Multiple composition methods**: Choose what fits your project\n\n## About ggen\n\n`ggen` is a Rust Template Generator with Frontmatter & RDF Support. It provides:\n\n- **AI-Powered Generation**: Generate templates, projects, and ontologies using LLMs\n- **Deterministic & Reproducible**: Generate byte-identical output every time\n- **Knowledge Graph-Driven**: Embed RDF and query with SPARQL\n- **Marketplace Integration**: Reusable template packages (gpacks)\n- **Production-Ready Testing**: Hermetic, deterministic test environments\n\nFrom the ggen documentation, we can see it has commands like:\n\n```bash\n# AI commands\nggen ai project \"E-commerce API with Stripe\" --name shop-api --rust\nggen ai generate -d \"Database repository pattern\" -o repo.tmpl\nggen ai graph -d \"User management ontology\" -o users.ttl\nggen ai sparql -d \"Find all active users\" -g schema.ttl\n\n# Marketplace commands\nggen search \"rust web\"\nggen add io.ggen.rust.axum\nggen list\nggen update\n```\n\nThis is a perfect candidate for the noun-verb pattern, as commands naturally group into:\n- `ai` noun with `project`, `generate`, `graph`, `sparql` verbs\n- `marketplace` noun with `search`, `add`, `list`, `update` verbs\n- And potentially other groups\n\n## Benefits of the noun-verb pattern\n\nThe noun-verb pattern provides several advantages for CLI applications:\n\n### 1. Intuitive Structure\n\nUsers quickly understand the command hierarchy:\n\n```bash\nggen ai project <name>        # Generate an AI project\nggen ai generate <description> # Generate a template\nggen marketplace search <query> # Search marketplace\n```\n\nThe structure is self-documenting and follows natural language patterns.\n\n### 2. Scalable Organization\n\nAdding new commands is straightforward:\n\n```rust,no_run\nnoun!(\"ai\", \"AI-powered generation\", [\n    verb!(\"project\", ...),\n    verb!(\"generate\", ...),\n    verb!(\"new-command\", ...), // Easy to add!\n])\n```\n\nNo need to modify enums or add match cases—just add the verb to the appropriate noun.\n\n### 3. Consistent UX\n\nUsers learn one pattern and can apply it everywhere. Once they understand `noun verb`, they can predict how new commands work.\n\n### 4. Type Safety\n\nThe framework provides compile-time verification of command structure, catching errors before runtime.\n\n### 5. Better Code Organization\n\nCommands are organized by functionality, making the codebase easier to navigate and maintain.\n\n## Next Steps\n\nNow that you understand the motivation and benefits, let's proceed to:\n\n1. [Analyzing ggen's Current Structure](analyzing-structure.md) - Understanding how to map ggen's commands to the noun-verb pattern\n2. [Getting Started with Porting](getting-started.md) - Setting up the project and understanding the framework APIs\n3. [Porting Commands Step-by-Step](porting-commands.md) - Detailed examples of porting each command group\n\n"
        }
    ]
}