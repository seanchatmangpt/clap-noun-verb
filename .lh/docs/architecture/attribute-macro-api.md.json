{
    "sourceFile": "docs/architecture/attribute-macro-api.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1762029818338,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762029892705,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -129,14 +129,19 @@\n ## Recommended: Option 3 (Direct Function Attributes)\n \n This is closest to Typer's decorator pattern and requires the least boilerplate.\n \n-### Example: Full Implementation\n+**IMPORTANT:** CLI functions decorated with `#[verb]` are **ONLY for input validation and output shaping**. They delegate to pure business logic functions.\n \n+### Example: Full Implementation with Separation\n+\n ```rust\n use clap_noun_verb::prelude::*;\n use serde::Serialize;\n \n+// Business Logic Layer (Pure, Reusable Functions)\n+// These can be used by CLI, API, Web, etc.\n+\n #[derive(Serialize)]\n struct Status {\n     services: Vec<String>,\n     healthy: bool,\n@@ -148,30 +153,58 @@\n     lines: usize,\n     entries: Vec<String>,\n }\n \n+/// Business logic: Get service status (pure function)\n+fn get_service_status() -> Status {\n+    // Pure business logic - no CLI concerns\n+    Status {\n+        services: vec![\"api\".to_string(), \"worker\".to_string()],\n+        healthy: true,\n+    }\n+}\n+\n+/// Business logic: Get logs for a service (pure function)\n+fn get_service_logs(service: String, lines: usize) -> Logs {\n+    // Pure business logic - no CLI concerns\n+    Logs {\n+        service,\n+        lines,\n+        entries: vec![\"log1\".to_string(), \"log2\".to_string()],\n+    }\n+}\n+\n+// CLI Layer (Input Validation + Output Shaping Only)\n+// These functions ONLY validate inputs and delegate to business logic\n+\n /// Show status of all services\n+/// \n+/// CLI function: Validates inputs and delegates to business logic\n #[noun(\"services\", \"Manage services\")]\n #[verb(\"status\")]\n fn show_status() -> Result<Status> {\n-    Ok(Status {\n-        services: vec![\"api\".to_string(), \"worker\".to_string()],\n-        healthy: true,\n-    })\n+    // 1. Validate inputs (auto-inferred from signature - none here)\n+    // 2. Delegate to business logic\n+    Ok(get_service_status())\n+    // 3. Output shaping (auto-serializes to JSON)\n }\n \n /// Show logs for a service\n /// \n /// # Arguments\n /// * `service` - Service name (required)\n /// * `lines` - Number of lines to show (default: 50)\n+/// \n+/// CLI function: Validates inputs and delegates to business logic\n #[verb(\"logs\")]\n fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n-    Ok(Logs {\n-        service,\n-        lines: lines.unwrap_or(50),\n-        entries: vec![\"log1\".to_string(), \"log2\".to_string()],\n-    })\n+    // 1. Validate inputs (auto-inferred: service required, lines optional)\n+    let lines = lines.unwrap_or(50);\n+    \n+    // 2. Delegate to business logic (pure function)\n+    Ok(get_service_logs(service, lines))\n+    \n+    // 3. Output shaping (auto-serializes to JSON)\n }\n \n #[noun(\"collector\", \"Manage collector\")]\n #[verb(\"up\")]\n@@ -277,18 +310,44 @@\n ```\n \n Both are declarative - just add an attribute/decorator to the function.\n \n-## Benefits\n+## Architecture: CLI Layer = Input Validation + Output Shaping\n \n-1. ✅ **Decorator-like** - Familiar to Python developers\n-2. ✅ **No manual registration** - Auto-discovery\n-3. ✅ **Minimal boilerplate** - Just add attributes\n-4. ✅ **Type-safe** - Compile-time checks\n-5. ✅ **JSON by default** - Perfect for agents/MCP\n-6. ✅ **Auto-help** - From docstrings\n-7. ✅ **Auto-inference** - Arguments from signature\n+**CRITICAL PRINCIPLE:** Functions decorated with `#[verb]` are **ONLY** for:\n+1. **Input Validation** - Validate arguments (auto-inferred from signature)\n+2. **Output Shaping** - Shape output for JSON (auto-serialization)\n+3. **Delegation** - Delegate to pure business logic functions\n \n+**They MUST NOT contain business logic.** Business logic must be in separate pure functions.\n+\n+### Separation Pattern\n+\n+```rust\n+// ✅ Business Logic Layer (Pure Functions - Reusable)\n+fn calculate_tax(amount: f64, rate: f64) -> f64 {\n+    amount * rate  // Pure business logic\n+}\n+\n+// ✅ CLI Layer (Input Validation + Output Shaping Only)\n+#[verb(\"calculate\")]\n+fn calculate_tax_cli(amount: f64, rate: f64) -> Result<TaxResult> {\n+    // 1. Validate inputs (auto-validated by signature)\n+    // 2. Delegate to business logic\n+    let tax = calculate_tax(amount, rate);\n+    // 3. Shape output (auto-serialized to JSON)\n+    Ok(TaxResult { amount, rate, tax })\n+}\n+```\n+\n+**Benefits:**\n+1. ✅ **Business logic is reusable** - Can be called from CLI, API, Web, etc.\n+2. ✅ **CLI code is minimal** - Just validation + delegation + output shaping\n+3. ✅ **Type-safe** - Compile-time checks\n+4. ✅ **JSON by default** - Perfect for agents/MCP\n+5. ✅ **Auto-help** - From docstrings\n+6. ✅ **Auto-inference** - Arguments from signature\n+\n ## Advanced: Optional Attributes\n \n ```rust\n /// Show logs with custom short name\n"
                }
            ],
            "date": 1762029818338,
            "name": "Commit-0",
            "content": "# Attribute Macro API (Decorator-Style)\n\n## Rust Attribute Macros = Python Decorators\n\nRust's **attribute macros** are the equivalent of Python decorators. Instead of:\n```rust\napp.noun(\"services\", \"Manage services\");\napp.verb(\"services\", \"status\", show_status);\n```\n\nWe can use attributes directly on functions:\n```rust\n#[noun(\"services\", \"Manage services\")]\n#[verb(\"status\")]\nfn show_status() -> Result<Status> {\n    Ok(Status { ... })\n}\n```\n\n## Design Options\n\n### Option 1: Function-Level Attributes (Simplest)\n\n```rust\nuse clap_noun_verb::prelude::*;\n\n#[app(\"myapp\", \"My awesome CLI\")]\nmod myapp {\n    use super::*;\n    \n    #[noun(\"services\", \"Manage services\")]\n    #[verb(\"status\")]\n    fn show_status() -> Result<Status> {\n        Ok(Status {\n            services: vec![\"api\".to_string()],\n            healthy: true,\n        })\n    }\n    \n    #[verb(\"logs\")]\n    fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n        Ok(Logs {\n            service,\n            lines: lines.unwrap_or(50),\n            entries: vec![],\n        })\n    }\n}\n\nfn main() -> Result<()> {\n    myapp::run()\n}\n```\n\n**Benefits:**\n- ✅ No manual registration\n- ✅ Decorator-like syntax\n- ✅ Auto-discovery of functions\n- ✅ Very clean\n\n### Option 2: Module-Level Attributes (More Organized)\n\n```rust\nuse clap_noun_verb::prelude::*;\n\n#[app(\"myapp\", \"My awesome CLI\")]\nmod myapp {\n    #[noun(\"services\", \"Manage services\")]\n    mod services {\n        #[verb(\"status\")]\n        fn show_status() -> Result<Status> { ... }\n        \n        #[verb(\"logs\")]\n        fn show_logs(service: String) -> Result<Logs> { ... }\n    }\n    \n    #[noun(\"collector\", \"Manage collector\")]\n    mod collector {\n        #[verb(\"up\")]\n        fn start() -> Result<()> { ... }\n        \n        #[verb(\"down\")]\n        fn stop() -> Result<()> { ... }\n    }\n}\n\nfn main() -> Result<()> {\n    myapp::run()\n}\n```\n\n**Benefits:**\n- ✅ Organized by noun (module structure)\n- ✅ Clear namespace\n- ✅ Easy to find commands\n\n### Option 3: Direct Function Attributes (Most Flexible)\n\n```rust\nuse clap_noun_verb::prelude::*;\n\n#[noun(\"services\", \"Manage services\")]\n#[verb(\"status\")]\nfn show_status() -> Result<Status> {\n    Ok(Status { ... })\n}\n\n#[verb(\"logs\")]\nfn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n    Ok(Logs { ... })\n}\n\n#[noun(\"collector\", \"Manage collector\")]\n#[verb(\"up\")]\nfn start_collector() -> Result<()> {\n    Ok(())\n}\n\nfn main() -> Result<()> {\n    clap_noun_verb::run() // Auto-discovers all #[verb] functions\n}\n```\n\n**Benefits:**\n- ✅ No module wrapping needed\n- ✅ Simplest to write\n- ✅ Auto-discovery\n\n## Recommended: Option 3 (Direct Function Attributes)\n\nThis is closest to Typer's decorator pattern and requires the least boilerplate.\n\n### Example: Full Implementation\n\n```rust\nuse clap_noun_verb::prelude::*;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct Status {\n    services: Vec<String>,\n    healthy: bool,\n}\n\n#[derive(Serialize)]\nstruct Logs {\n    service: String,\n    lines: usize,\n    entries: Vec<String>,\n}\n\n/// Show status of all services\n#[noun(\"services\", \"Manage services\")]\n#[verb(\"status\")]\nfn show_status() -> Result<Status> {\n    Ok(Status {\n        services: vec![\"api\".to_string(), \"worker\".to_string()],\n        healthy: true,\n    })\n}\n\n/// Show logs for a service\n/// \n/// # Arguments\n/// * `service` - Service name (required)\n/// * `lines` - Number of lines to show (default: 50)\n#[verb(\"logs\")]\nfn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n    Ok(Logs {\n        service,\n        lines: lines.unwrap_or(50),\n        entries: vec![\"log1\".to_string(), \"log2\".to_string()],\n    })\n}\n\n#[noun(\"collector\", \"Manage collector\")]\n#[verb(\"up\")]\nfn start_collector() -> Result<String> {\n    Ok(\"Collector started\".to_string())\n}\n\n#[verb(\"down\")]\nfn stop_collector() -> Result<String> {\n    Ok(\"Collector stopped\".to_string())\n}\n\nfn main() -> Result<()> {\n    clap_noun_verb::run() // Auto-discovers all #[noun] and #[verb] functions\n}\n```\n\n**Usage:**\n```bash\n$ myapp services status\n{\"services\":[\"api\",\"worker\"],\"healthy\":true}\n\n$ myapp services logs api --lines 100\n{\"service\":\"api\",\"lines\":100,\"entries\":[\"log1\",\"log2\"]}\n\n$ myapp collector up\n\"Collector started\"\n```\n\n## How It Works\n\n1. **`#[noun(...)]`** - Marks which noun this verb belongs to\n2. **`#[verb(...)]`** - Registers function as a CLI verb\n3. **Auto-discovery** - Macro collects all `#[verb]` functions at compile time\n4. **Auto-serialization** - Return types automatically serialized to JSON\n5. **Auto-inference** - Arguments inferred from function signature\n\n## Implementation Details\n\n### Attribute Macro Expansion\n\n```rust\n#[verb(\"status\")]\nfn show_status() -> Result<Status> { ... }\n```\n\nExpands to something like:\n\n```rust\nfn show_status() -> Result<Status> { ... }\n\n// Auto-generated registration\n#[::clap_noun_verb::__internal::register_verb(\"status\", show_status)]\nstatic __REGISTER_STATUS: () = ();\n```\n\n### Function Signature Inference\n\n```rust\nfn show_logs(service: String, lines: Option<usize>) -> Result<Logs>\n```\n\n- `service: String` → Required argument `--service`\n- `lines: Option<usize>` → Optional flag `--lines <number>`\n- `Result<Logs>` → Serialize `Logs` to JSON on output\n\n### Docstring Help Generation\n\n```rust\n/// Show logs for a service\n/// \n/// # Arguments\n/// * `service` - Service name (required)\n/// * `lines` - Number of lines to show (default: 50)\n#[verb(\"logs\")]\nfn show_logs(service: String, lines: Option<usize>) -> Result<Logs>\n```\n\nAuto-generates clap help:\n```\nShow logs for a service\n\nArguments:\n  --service <SERVICE>    Service name (required)\n  --lines <LINES>        Number of lines to show (default: 50)\n```\n\n## Comparison: Decorator vs Registration\n\n### Python (Typer)\n```python\n@app.command()\ndef greet(name: str):\n    ...\n```\n\n### Rust (Attribute Macro)\n```rust\n#[verb(\"greet\")]\nfn greet(name: String) -> Result<Greeting> {\n    ...\n}\n```\n\nBoth are declarative - just add an attribute/decorator to the function.\n\n## Benefits\n\n1. ✅ **Decorator-like** - Familiar to Python developers\n2. ✅ **No manual registration** - Auto-discovery\n3. ✅ **Minimal boilerplate** - Just add attributes\n4. ✅ **Type-safe** - Compile-time checks\n5. ✅ **JSON by default** - Perfect for agents/MCP\n6. ✅ **Auto-help** - From docstrings\n7. ✅ **Auto-inference** - Arguments from signature\n\n## Advanced: Optional Attributes\n\n```rust\n/// Show logs with custom short name\n#[verb(\"logs\", short = \"l\")]\nfn show_logs(service: String) -> Result<Logs> { ... }\n\n/// Force with custom help text\n#[verb(\"status\", help = \"Show current status of services\")]\nfn show_status() -> Result<Status> { ... }\n```\n\n## Migration Path\n\nFrom current API:\n```rust\nlet mut app = cli::new(\"myapp\", \"My CLI\");\napp.noun(\"services\", \"Manage services\");\napp.verb(\"services\", \"status\", show_status);\napp.run()\n```\n\nTo attribute macro:\n```rust\n#[noun(\"services\", \"Manage services\")]\n#[verb(\"status\")]\nfn show_status() -> Result<Status> { ... }\n\nfn main() -> Result<()> {\n    clap_noun_verb::run()\n}\n```\n\n**Much simpler!**\n\n"
        }
    ]
}