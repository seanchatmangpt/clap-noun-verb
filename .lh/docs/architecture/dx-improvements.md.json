{
    "sourceFile": "docs/architecture/dx-improvements.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1762029571568,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762029709794,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -199,39 +199,125 @@\n 13. ✅ Macro sugar for common patterns\n 14. ✅ Structured output helpers\n 15. ✅ Better error messages with context\n \n-## Example: Ideal DX\n+## Typer-Style API (Non-Fluent)\n \n+Typer uses simple function registration - no fluent chaining. Just register functions directly.\n+\n+### Typer Pattern\n+\n+**Python:**\n+```python\n+import typer\n+\n+app = typer.Typer()\n+\n+@app.command()\n+def greet(name: str):\n+    \"\"\"Greet a user by name.\"\"\"\n+    print(f\"Hello, {name}!\")\n+\n+if __name__ == \"__main__\":\n+    app()\n+```\n+\n+### Rust Equivalent (Ideal DX)\n+\n ```rust\n-use clap_noun_verb::{cli, Result};\n+use clap_noun_verb::{cli, Result, serde_json::json};\n \n /// Show status of all services\n-fn show_status() -> Result<String> {\n-    Ok(\"All services running\".to_string())\n+fn show_status() -> Result<serde_json::Value> {\n+    Ok(json!({\n+        \"status\": \"running\",\n+        \"services\": [\"api\", \"worker\"]\n+    }))\n }\n \n /// Show logs for a service\n /// \n /// # Arguments\n /// * `service` - Service name (required)\n /// * `lines` - Number of lines to show (default: 50)\n-fn show_logs(service: String, lines: Option<usize>) -> Result<String> {\n+fn show_logs(service: String, lines: Option<usize>) -> Result<serde_json::Value> {\n     let lines = lines.unwrap_or(50);\n-    Ok(format!(\"Showing {} lines for {}\", lines, service))\n+    Ok(json!({\n+        \"service\": service,\n+        \"lines\": lines,\n+        \"logs\": [\"log1\", \"log2\"]\n+    }))\n }\n \n fn main() -> Result<()> {\n-    cli::build(\"myapp\", \"My awesome CLI\")\n-        .noun(\"services\", \"Manage services\", |n| {\n-            n.verb(\"status\", show_status)\n-             .verb(\"logs\", show_logs)\n-        })\n-        .run()\n+    let mut app = cli::new(\"myapp\", \"My awesome CLI\");\n+    \n+    // Register noun\n+    app.noun(\"services\", \"Manage services\");\n+    \n+    // Register verbs (Typer-style - no fluent chaining)\n+    app.verb(\"services\", \"status\", show_status);\n+    app.verb(\"services\", \"logs\", show_logs);\n+    \n+    app.run()\n }\n ```\n \n+### Even Simpler - Auto JSON by Default\n+\n+Since most CLIs will be used by agents/MCP, make JSON the default output:\n+\n+```rust\n+use clap_noun_verb::{cli, Result};\n+\n+/// Show status - returns JSON automatically\n+fn show_status() -> Result<Status> {\n+    Ok(Status {\n+        status: \"running\".to_string(),\n+        services: vec![\"api\".to_string(), \"worker\".to_string()],\n+    })\n+}\n+\n+/// Show logs - auto-serializes to JSON\n+fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n+    Ok(Logs {\n+        service,\n+        lines: lines.unwrap_or(50),\n+        entries: vec![\"log1\".to_string(), \"log2\".to_string()],\n+    })\n+}\n+\n+#[derive(serde::Serialize)]\n+struct Status {\n+    status: String,\n+    services: Vec<String>,\n+}\n+\n+#[derive(serde::Serialize)]\n+struct Logs {\n+    service: String,\n+    lines: usize,\n+    entries: Vec<String>,\n+}\n+\n+fn main() -> Result<()> {\n+    let mut app = cli::new(\"myapp\", \"My awesome CLI\");\n+    app.noun(\"services\", \"Manage services\");\n+    app.verb(\"services\", \"status\", show_status);\n+    app.verb(\"services\", \"logs\", show_logs);\n+    app.run() // Outputs JSON automatically\n+}\n+```\n+\n **Benefits:**\n+- ✅ No fluent chaining (simpler)\n+- ✅ JSON by default (perfect for agents/MCP)\n+- ✅ Auto-serialize return types\n+- ✅ Auto-infer arguments from function signature\n+- ✅ Simple function registration (Typer-style)\n+- ✅ Type-safe with serde\n+\n+**Benefits:**\n - ✅ No boilerplate\n - ✅ Type-safe\n - ✅ Auto-validated\n - ✅ Auto-help\n"
                }
            ],
            "date": 1762029571568,
            "name": "Commit-0",
            "content": "# Developer Experience (DX) Improvements\n\n## Current Friction Points\n\n### 1. **Verb Method is Placeholder**\nThe `.verb()` method in `CliBuilder` doesn't actually work yet - it just returns `self`.\n\n**Problem:**\n```rust\ncli.verb(\"services\", \"status\", \"Show status\", handler); // Does nothing!\n```\n\n**Solution:** Implement actual verb registration\n\n### 2. **HandlerInput/HandlerOutput Boilerplate**\nToo much ceremony to wrap values.\n\n**Problem:**\n```rust\nfn show_status(_input: HandlerInput) -> Result<HandlerOutput> {\n    Ok(HandlerOutput {\n        data: OutputData::Text(\"All services running\".to_string()),\n        message: None,\n    })\n}\n```\n\n**Solution:** Auto-wrap simple return types\n```rust\nfn show_status(_input: HandlerInput) -> Result<String> {\n    Ok(\"All services running\".to_string())\n}\n// Auto-wrapped to HandlerOutput internally\n```\n\n### 3. **Manual Argument Specification**\nStill requires verbose `Arg::new()` calls.\n\n**Problem:**\n```rust\nverb!(\"logs\", \"Show logs\", |args| { ... }, args: [\n    Arg::new(\"service\").required(true),\n    Arg::new(\"lines\").short('n').long(\"lines\").default_value(\"50\"),\n])\n```\n\n**Solution:** Type-driven argument inference\n```rust\nfn show_logs(service: String, lines: Option<usize>) -> Result<String> {\n    // Arguments auto-inferred from function signature\n}\n```\n\n### 4. **Two Competing Patterns**\nOld macro pattern (`noun!`, `verb!`) vs new builder pattern (`CliBuilder`).\n\n**Problem:** Confusion about which to use\n\n**Solution:** \n- Make builder the primary API\n- Keep macros as sugar syntax\n- Clear migration path\n\n### 5. **Argument Extraction Friction**\nManual calls to `get_one_str()`, `get_one_opt()`, etc.\n\n**Problem:**\n```rust\nlet service = args.get_one_str(\"service\")?;\nlet lines = args.get_one_opt::<usize>(\"lines\").unwrap_or(50);\n```\n\n**Solution:** Auto-extract from function signature\n```rust\nfn show_logs(service: String, lines: usize) -> Result<String> {\n    // service and lines auto-extracted and passed\n}\n```\n\n### 6. **No Auto-Validation from Signatures**\nTODO comments indicate this should exist but doesn't.\n\n**Solution:** Infer argument types and validation from function signatures\n\n### 7. **No Auto-Help from Docstrings**\nShould automatically extract help text from function docstrings.\n\n**Solution:**\n```rust\n/// Show logs for a service\n/// \n/// # Arguments\n/// * `service` - Service name to show logs for\n/// * `lines` - Number of lines to show (default: 50)\nfn show_logs(service: String, lines: usize) -> Result<String> {\n    // Help auto-generated from docstring\n}\n```\n\n### 8. **No Auto-Output Formatting**\nManual string formatting required.\n\n**Problem:**\n```rust\nprintln!(\"Showing {} lines for {}\", lines, service);\n```\n\n**Solution:** Structured output with auto-formatting\n```rust\nOk(OutputData::Structured(hashmap! {\n    \"service\" => service,\n    \"lines\" => lines.to_string(),\n}))\n// Auto-formatted as table or JSON\n```\n\n### 9. **Separate Noun/Verb Calls**\nCan't fluently chain verb registration.\n\n**Problem:**\n```rust\n.noun(\"services\", \"Manage services\")\n.verb(\"services\", \"status\", \"Show status\", handler1)\n.verb(\"services\", \"logs\", \"Show logs\", handler2)\n```\n\n**Solution:** Fluent builder with verb chaining\n```rust\n.noun(\"services\", \"Manage services\", |noun| {\n    noun.verb(\"status\", \"Show status\", handler1)\n        .verb(\"logs\", \"Show logs\", handler2)\n})\n```\n\n### 10. **Version Auto-Detection Not Working**\nClaims to auto-detect from Cargo.toml but is manual.\n\n**Solution:** Actually implement auto-detection\n\n### 11. **No Tab Completion Generation**\nMissing auto-completion support.\n\n**Solution:** Auto-generate completion scripts (bash, zsh, fish, PowerShell)\n\n### 12. **Global Args Still Manual**\nMust specify global args explicitly.\n\n**Solution:** Auto-infer from shared function parameters\n\n### 13. **Error Handling Ceremony**\nLots of `?` and `Result` wrapping.\n\n**Solution:** Macro sugar for common patterns\n\n### 14. **No Batch Verb Registration**\nCan't register multiple verbs at once.\n\n**Solution:**\n```rust\n.noun(\"services\", \"Manage services\")\n    .verbs(vec![\n        (\"status\", \"Show status\", handler1),\n        (\"logs\", \"Show logs\", handler2),\n        (\"restart\", \"Restart service\", handler3),\n    ])\n```\n\n### 15. **Type Conversion Pain**\nManual type conversions for arguments.\n\n**Problem:**\n```rust\nlet count = args.get_one_opt::<usize>(\"count\").unwrap_or(10);\n```\n\n**Solution:** Type inference handles this automatically\n\n## Proposed Solutions\n\n### Priority 1: Core Functionality\n1. ✅ Implement actual `.verb()` registration\n2. ✅ Auto-wrap simple return types (String → HandlerOutput)\n3. ✅ Type-driven argument inference from function signatures\n4. ✅ Auto-extract arguments from signatures\n\n### Priority 2: Automation\n5. ✅ Auto-validation from types\n6. ✅ Auto-help from docstrings  \n7. ✅ Auto-output formatting (table/JSON)\n8. ✅ Version auto-detection from Cargo.toml\n\n### Priority 3: DX Enhancements\n9. ✅ Fluent verb chaining\n10. ✅ Tab completion generation\n11. ✅ Batch verb registration\n12. ✅ Global args auto-inference\n\n### Priority 4: Polish\n13. ✅ Macro sugar for common patterns\n14. ✅ Structured output helpers\n15. ✅ Better error messages with context\n\n## Example: Ideal DX\n\n```rust\nuse clap_noun_verb::{cli, Result};\n\n/// Show status of all services\nfn show_status() -> Result<String> {\n    Ok(\"All services running\".to_string())\n}\n\n/// Show logs for a service\n/// \n/// # Arguments\n/// * `service` - Service name (required)\n/// * `lines` - Number of lines to show (default: 50)\nfn show_logs(service: String, lines: Option<usize>) -> Result<String> {\n    let lines = lines.unwrap_or(50);\n    Ok(format!(\"Showing {} lines for {}\", lines, service))\n}\n\nfn main() -> Result<()> {\n    cli::build(\"myapp\", \"My awesome CLI\")\n        .noun(\"services\", \"Manage services\", |n| {\n            n.verb(\"status\", show_status)\n             .verb(\"logs\", show_logs)\n        })\n        .run()\n}\n```\n\n**Benefits:**\n- ✅ No boilerplate\n- ✅ Type-safe\n- ✅ Auto-validated\n- ✅ Auto-help\n- ✅ Minimal cognitive load\n- ✅ Reusable functions (can call directly from API/Web)\n\n"
        }
    ]
}