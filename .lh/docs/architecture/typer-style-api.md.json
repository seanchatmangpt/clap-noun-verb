{
    "sourceFile": "docs/architecture/typer-style-api.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1762029709797,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762029818346,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -237,13 +237,34 @@\n - Extract help from `///` docstrings\n - Parse `# Arguments` section\n - Auto-generate clap help\n \n-## Example: Full Implementation\n+## Attribute Macros (Decorator-Style) - RECOMMENDED\n \n+Rust attribute macros are the equivalent of Python decorators. Instead of manual registration, use attributes:\n+\n+### Python (Typer)\n+```python\n+@app.command()\n+def greet(name: str):\n+    \"\"\"Greet a user.\"\"\"\n+    print(f\"Hello, {name}!\")\n+```\n+\n+### Rust (Attribute Macro)\n ```rust\n-use clap_noun_verb::{cli, Result, serde::Serialize};\n+#[verb(\"greet\")]\n+fn greet(name: String) -> Result<Greeting> {\n+    Ok(Greeting { message: format!(\"Hello, {}!\", name) })\n+}\n+```\n \n+## Example: Full Implementation with Attributes\n+\n+```rust\n+use clap_noun_verb::prelude::*;\n+use serde::Serialize;\n+\n #[derive(Serialize)]\n struct Status {\n     services: Vec<String>,\n     healthy: bool,\n@@ -256,8 +277,10 @@\n     entries: Vec<String>,\n }\n \n /// Show status of all services\n+#[noun(\"services\", \"Manage services\")]\n+#[verb(\"status\")]\n fn show_status() -> Result<Status> {\n     Ok(Status {\n         services: vec![\"api\".to_string(), \"worker\".to_string()],\n         healthy: true,\n@@ -268,8 +291,9 @@\n /// \n /// # Arguments\n /// * `service` - Service name (required)\n /// * `lines` - Number of lines to show (default: 50)\n+#[verb(\"logs\")]\n fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n     Ok(Logs {\n         service,\n         lines: lines.unwrap_or(50),\n@@ -277,18 +301,31 @@\n     })\n }\n \n fn main() -> Result<()> {\n-    let mut app = cli::new(\"myapp\", \"My awesome CLI\");\n-    \n-    app.noun(\"services\", \"Manage services\");\n-    app.verb(\"services\", \"status\", show_status);\n-    app.verb(\"services\", \"logs\", show_logs);\n-    \n-    app.run() // Outputs JSON to stdout\n+    clap_noun_verb::run() // Auto-discovers all #[verb] functions\n }\n ```\n \n+**Usage:**\n+```bash\n+$ myapp services status\n+{\"services\":[\"api\",\"worker\"],\"healthy\":true}\n+\n+$ myapp services logs api --lines 100\n+{\"service\":\"api\",\"lines\":100,\"entries\":[\"log1\",\"log2\"]}\n+```\n+\n+## Benefits of Attribute Macros\n+\n+1. ✅ **Decorator-like** - Familiar to Python/Typer users\n+2. ✅ **No manual registration** - Auto-discovery at compile time\n+3. ✅ **Minimal boilerplate** - Just add `#[verb(...)]` attribute\n+4. ✅ **Cleaner code** - No `app.noun()` or `app.verb()` calls\n+5. ✅ **Type-safe** - Compile-time checks\n+6. ✅ **JSON by default** - Perfect for agents/MCP\n+```\n+\n **Output:**\n ```json\n {\n   \"services\": [\"api\", \"worker\"],\n"
                }
            ],
            "date": 1762029709797,
            "name": "Commit-0",
            "content": "# Typer-Style API Design\n\n## Philosophy\n\nTyper's success comes from:\n1. **Simple function registration** - no fluent chaining\n2. **Type-driven inference** - arguments inferred from function signatures\n3. **Docstring-driven help** - help auto-generated from docstrings\n4. **Minimal boilerplate** - just write functions\n\nWe should adopt this pattern for Rust.\n\n## Current Problems\n\n1. **Fluent chaining is verbose** - `.noun().verb().verb()` requires closures\n2. **Output is too verbose** - `OutputData::Structured(hashmap! {...})` is verbose\n3. **Not JSON by default** - agents/MCP need JSON, not hashmap strings\n\n## Typer Pattern\n\n### Python (Typer)\n\n```python\nimport typer\n\napp = typer.Typer()\n\n@app.command()\ndef greet(name: str, age: int = 25):\n    \"\"\"Greet a user.\"\"\"\n    print(f\"Hello, {name}! You are {age}\")\n\nif __name__ == \"__main__\":\n    app()\n```\n\n**Key points:**\n- ✅ Just register functions with `@app.command()`\n- ✅ Arguments inferred from function signature\n- ✅ Help auto-generated from docstring\n- ✅ Optional args use default values\n- ✅ No fluent chaining\n\n### Rust Equivalent (Proposed)\n\n```rust\nuse clap_noun_verb::{cli, Result, serde::Serialize};\n\n#[derive(Serialize)]\nstruct GreetOutput {\n    message: String,\n    age: u32,\n}\n\n/// Greet a user\nfn greet(name: String, age: Option<u32>) -> Result<GreetOutput> {\n    let age = age.unwrap_or(25);\n    Ok(GreetOutput {\n        message: format!(\"Hello, {}! You are {}\", name, age),\n        age,\n    })\n}\n\nfn main() -> Result<()> {\n    let mut app = cli::new(\"myapp\", \"My CLI\");\n    \n    // Register verb directly (no fluent chaining)\n    app.verb(\"greet\", greet);\n    \n    app.run() // JSON output by default\n}\n```\n\n## Key Design Decisions\n\n### 1. No Fluent Chaining\n\n**Instead of:**\n```rust\n.noun(\"services\", \"Manage services\", |n| {\n    n.verb(\"status\", handler1)\n     .verb(\"logs\", handler2)\n})\n```\n\n**Do:**\n```rust\napp.noun(\"services\", \"Manage services\");\napp.verb(\"services\", \"status\", handler1);\napp.verb(\"services\", \"logs\", handler2);\n```\n\n**Why:** Simpler, more explicit, easier to understand\n\n### 2. JSON by Default\n\n**Instead of:**\n```rust\nOk(OutputData::Structured(hashmap! {\n    \"service\" => service,\n    \"lines\" => lines.to_string(),\n}))\n```\n\n**Do:**\n```rust\n#[derive(Serialize)]\nstruct LogsOutput {\n    service: String,\n    lines: usize,\n    entries: Vec<String>,\n}\n\nfn show_logs(service: String, lines: Option<usize>) -> Result<LogsOutput> {\n    Ok(LogsOutput {\n        service,\n        lines: lines.unwrap_or(50),\n        entries: vec![\"log1\".to_string()],\n    })\n}\n// Auto-serializes to JSON\n```\n\n**Why:** \n- Agents/MCP need JSON\n- serde is standard in Rust\n- Type-safe with structs\n- Much less verbose\n\n### 3. Auto-Infer Arguments\n\n**Instead of:**\n```rust\nlet service = args.get_one_str(\"service\")?;\nlet lines = args.get_one_opt::<usize>(\"lines\").unwrap_or(50);\n```\n\n**Do:**\n```rust\nfn show_logs(service: String, lines: Option<usize>) -> Result<LogsOutput> {\n    // service and lines auto-extracted from CLI args\n    // lines auto-converted from string to usize\n    // Option<usize> means optional flag --lines\n}\n```\n\n**Why:**\n- Typer does this - infer from function signature\n- Less boilerplate\n- Type-safe conversions\n- Compile-time checks\n\n### 4. Simple Return Types\n\n**Instead of:**\n```rust\nfn show_status() -> Result<HandlerOutput> {\n    Ok(HandlerOutput {\n        data: OutputData::Text(\"running\".to_string()),\n        message: None,\n    })\n}\n```\n\n**Do:**\n```rust\nfn show_status() -> Result<String> {\n    Ok(\"running\".to_string())\n}\n// Or for structured data:\nfn show_status() -> Result<StatusOutput> {\n    Ok(StatusOutput { ... })\n}\n// Auto-wrapped and serialized to JSON\n```\n\n**Why:**\n- Simpler\n- Natural Rust functions\n- Auto-wrap internally\n\n## Implementation Plan\n\n### Phase 1: Core Function Registration\n\n```rust\npub struct Cli {\n    name: String,\n    about: String,\n    nouns: HashMap<String, Vec<Verb>>,\n}\n\nimpl Cli {\n    pub fn new(name: impl Into<String>, about: impl Into<String>) -> Self {\n        Self {\n            name: name.into(),\n            about: about.into(),\n            nouns: HashMap::new(),\n        }\n    }\n    \n    pub fn noun(&mut self, name: &str, about: &str) {\n        // Register noun\n    }\n    \n    pub fn verb<F>(&mut self, noun: &str, verb: &str, handler: F)\n    where\n        F: Fn(...) -> Result<T> + Send + Sync + 'static,\n        T: Serialize,\n    {\n        // Register verb with handler\n    }\n    \n    pub fn run(&mut self) -> Result<()> {\n        // Parse args and route\n    }\n}\n```\n\n### Phase 2: JSON by Default\n\n- Use `serde::Serialize` for output\n- Auto-serialize return types to JSON\n- Remove `OutputData` enum (too verbose)\n- Use simple return types: `String`, `Vec<T>`, `Struct`, etc.\n\n### Phase 3: Type Inference\n\n- Use function signature to infer args\n- `String` → required arg\n- `Option<T>` → optional flag\n- `bool` → flag (true if present)\n- `Vec<T>` → multiple values\n\n### Phase 4: Docstring Help\n\n- Extract help from `///` docstrings\n- Parse `# Arguments` section\n- Auto-generate clap help\n\n## Example: Full Implementation\n\n```rust\nuse clap_noun_verb::{cli, Result, serde::Serialize};\n\n#[derive(Serialize)]\nstruct Status {\n    services: Vec<String>,\n    healthy: bool,\n}\n\n#[derive(Serialize)]\nstruct Logs {\n    service: String,\n    lines: usize,\n    entries: Vec<String>,\n}\n\n/// Show status of all services\nfn show_status() -> Result<Status> {\n    Ok(Status {\n        services: vec![\"api\".to_string(), \"worker\".to_string()],\n        healthy: true,\n    })\n}\n\n/// Show logs for a service\n/// \n/// # Arguments\n/// * `service` - Service name (required)\n/// * `lines` - Number of lines to show (default: 50)\nfn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n    Ok(Logs {\n        service,\n        lines: lines.unwrap_or(50),\n        entries: vec![\"log1\".to_string(), \"log2\".to_string()],\n    })\n}\n\nfn main() -> Result<()> {\n    let mut app = cli::new(\"myapp\", \"My awesome CLI\");\n    \n    app.noun(\"services\", \"Manage services\");\n    app.verb(\"services\", \"status\", show_status);\n    app.verb(\"services\", \"logs\", show_logs);\n    \n    app.run() // Outputs JSON to stdout\n}\n```\n\n**Output:**\n```json\n{\n  \"services\": [\"api\", \"worker\"],\n  \"healthy\": true\n}\n```\n\n## Benefits\n\n1. ✅ **Simpler** - No fluent chaining, just function registration\n2. ✅ **JSON by default** - Perfect for agents/MCP\n3. ✅ **Less verbose** - No `OutputData::Structured(hashmap! {...})`\n4. ✅ **Type-safe** - serde Serialize ensures correctness\n5. ✅ **Auto-inference** - Arguments from function signature\n6. ✅ **Typer-like** - Familiar pattern for Python developers\n7. ✅ **Natural Rust** - Just write normal functions\n\n"
        }
    ]
}