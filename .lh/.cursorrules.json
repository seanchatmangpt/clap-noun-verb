{
    "sourceFile": ".cursorrules",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1762033157555,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762033200247,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,9 +140,9 @@\n \n ### ‚ö° Test Performance Requirements\n **The ENTIRE test suite MUST complete within 1 second. If the test suite takes longer, optimize with concurrency or other performance improvements.**\n \n-- Run tests with timeout: `cargo test -- --timeout 1s` or configure test timeouts (default parallel execution is used)\n+- Run tests with timeout: `timeout 1s cargo test && echo \"Tests completed in <1s\"` (uses shell timeout command)\n - The complete test suite (all tests combined) must finish in under 1 second\n - Use parallel test execution (cargo test default, or `--test-threads=N` to explicitly set concurrency) to maximize speed\n - For slow test suites, refactor tests to use concurrent execution, optimize test code, or reduce test coverage to essential behaviors only\n - Individual tests should be fast (<100ms each) to allow the full suite to complete in <1s with parallel execution\n@@ -383,9 +383,9 @@\n 10. **‚úÖ Documentation**: All public APIs have documentation with examples\n \n ### Validation Checklist:\n - [ ] `cargo test` passes completely\n-- [ ] `cargo test -- --timeout 1s` passes (entire test suite completes in <1s with parallel execution)\n+- [ ] `timeout 1s cargo test && echo \"Tests completed in <1s\"` passes (entire test suite completes in <1s with parallel execution)\n - [ ] `cargo clippy` shows no warnings\n - [ ] No `unwrap()` or `expect()` in production code\n - [ ] All traits are `dyn` compatible\n - [ ] No breaking changes to public APIs\n"
                }
            ],
            "date": 1762033157555,
            "name": "Commit-0",
            "content": "# Core Team Best Practices for clap-noun-verb\n\n## üéØ Project Overview\n\n**clap-noun-verb** is a framework for building composable CLI patterns on top of clap. This library focuses on:\n- **Composable Command Structure**: Easy composition of nouns and verbs\n- **Type-Safe APIs**: Compile-time verification of command structure\n- **Zero-Cost Abstractions**: Thin wrapper over clap with no runtime overhead\n- **Framework Philosophy**: Provide tools for composition, not pre-built patterns\n\n## üéØ Error Handling Best Practices\n\n### ‚ùå NEVER use unwrap() or expect() in production code\n```rust\n// ‚ùå Bad: Using unwrap() - can cause panics\nlet result = some_operation().unwrap();\n\n// ‚ùå Bad: Using expect() - can cause panics\nlet result = some_operation().expect(\"This should not fail\");\n\n// ‚úÖ Good: Proper error handling\nlet result = some_operation()?;\n\n// ‚úÖ Good: Proper error handling with context\nlet result = some_operation().map_err(|e| {\n    NounVerbError::argument_error(format!(\"Operation failed: {}\", e))\n})?;\n```\n\n### ‚úÖ Use structured error types with context\n```rust\n// ‚úÖ Good: Using NounVerbError with context\nfn my_function() -> Result<MyType> {\n    some_operation().map_err(|e| {\n        NounVerbError::execution_error(format!(\"Command execution failed: {}\", e))\n    })?;\n}\n```\n\n## üîÑ Async/Sync Best Practices\n\n### ‚ùå NEVER make trait methods async - breaks dyn compatibility\n```rust\n// ‚ùå Bad: Async trait methods break dyn compatibility\npub trait VerbCommand: Send + Sync {\n    async fn run(&self, args: &VerbArgs) -> Result<()>; // BREAKS dyn VerbCommand!\n}\n\n// ‚úÖ Good: Keep trait methods sync, use sync operations\npub trait VerbCommand: Send + Sync {\n    fn run(&self, args: &VerbArgs) -> Result<()>; // dyn compatible\n    fn name(&self) -> &'static str;\n    fn about(&self) -> &'static str;\n}\n```\n\n### ‚úÖ Use sync for CLI framework operations\n```rust\n// ‚úÖ Good: Sync for CLI parsing and routing\npub fn route_command(matches: &ArgMatches) -> Result<()> {\n    // CLI operations are synchronous\n    Ok(())\n}\n\n// ‚úÖ Good: Sync for argument extraction\npub fn extract_argument<T: Clone>(matches: &ArgMatches, name: &str) -> Option<T> {\n    matches.get_one::<T>(name).cloned()\n}\n```\n\n## üß™ Testing Best Practices\n\n### üéØ Core Testing Philosophy\n**Test behaviors, not implementation details. The best test suite is the smallest one that still catches all bugs.**\n\nFocus on testing what the code does (behavior) rather than how it does it (implementation).\n\n```rust\n// ‚ùå Bad: Testing implementation details\n#[test]\nfn test_registry_uses_hashmap() {\n    let registry = CommandRegistry::new();\n    assert_eq!(registry.nouns.len(), 0); // Implementation detail!\n}\n\n// ‚úÖ Good: Testing behavior\n#[test]\nfn test_registry_builds_valid_command() -> Result<()> {\n    let registry = CommandRegistry::new()\n        .name(\"test\")\n        .register_noun(noun!(\"services\", \"Manage services\", [\n            verb!(\"status\", \"Show status\", |_args| Ok(()))\n        ]));\n\n    let command = registry.build_command();\n    assert!(command.get_subcommands().any(|cmd| cmd.get_name() == \"services\"));\n    Ok(())\n}\n```\n\n### ‚úÖ Follow AAA pattern (Arrange, Act, Assert)\n```rust\n// ‚úÖ Good: Clear AAA structure\n#[test]\nfn test_verb_executes_with_valid_args() -> Result<()> {\n    // Arrange - Set up test data\n    let verb = verb!(\"test\", \"Test command\", |args: &VerbArgs| {\n        let value = args.get_one_str(\"value\")?;\n        assert_eq!(value, \"test\");\n        Ok(())\n    }, args: [\n        Arg::new(\"value\").required(true)\n    ]);\n\n    // Act - Execute the code under test\n    let matches = Command::new(\"test\")\n        .arg(Arg::new(\"value\").required(true))\n        .get_matches_from(vec![\"test\", \"test\"]);\n    let verb_args = VerbArgs::new(matches);\n\n    // Assert - Verify the results\n    verb.run(&verb_args)?;\n    Ok(())\n}\n```\n\n### ‚úÖ Use descriptive test names\n```rust\n// ‚úÖ Good: Descriptive test names\n#[test]\nfn test_verb_command_executes_successfully_with_required_args() -> Result<()> {}\n\n#[test]\nfn test_registry_validation_catches_duplicate_noun_names() -> Result<()> {}\n\n// ‚ùå Bad: Vague test names\n#[test]\nfn test_verb() {}\n```\n\n### ‚ö° Test Performance Requirements\n**The ENTIRE test suite MUST complete within 1 second. If the test suite takes longer, optimize with concurrency or other performance improvements.**\n\n- Run tests with timeout: `cargo test -- --timeout 1s` or configure test timeouts (default parallel execution is used)\n- The complete test suite (all tests combined) must finish in under 1 second\n- Use parallel test execution (cargo test default, or `--test-threads=N` to explicitly set concurrency) to maximize speed\n- For slow test suites, refactor tests to use concurrent execution, optimize test code, or reduce test coverage to essential behaviors only\n- Individual tests should be fast (<100ms each) to allow the full suite to complete in <1s with parallel execution\n- Note: `--test-threads=1` forces sequential execution (slower) - avoid unless testing sequential behavior\n\n```rust\n// ‚ùå Bad: Slow test suite that takes >1s total\n#[test]\nfn test_slow_operation() -> Result<()> {\n    // Sequential operations that make the suite too slow\n    for i in 0..10000 {\n        expensive_operation(i)?;\n    }\n    Ok(())\n}\n\n// ‚úÖ Good: Fast test that completes quickly\n#[test]\nfn test_fast_operation() -> Result<()> {\n    use std::sync::Arc;\n    use std::thread;\n\n    // Parallel execution for independent operations within the test\n    let handles: Vec<_> = (0..10000)\n        .map(|i| {\n            thread::spawn(move || {\n                expensive_operation(i)\n            })\n        })\n        .collect();\n\n    for handle in handles {\n        handle.join().unwrap()?;\n    }\n    Ok(())\n}\n\n// ‚úÖ Good: Optimized test that contributes to fast suite completion\n#[test]\nfn test_optimized_operation() -> Result<()> {\n    // Refactored to use efficient algorithms/data structures\n    batch_operation(0..10000)?;\n    Ok(())\n}\n```\n\n## üì¶ Module Organization Best Practices\n\n### ‚úÖ Use proper module structure\n```rust\n// ‚úÖ Good: Clear module organization\npub mod builder {\n    // CLI builder implementation\n}\n\npub mod registry {\n    // Command registry implementation\n}\n\npub mod error {\n    // Error types\n}\n```\n\n### ‚úÖ Use proper imports and avoid wildcard imports in production code\n```rust\n// ‚úÖ Good: Specific imports\nuse crate::error::{NounVerbError, Result};\nuse crate::builder::CliBuilder;\nuse crate::registry::CommandRegistry;\n\n// ‚ùå Bad: Wildcard imports in production code\nuse crate::*;\n```\n\n## üèóÔ∏è Architecture Guidelines\n\n### ‚úÖ Trait Design\n- Keep traits `dyn` compatible (no async trait methods)\n- Use static string lifetimes (`&'static str`) for trait methods\n- Provide sensible defaults where possible\n- Document trait contracts clearly\n\n```rust\n// ‚úÖ Good: Dyn-compatible trait design\npub trait VerbCommand: Send + Sync {\n    fn name(&self) -> &'static str;\n    fn about(&self) -> &'static str;\n    fn run(&self, args: &VerbArgs) -> Result<()>;\n    fn build_command(&self) -> Command {\n        Command::new(self.name()).about(self.about())\n    }\n}\n```\n\n### ‚úÖ Builder Pattern\n- Use method chaining for ergonomic APIs\n- Provide sensible defaults\n- Allow configuration at any point in the chain\n- Make the API intuitive and discoverable\n\n```rust\n// ‚úÖ Good: Ergonomic builder API\nlet cli = Cli::new()\n    .name(\"myapp\")\n    .about(\"My application\")\n    .global_args(vec![/* ... */])\n    .noun(noun!(\"services\", \"Manage services\", [/* ... */]))\n    .auto_validate(true);\n```\n\n### ‚úÖ Macro Design\n- Keep macros simple and focused\n- Provide clear error messages for macro misuse\n- Use proper hygiene to avoid name conflicts\n- Document macro syntax and behavior\n\n## üö´ Code Quality Anti-Patterns\n\n### ‚ùå Avoid printing/logging in production code\n```rust\n// ‚ùå Bad: Printing in production code\nfn process_command(args: &VerbArgs) -> Result<()> {\n    println!(\"Processing command...\"); // Don't do this!\n    Ok(())\n}\n\n// ‚úÖ Good: Use proper error handling - no logging needed for CLI framework\nfn process_command(args: &VerbArgs) -> Result<()> {\n    // Framework logic - errors are returned via Result\n    Ok(())\n}\n```\n\n### ‚ùå NEVER use unwrap() or expect() anywhere in production code\n```rust\n// ‚ùå Bad: Even in helper functions\nfn get_argument<T>(matches: &ArgMatches, name: &str) -> T {\n    matches.get_one::<T>(name).unwrap() // Don't do this!\n}\n\n// ‚úÖ Good: Proper error handling\nfn get_argument<T: Clone>(matches: &ArgMatches, name: &str) -> Result<T> {\n    matches.get_one::<T>(name)\n        .cloned()\n        .ok_or_else(|| NounVerbError::missing_argument(name))\n}\n```\n\n## üéØ API Design Principles\n\n### ‚úÖ Framework Philosophy\n**clap-noun-verb** is designed as a **framework** rather than a library of specific compositions:\n\n1. **Composable by Design** - Users compose their own CLI patterns\n2. **Multiple Composition Methods** - Choose the approach that fits your needs\n3. **Extensible Architecture** - Easy to extend and customize for specific use cases\n4. **Framework-Level APIs** - APIs that make it easy to build CLI frameworks\n\n### ‚úÖ Type Safety\n- Use compile-time verification where possible\n- Leverage Rust's type system for safety\n- Provide helpful error messages when validation fails\n\n```rust\n// ‚úÖ Good: Compile-time type safety\npub fn get_one<T: Clone>(&self, name: &str) -> Result<T> {\n    self.matches.get_one::<T>(name)\n        .cloned()\n        .ok_or_else(|| NounVerbError::missing_argument(name))\n}\n```\n\n### ‚úÖ Zero-Cost Abstractions\n- Thin wrapper over clap\n- No runtime overhead\n- Maintain clap's performance characteristics\n\n## üö´ Breaking Changes and Compatibility\n\n### ‚ùå NEVER make breaking changes without migration plan\n```rust\n// ‚ùå Bad: Changing trait signatures breaks all implementations\npub trait VerbCommand: Send + Sync {\n    fn run(&self, args: &VerbArgs) -> Result<()>; // Original\n    // Later changed to:\n    fn run(&self, args: &VerbArgs, context: &Context) -> Result<()>; // BREAKS ALL IMPLEMENTATIONS!\n}\n\n// ‚úÖ Good: Add new methods, deprecate old ones\npub trait VerbCommand: Send + Sync {\n    fn run(&self, args: &VerbArgs) -> Result<()>; // Keep for compatibility\n\n    #[deprecated(note = \"Use run_with_context instead\")]\n    fn run_with_context(&self, args: &VerbArgs, context: &Context) -> Result<()> {\n        self.run(args) // Default implementation\n    }\n}\n```\n\n### ‚úÖ Always maintain backward compatibility\n- Add new methods instead of changing existing ones\n- Use deprecation warnings for old methods\n- Provide migration guides for breaking changes\n- Test all existing implementations still work\n\n## üéØ Core Team Standards Summary\n\n1. **Error Handling**: Never use `.unwrap()` or `.expect()` in production code. Always use proper `Result<T, E>` types with meaningful error messages.\n\n2. **Trait Design**: Keep traits `dyn` compatible. Use sync methods in traits. No async trait methods.\n\n3. **Breaking Changes**: Never make breaking changes without migration plan. Maintain backward compatibility.\n\n4. **Testing**: Follow AAA pattern, use descriptive names, proper test functions, and test behaviors not implementation.\n\n5. **Code Quality**: Proper module organization, avoid wildcard imports, use structured error types, no false positives.\n\n6. **API Design**: Framework philosophy - composable, extensible, type-safe, zero-cost abstractions.\n\n7. **Performance**: Thin wrapper over clap, maintain clap's performance characteristics.\n\n8. **Documentation**: Comprehensive documentation with examples for all public APIs.\n\n## ‚úÖ Definition of Done - Core Team Standards\n\n### Before any code is considered complete, ALL of these must be true:\n\n1. **‚úÖ Compilation**: Code compiles without errors or warnings\n2. **‚úÖ No unwrap()/expect()**: Zero usage of unwrap() or expect() in production code\n3. **‚úÖ Trait Compatibility**: All traits remain `dyn` compatible (no async trait methods)\n4. **‚úÖ Backward Compatibility**: No breaking changes without migration plan\n5. **‚úÖ All Tests Pass**: Every test in the codebase passes\n6. **‚úÖ Test Performance**: The ENTIRE test suite completes in <1 second (use concurrency or optimization if needed)\n7. **‚úÖ No Linting Errors**: Zero linting errors or warnings\n8. **‚úÖ Proper Error Handling**: All functions use Result types with meaningful errors\n9. **‚úÖ API Design**: Follows framework philosophy - composable and extensible\n10. **‚úÖ Documentation**: All public APIs have documentation with examples\n\n### Validation Checklist:\n- [ ] `cargo test` passes completely\n- [ ] `cargo test -- --timeout 1s` passes (entire test suite completes in <1s with parallel execution)\n- [ ] `cargo clippy` shows no warnings\n- [ ] No `unwrap()` or `expect()` in production code\n- [ ] All traits are `dyn` compatible\n- [ ] No breaking changes to public APIs\n- [ ] All error paths use proper Result types\n- [ ] All public APIs have documentation with examples\n- [ ] Entire test suite completes in <1s (add concurrency or optimization if needed)\n\n### If ANY of these fail, the code is NOT ready for production.\n\n## ü§ñ AI Code Generation Guidelines\n\n### ‚úÖ Generate production-ready code for clap-noun-verb\n```rust\n// ‚úÖ Good: Real implementations with proper error handling\npub fn register_noun(&mut self, noun: Box<dyn NounCommand>) -> Result<()> {\n    let name = noun.name();\n    if self.nouns.contains_key(name) {\n        return Err(NounVerbError::invalid_structure(\n            format!(\"Duplicate noun name: {}\", name)\n        ));\n    }\n    self.nouns.insert(name.to_string(), noun);\n    Ok(())\n}\n\n// ‚úÖ Good: Proper argument extraction\npub fn get_one_str(&self, name: &str) -> Result<String> {\n    self.matches.get_one::<String>(name)\n        .cloned()\n        .ok_or_else(|| NounVerbError::missing_argument(name))\n}\n```\n\n### ‚úÖ Code Generation Checklist\nBefore generating any code file, ensure:\n- [ ] No `unimplemented!()`, `todo!()`, or `panic!()` macros in production code\n- [ ] No `.unwrap()` or `.expect()` - use proper error handling\n- [ ] All functions return `Result<T>` types\n- [ ] All traits are `dyn` compatible\n- [ ] Code compiles without warnings\n- [ ] Passes `cargo clippy` checks\n- [ ] All public APIs have documentation with examples\n- [ ] Follows framework philosophy (composable, extensible)\n\n## üìö Documentation Standards\n\n### ‚úÖ Public API Documentation\nAll public types, traits, and functions must have comprehensive documentation:\n\n```rust\n/// A builder for creating composable CLI applications.\n///\n/// This builder allows you to construct CLI applications using the\n/// noun-verb pattern, where commands follow the structure `noun verb`\n/// (e.g., `services status`, `collector up`).\n///\n/// # Example\n///\n/// ```rust,no_run\n/// use clap_noun_verb::{Cli, noun, verb, VerbArgs, Result};\n///\n/// fn main() -> Result<()> {\n///     let cli = Cli::new()\n///         .name(\"myapp\")\n///         .noun(noun!(\"services\", \"Manage services\", [\n///             verb!(\"status\", \"Show status\", |_args: &VerbArgs| Ok(())),\n///         ]));\n///     cli.run()\n/// }\n/// ```\npub struct CliBuilder {\n    // ...\n}\n```\n\n### ‚úÖ Trait Documentation\nTraits should document their contracts and provide usage examples:\n\n```rust\n/// A command that represents a noun (group of verbs).\n///\n/// Nouns are the first level of the noun-verb pattern (e.g., `services`,\n/// `collector`). Each noun contains one or more verbs that can be executed.\n///\n/// # Example\n///\n/// ```rust,no_run\n/// use clap_noun_verb::{NounCommand, VerbCommand, VerbArgs, Result};\n///\n/// struct MyNoun;\n///\n/// impl NounCommand for MyNoun {\n///     fn name(&self) -> &'static str { \"mynoun\" }\n///     fn about(&self) -> &'static str { \"My noun command\" }\n///     fn verbs(&self) -> Vec<Box<dyn VerbCommand>> { vec![] }\n/// }\n/// ```\npub trait NounCommand: Send + Sync {\n    // ...\n}\n```\n\nThese rules ensure FAANG-level code quality, reliability, and maintainability while following the framework's composable design philosophy.\n\n\n\n\n"
        }
    ]
}