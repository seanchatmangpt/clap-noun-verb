{
    "sourceFile": "README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1762032999870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762033034102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,422 @@\n+# clap-noun-verb\n+\n+A framework for building composable CLI patterns on top of clap. This crate provides the foundation for creating command-line interfaces with the `noun verb` pattern (e.g., `services status`, `collector up`), similar to how Python's Typer provides a simpler interface over Click.\n+\n+## Version 3.0.0 - Attribute Macros & Auto-Discovery\n+\n+This crate has reached version 3.0.0 with revolutionary attribute macros:\n+\n+- **Attribute Macros**: `#[noun]` and `#[verb]` for zero-boilerplate command registration\n+- **Auto-Discovery**: Commands automatically discovered at compile time using `linkme`\n+- **Type Inference**: Arguments automatically inferred from function signatures\n+- **JSON Output**: All output automatically serialized to JSON (perfect for agents/MCP)\n+- **Production Ready**: Suitable for use in production applications\n+\n+For details, see the [Quick Start](#quick-start) section.\n+\n+## Framework Philosophy\n+\n+**clap-noun-verb** is designed as a **framework** rather than a library of specific compositions. Instead of providing pre-built CLI patterns, it provides the tools and APIs that allow you to compose your own CLI patterns in flexible, extensible ways.\n+\n+### Key Framework Features\n+\n+- **Composable Command Structure**: Easy composition of nouns and verbs\n+- **Framework-Level APIs**: APIs that make it easy to build CLI frameworks\n+- **Extensible Traits**: Traits that can be easily extended and customized\n+- **Hierarchical Command Support**: Support for complex nested command structures\n+- **Type-Safe Composition**: Compile-time verification of command structure\n+- **Multiple Composition Methods**: Choose the composition style that fits your needs\n+\n+## Features\n+\n+- **Trait-based command definition** - `NounCommand` and `VerbCommand` traits for type-safe command structure\n+- **Builder pattern API** - Ergonomic command registration with method chaining\n+- **Automatic help generation** - Enhanced help text for noun-verb patterns\n+- **Type-safe command routing** - Compile-time verification of command structure\n+- **Zero-cost abstractions** - Thin wrapper over clap with no runtime overhead\n+- **Convenience macros** - Reduce boilerplate with `noun!` and `verb!` macros\n+- **Argument extraction helpers** - Type-safe argument extraction from `VerbArgs` with helper methods\n+- **Verb argument support** - Define arguments directly in verb macros\n+- **Command structure validation** - Validate command structure for duplicate names and conflicts\n+- **Global arguments access** - Verbs can access global arguments like `--verbose` and `--config` from parent commands\n+- **PathBuf convenience methods** - Specialized helpers for `PathBuf` argument extraction\n+- **Auto-validation option** - Optional automatic structure validation on build/run\n+\n+## Quick Start\n+\n+Add this to your `Cargo.toml`:\n+\n+```toml\n+[dependencies]\n+clap-noun-verb = \"3.0.0\"\n+clap-noun-verb-macros = \"3.0.0\"\n+```\n+\n+## Architecture\n+\n+Version 3.0.0 uses attribute macros for zero-boilerplate command registration:\n+\n+```\n+Function with #[verb] → Auto-registered → Auto-discovered → JSON output\n+```\n+\n+### Key Principles\n+\n+1. **Zero Boilerplate** - Just add `#[noun]` and `#[verb]` attributes\n+2. **Auto-Discovery** - Commands automatically discovered at compile time\n+3. **Type Inference** - Arguments inferred from function signatures\n+4. **JSON by Default** - Perfect for agents, MCP, and modern tooling\n+\n+## Quick Start\n+\n+The recommended approach in v3.0.0 uses attribute macros for zero-boilerplate command registration:\n+\n+```rust\n+use clap_noun_verb_macros::{noun, verb};\n+use clap_noun_verb::Result;\n+use serde::Serialize;\n+\n+#[derive(Serialize)]\n+struct Status {\n+    services: Vec<String>,\n+    healthy: bool,\n+}\n+\n+/// Show service status\n+#[noun(\"services\", \"Manage services\")]\n+#[verb(\"status\")]\n+fn show_status() -> Result<Status> {\n+    Ok(Status {\n+        services: vec![\"api\".to_string(), \"worker\".to_string()],\n+        healthy: true,\n+    })\n+}\n+\n+fn main() -> Result<()> {\n+    clap_noun_verb::run() // Auto-discovers all commands!\n+}\n+```\n+\n+**Usage:**\n+```bash\n+$ myapp services status\n+{\"services\":[\"api\",\"worker\"],\"healthy\":true}\n+```\n+\n+**Key Benefits:**\n+- ✅ **Zero boilerplate** - Just add attributes\n+- ✅ **Auto-discovery** - Commands discovered at compile time\n+- ✅ **Type inference** - Arguments inferred from function signature\n+- ✅ **JSON by default** - Perfect for agents/MCP\n+\n+## Framework Usage\n+\n+The framework provides a simple, opinionated API for 80% of use cases using attribute macros:\n+\n+```rust\n+use clap_noun_verb_macros::{noun, verb};\n+use clap_noun_verb::Result;\n+use serde::Serialize;\n+\n+#[derive(Serialize)]\n+struct Status {\n+    services: Vec<String>,\n+    healthy: bool,\n+}\n+\n+/// Show service status\n+#[noun(\"services\", \"Manage services\")]\n+#[verb(\"status\")]\n+fn show_status() -> Result<Status> {\n+    Ok(Status {\n+        services: vec![\"api\".to_string(), \"worker\".to_string()],\n+        healthy: true,\n+    })\n+}\n+\n+/// Show logs for a service\n+#[verb(\"logs\")]\n+fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n+    // service: String → Required argument --service\n+    // lines: Option<usize> → Optional argument --lines\n+    Ok(Logs {\n+        service,\n+        lines: lines.unwrap_or(50),\n+        entries: vec![],\n+    })\n+}\n+\n+#[derive(Serialize)]\n+struct Logs {\n+    service: String,\n+    lines: usize,\n+    entries: Vec<String>,\n+}\n+\n+fn main() -> Result<()> {\n+    clap_noun_verb::run() // Auto-discovers all commands!\n+}\n+```\n+\n+**That's it!** Just add `#[noun]` and `#[verb]` attributes to your functions.\n+\n+### Arguments with Type Inference\n+\n+Arguments are automatically inferred from function signatures:\n+\n+```rust\n+/// Show logs for a service\n+/// \n+/// # Arguments\n+/// * `service` - Service name (required)\n+/// * `lines` - Number of lines to show (default: 50)\n+#[verb(\"logs\")]\n+fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n+    // service: String → Required argument --service\n+    // lines: Option<usize> → Optional argument --lines\n+    Ok(Logs {\n+        service,\n+        lines: lines.unwrap_or(50),\n+        entries: vec![],\n+    })\n+}\n+```\n+\n+**Type inference rules:**\n+- `String` → Required argument `--name`\n+- `Option<T>` → Optional argument `--name <value>`\n+- `bool` → Flag `--name` (true if present)\n+- `Vec<T>` → Multiple values `--name <value1> <value2> ...`\n+\n+## Examples\n+\n+Run the attribute macro example:\n+\n+```bash\n+cargo run --example attribute_macro -- services status\n+cargo run --example attribute_macro -- services logs api --lines 100\n+```\n+\n+## API Reference\n+\n+### Attribute Macros\n+\n+- **`#[noun(\"name\", \"description\")]`** - Register a noun command\n+- **`#[verb(\"name\")]`** - Register a verb command with auto-discovery\n+\n+### Core Types\n+\n+- **`Result<T>`** - Error type used throughout the framework\n+- **All output types must implement `Serialize`** - For JSON output\n+\n+### Error Types\n+\n+The crate uses `thiserror` for comprehensive error handling:\n+\n+- **`NounVerbError::CommandNotFound`** - When a command is not found\n+- **`NounVerbError::ExecutionError`** - When command execution fails\n+- **`NounVerbError::ArgumentError`** - When argument parsing fails\n+\n+## Design Philosophy\n+\n+### Why Framework-Based?\n+\n+**clap-noun-verb** is designed as a **framework** that enables composition rather than providing specific compositions:\n+\n+1. **Composable by Design** - Users compose their own CLI patterns\n+2. **Multiple Composition Methods** - Choose the approach that fits your needs\n+3. **Extensible Architecture** - Easy to extend and customize for specific use cases\n+4. **Framework-Level APIs** - APIs that make it easy to build CLI frameworks\n+\n+### Why Noun-Verb Pattern?\n+\n+The noun-verb pattern provides several benefits:\n+\n+1. **Intuitive Structure** - Commands naturally group related functionality\n+2. **Scalable Organization** - Easy to add new verbs to existing nouns\n+3. **Consistent UX** - Users learn one pattern and can apply it everywhere\n+4. **Type Safety** - Compile-time verification of command structure\n+\n+### Why Trait-Based Architecture?\n+\n+- **Extensibility** - Easy to add new command types without modifying core\n+- **Type Safety** - Compile-time verification of command implementations\n+- **Testability** - Commands can be easily mocked and tested\n+- **Composability** - Commands can be combined and reused\n+\n+### Why Multiple Composition Methods?\n+\n+Different projects have different needs:\n+\n+- **Declarative** - For simple, static CLI structures\n+- **Builder** - For flexible, programmatic composition\n+- **Registry** - For dynamic, runtime composition\n+- **Tree** - For complex, hierarchical command structures\n+\n+## Framework vs Direct clap Usage\n+\n+### Direct clap (verbose enum-based):\n+\n+```rust\n+use clap::{Parser, Subcommand};\n+\n+#[derive(Parser)]\n+struct Cli {\n+    #[command(subcommand)]\n+    command: Commands,\n+}\n+\n+#[derive(Subcommand)]\n+enum Commands {\n+    Services {\n+        #[command(subcommand)]\n+        command: ServiceCommands,\n+    },\n+}\n+\n+#[derive(Subcommand)]\n+enum ServiceCommands {\n+    Status,\n+    Logs { service: String },\n+    Restart { service: String },\n+}\n+\n+fn main() {\n+    let cli = Cli::parse();\n+    match cli.command {\n+        Commands::Services { command } => match command {\n+            ServiceCommands::Status => println!(\"Services running\"),\n+            ServiceCommands::Logs { service } => println!(\"Logs for {}\", service),\n+            ServiceCommands::Restart { service } => println!(\"Restarting {}\", service),\n+        },\n+    }\n+}\n+```\n+\n+### With clap-noun-verb Framework (attribute macros):\n+\n+```rust\n+use clap_noun_verb_macros::{noun, verb};\n+use clap_noun_verb::Result;\n+use serde::Serialize;\n+\n+#[derive(Serialize)]\n+struct Status {\n+    services: Vec<String>,\n+    healthy: bool,\n+}\n+\n+#[noun(\"services\", \"Manage services\")]\n+#[verb(\"status\")]\n+fn show_status() -> Result<Status> {\n+    Ok(Status {\n+        services: vec![\"api\".to_string(), \"worker\".to_string()],\n+        healthy: true,\n+    })\n+}\n+\n+#[verb(\"logs\")]\n+fn show_logs(service: String) -> Result<String> {\n+    Ok(format!(\"Logs for {}\", service))\n+}\n+\n+fn main() -> Result<()> {\n+    clap_noun_verb::run() // Auto-discovers all commands!\n+}\n+```\n+\n+The framework approach provides:\n+- **Zero boilerplate** - Just add attributes\n+- **Auto-discovery** - Commands automatically registered\n+- **Better organization** - Commands grouped by functionality\n+- **Type safety** - Compile-time verification\n+- **JSON output** - Perfect for agents/MCP\n+\n+## CLI Patterns for Porting\n+\n+Here are common CLI patterns that could benefit from the noun-verb approach:\n+\n+### Example Patterns to Convert\n+\n+**Services Management:**\n+```rust\n+// Current: services status|logs|restart|ai-manage\n+// Could be: services status, services logs, services restart, services ai-manage\n+```\n+\n+**Collector Management:**\n+```rust\n+// Current: collector up|down|status|logs\n+// Could be: collector up, collector down, collector status, collector logs\n+```\n+\n+**Report Generation:**\n+```rust\n+// Current: report --input --output --format\n+// Could be: report generate, report view, report export\n+```\n+\n+**Template Operations:**\n+```rust\n+// Current: template <template_name> --output\n+// Could be: template generate, template list, template validate\n+```\n+\n+**AI Commands:**\n+```rust\n+// Current: ai-orchestrate, ai-predict, ai-optimize, ai-real, ai-monitor\n+// Could be: ai orchestrate, ai predict, ai optimize, ai real, ai monitor\n+```\n+\n+**Trace Operations:**\n+```rust\n+// Current: analyze, diff, graph, spans, repro\n+// Could be: trace analyze, trace diff, trace graph, trace spans, trace repro\n+```\n+\n+**Development Tools:**\n+```rust\n+// Current: dev, dry-run, fmt, lint\n+// Could be: dev test, dev lint, dev format, dev run\n+```\n+\n+This creates intuitive command structures like:\n+- `myapp services status`\n+- `myapp services logs <service>`\n+\n+## Migration Guide\n+\n+### From Direct clap or v1.x\n+\n+1. **Replace builder/enum-based commands** with attribute macros\n+2. **Add `#[derive(Serialize)]`** to output types\n+3. **Use `#[noun]` and `#[verb]`** attributes on functions\n+4. **Return `Result<T>`** where `T: Serialize` for JSON output\n+\n+```rust\n+// Old (v1.x or direct clap)\n+let cli = CliBuilder::new(\"myapp\")\n+    .noun(\"services\", \"Manage services\")\n+    .verb(\"services\", \"status\", \"Show status\", handler);\n+cli.run()\n+\n+// New (v3.0.0)\n+#[noun(\"services\", \"Manage services\")]\n+#[verb(\"status\")]\n+fn show_status() -> Result<Status> { ... }\n+fn main() -> Result<()> { clap_noun_verb::run() }\n+```\n+\n+## Contributing\n+\n+Contributions are welcome! Please see the [CONTRIBUTING.md](CONTRIBUTING.md) file for guidelines.\n+\n+## License\n+\n+This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n+\n+## Acknowledgments\n+\n+- Inspired by Python's [Typer](https://typer.tiangolo.com/) library\n+- Built on top of the excellent [clap](https://crates.io/crates/clap) crate\n+- Error handling powered by [thiserror](https://crates.io/crates/thiserror)\n"
                },
                {
                    "date": 1762033102978,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -419,426 +419,4 @@\n \n - Inspired by Python's [Typer](https://typer.tiangolo.com/) library\n - Built on top of the excellent [clap](https://crates.io/crates/clap) crate\n - Error handling powered by [thiserror](https://crates.io/crates/thiserror)\n-# clap-noun-verb\n-\n-A framework for building composable CLI patterns on top of clap. This crate provides the foundation for creating command-line interfaces with the `noun verb` pattern (e.g., `services status`, `collector up`), similar to how Python's Typer provides a simpler interface over Click.\n-\n-## Version 3.0.0 - Attribute Macros & Auto-Discovery\n-\n-This crate has reached version 3.0.0 with revolutionary attribute macros:\n-\n-- **Attribute Macros**: `#[noun]` and `#[verb]` for zero-boilerplate command registration\n-- **Auto-Discovery**: Commands automatically discovered at compile time using `linkme`\n-- **Type Inference**: Arguments automatically inferred from function signatures\n-- **JSON Output**: All output automatically serialized to JSON (perfect for agents/MCP)\n-- **Production Ready**: Suitable for use in production applications\n-\n-For details, see the [Quick Start](#quick-start) section.\n-\n-## Framework Philosophy\n-\n-**clap-noun-verb** is designed as a **framework** rather than a library of specific compositions. Instead of providing pre-built CLI patterns, it provides the tools and APIs that allow you to compose your own CLI patterns in flexible, extensible ways.\n-\n-### Key Framework Features\n-\n-- **Composable Command Structure**: Easy composition of nouns and verbs\n-- **Framework-Level APIs**: APIs that make it easy to build CLI frameworks\n-- **Extensible Traits**: Traits that can be easily extended and customized\n-- **Hierarchical Command Support**: Support for complex nested command structures\n-- **Type-Safe Composition**: Compile-time verification of command structure\n-- **Multiple Composition Methods**: Choose the composition style that fits your needs\n-\n-## Features\n-\n-- **Trait-based command definition** - `NounCommand` and `VerbCommand` traits for type-safe command structure\n-- **Builder pattern API** - Ergonomic command registration with method chaining\n-- **Automatic help generation** - Enhanced help text for noun-verb patterns\n-- **Type-safe command routing** - Compile-time verification of command structure\n-- **Zero-cost abstractions** - Thin wrapper over clap with no runtime overhead\n-- **Convenience macros** - Reduce boilerplate with `noun!` and `verb!` macros\n-- **Argument extraction helpers** - Type-safe argument extraction from `VerbArgs` with helper methods\n-- **Verb argument support** - Define arguments directly in verb macros\n-- **Command structure validation** - Validate command structure for duplicate names and conflicts\n-- **Global arguments access** - Verbs can access global arguments like `--verbose` and `--config` from parent commands\n-- **PathBuf convenience methods** - Specialized helpers for `PathBuf` argument extraction\n-- **Auto-validation option** - Optional automatic structure validation on build/run\n-\n-## Quick Start\n-\n-Add this to your `Cargo.toml`:\n-\n-```toml\n-[dependencies]\n-clap-noun-verb = \"3.0.0\"\n-clap-noun-verb-macros = \"3.0.0\"\n-```\n-\n-## Architecture\n-\n-Version 3.0.0 uses attribute macros for zero-boilerplate command registration:\n-\n-```\n-Function with #[verb] → Auto-registered → Auto-discovered → JSON output\n-```\n-\n-### Key Principles\n-\n-1. **Zero Boilerplate** - Just add `#[noun]` and `#[verb]` attributes\n-2. **Auto-Discovery** - Commands automatically discovered at compile time\n-3. **Type Inference** - Arguments inferred from function signatures\n-4. **JSON by Default** - Perfect for agents, MCP, and modern tooling\n-\n-## Quick Start\n-\n-The recommended approach in v3.0.0 uses attribute macros for zero-boilerplate command registration:\n-\n-```rust\n-use clap_noun_verb_macros::{noun, verb};\n-use clap_noun_verb::Result;\n-use serde::Serialize;\n-\n-#[derive(Serialize)]\n-struct Status {\n-    services: Vec<String>,\n-    healthy: bool,\n-}\n-\n-/// Show service status\n-#[noun(\"services\", \"Manage services\")]\n-#[verb(\"status\")]\n-fn show_status() -> Result<Status> {\n-    Ok(Status {\n-        services: vec![\"api\".to_string(), \"worker\".to_string()],\n-        healthy: true,\n-    })\n-}\n-\n-fn main() -> Result<()> {\n-    clap_noun_verb::run() // Auto-discovers all commands!\n-}\n-```\n-\n-**Usage:**\n-```bash\n-$ myapp services status\n-{\"services\":[\"api\",\"worker\"],\"healthy\":true}\n-```\n-\n-**Key Benefits:**\n-- ✅ **Zero boilerplate** - Just add attributes\n-- ✅ **Auto-discovery** - Commands discovered at compile time\n-- ✅ **Type inference** - Arguments inferred from function signature\n-- ✅ **JSON by default** - Perfect for agents/MCP\n-\n-## Framework Usage\n-\n-The framework provides a simple, opinionated API for 80% of use cases using attribute macros:\n-\n-```rust\n-use clap_noun_verb_macros::{noun, verb};\n-use clap_noun_verb::Result;\n-use serde::Serialize;\n-\n-#[derive(Serialize)]\n-struct Status {\n-    services: Vec<String>,\n-    healthy: bool,\n-}\n-\n-/// Show service status\n-#[noun(\"services\", \"Manage services\")]\n-#[verb(\"status\")]\n-fn show_status() -> Result<Status> {\n-    Ok(Status {\n-        services: vec![\"api\".to_string(), \"worker\".to_string()],\n-        healthy: true,\n-    })\n-}\n-\n-/// Show logs for a service\n-#[verb(\"logs\")]\n-fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n-    // service: String → Required argument --service\n-    // lines: Option<usize> → Optional argument --lines\n-    Ok(Logs {\n-        service,\n-        lines: lines.unwrap_or(50),\n-        entries: vec![],\n-    })\n-}\n-\n-#[derive(Serialize)]\n-struct Logs {\n-    service: String,\n-    lines: usize,\n-    entries: Vec<String>,\n-}\n-\n-fn main() -> Result<()> {\n-    clap_noun_verb::run() // Auto-discovers all commands!\n-}\n-```\n-\n-**That's it!** Just add `#[noun]` and `#[verb]` attributes to your functions.\n-\n-### Arguments with Type Inference\n-\n-Arguments are automatically inferred from function signatures:\n-\n-```rust\n-/// Show logs for a service\n-/// \n-/// # Arguments\n-/// * `service` - Service name (required)\n-/// * `lines` - Number of lines to show (default: 50)\n-#[verb(\"logs\")]\n-fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n-    // service: String → Required argument --service\n-    // lines: Option<usize> → Optional argument --lines\n-    Ok(Logs {\n-        service,\n-        lines: lines.unwrap_or(50),\n-        entries: vec![],\n-    })\n-}\n-```\n-\n-**Type inference rules:**\n-- `String` → Required argument `--name`\n-- `Option<T>` → Optional argument `--name <value>`\n-- `bool` → Flag `--name` (true if present)\n-- `Vec<T>` → Multiple values `--name <value1> <value2> ...`\n-\n-## Examples\n-\n-Run the attribute macro example:\n-\n-```bash\n-cargo run --example attribute_macro -- services status\n-cargo run --example attribute_macro -- services logs api --lines 100\n-```\n-\n-## API Reference\n-\n-### Attribute Macros\n-\n-- **`#[noun(\"name\", \"description\")]`** - Register a noun command\n-- **`#[verb(\"name\")]`** - Register a verb command with auto-discovery\n-\n-### Core Types\n-\n-- **`Result<T>`** - Error type used throughout the framework\n-- **All output types must implement `Serialize`** - For JSON output\n-\n-### Error Types\n-\n-The crate uses `thiserror` for comprehensive error handling:\n-\n-- **`NounVerbError::CommandNotFound`** - When a command is not found\n-- **`NounVerbError::ExecutionError`** - When command execution fails\n-- **`NounVerbError::ArgumentError`** - When argument parsing fails\n-\n-## Design Philosophy\n-\n-### Why Framework-Based?\n-\n-**clap-noun-verb** is designed as a **framework** that enables composition rather than providing specific compositions:\n-\n-1. **Composable by Design** - Users compose their own CLI patterns\n-2. **Multiple Composition Methods** - Choose the approach that fits your needs\n-3. **Extensible Architecture** - Easy to extend and customize for specific use cases\n-4. **Framework-Level APIs** - APIs that make it easy to build CLI frameworks\n-\n-### Why Noun-Verb Pattern?\n-\n-The noun-verb pattern provides several benefits:\n-\n-1. **Intuitive Structure** - Commands naturally group related functionality\n-2. **Scalable Organization** - Easy to add new verbs to existing nouns\n-3. **Consistent UX** - Users learn one pattern and can apply it everywhere\n-4. **Type Safety** - Compile-time verification of command structure\n-\n-### Why Trait-Based Architecture?\n-\n-- **Extensibility** - Easy to add new command types without modifying core\n-- **Type Safety** - Compile-time verification of command implementations\n-- **Testability** - Commands can be easily mocked and tested\n-- **Composability** - Commands can be combined and reused\n-\n-### Why Multiple Composition Methods?\n-\n-Different projects have different needs:\n-\n-- **Declarative** - For simple, static CLI structures\n-- **Builder** - For flexible, programmatic composition\n-- **Registry** - For dynamic, runtime composition\n-- **Tree** - For complex, hierarchical command structures\n-\n-## Framework vs Direct clap Usage\n-\n-### Direct clap (verbose enum-based):\n-\n-```rust\n-use clap::{Parser, Subcommand};\n-\n-#[derive(Parser)]\n-struct Cli {\n-    #[command(subcommand)]\n-    command: Commands,\n-}\n-\n-#[derive(Subcommand)]\n-enum Commands {\n-    Services {\n-        #[command(subcommand)]\n-        command: ServiceCommands,\n-    },\n-}\n-\n-#[derive(Subcommand)]\n-enum ServiceCommands {\n-    Status,\n-    Logs { service: String },\n-    Restart { service: String },\n-}\n-\n-fn main() {\n-    let cli = Cli::parse();\n-    match cli.command {\n-        Commands::Services { command } => match command {\n-            ServiceCommands::Status => println!(\"Services running\"),\n-            ServiceCommands::Logs { service } => println!(\"Logs for {}\", service),\n-            ServiceCommands::Restart { service } => println!(\"Restarting {}\", service),\n-        },\n-    }\n-}\n-```\n-\n-### With clap-noun-verb Framework (attribute macros):\n-\n-```rust\n-use clap_noun_verb_macros::{noun, verb};\n-use clap_noun_verb::Result;\n-use serde::Serialize;\n-\n-#[derive(Serialize)]\n-struct Status {\n-    services: Vec<String>,\n-    healthy: bool,\n-}\n-\n-#[noun(\"services\", \"Manage services\")]\n-#[verb(\"status\")]\n-fn show_status() -> Result<Status> {\n-    Ok(Status {\n-        services: vec![\"api\".to_string(), \"worker\".to_string()],\n-        healthy: true,\n-    })\n-}\n-\n-#[verb(\"logs\")]\n-fn show_logs(service: String) -> Result<String> {\n-    Ok(format!(\"Logs for {}\", service))\n-}\n-\n-fn main() -> Result<()> {\n-    clap_noun_verb::run() // Auto-discovers all commands!\n-}\n-```\n-\n-The framework approach provides:\n-- **Zero boilerplate** - Just add attributes\n-- **Auto-discovery** - Commands automatically registered\n-- **Better organization** - Commands grouped by functionality\n-- **Type safety** - Compile-time verification\n-- **JSON output** - Perfect for agents/MCP\n-\n-## CLI Patterns for Porting\n-\n-Here are common CLI patterns that could benefit from the noun-verb approach:\n-\n-### Example Patterns to Convert\n-\n-**Services Management:**\n-```rust\n-// Current: services status|logs|restart|ai-manage\n-// Could be: services status, services logs, services restart, services ai-manage\n-```\n-\n-**Collector Management:**\n-```rust\n-// Current: collector up|down|status|logs\n-// Could be: collector up, collector down, collector status, collector logs\n-```\n-\n-**Report Generation:**\n-```rust\n-// Current: report --input --output --format\n-// Could be: report generate, report view, report export\n-```\n-\n-**Template Operations:**\n-```rust\n-// Current: template <template_name> --output\n-// Could be: template generate, template list, template validate\n-```\n-\n-**AI Commands:**\n-```rust\n-// Current: ai-orchestrate, ai-predict, ai-optimize, ai-real, ai-monitor\n-// Could be: ai orchestrate, ai predict, ai optimize, ai real, ai monitor\n-```\n-\n-**Trace Operations:**\n-```rust\n-// Current: analyze, diff, graph, spans, repro\n-// Could be: trace analyze, trace diff, trace graph, trace spans, trace repro\n-```\n-\n-**Development Tools:**\n-```rust\n-// Current: dev, dry-run, fmt, lint\n-// Could be: dev test, dev lint, dev format, dev run\n-```\n-\n-This creates intuitive command structures like:\n-- `myapp services status`\n-- `myapp services logs <service>`\n-\n-## Migration Guide\n-\n-### From Direct clap or v1.x\n-\n-1. **Replace builder/enum-based commands** with attribute macros\n-2. **Add `#[derive(Serialize)]`** to output types\n-3. **Use `#[noun]` and `#[verb]`** attributes on functions\n-4. **Return `Result<T>`** where `T: Serialize` for JSON output\n-\n-```rust\n-// Old (v1.x or direct clap)\n-let cli = CliBuilder::new(\"myapp\")\n-    .noun(\"services\", \"Manage services\")\n-    .verb(\"services\", \"status\", \"Show status\", handler);\n-cli.run()\n-\n-// New (v3.0.0)\n-#[noun(\"services\", \"Manage services\")]\n-#[verb(\"status\")]\n-fn show_status() -> Result<Status> { ... }\n-fn main() -> Result<()> { clap_noun_verb::run() }\n-```\n-\n-## Contributing\n-\n-Contributions are welcome! Please see the [CONTRIBUTING.md](CONTRIBUTING.md) file for guidelines.\n-\n-## License\n-\n-This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n-\n-## Acknowledgments\n-\n-- Inspired by Python's [Typer](https://typer.tiangolo.com/) library\n-- Built on top of the excellent [clap](https://crates.io/crates/clap) crate\n-- Error handling powered by [thiserror](https://crates.io/crates/thiserror)\n"
                },
                {
                    "date": 1762033470869,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -134,12 +134,13 @@\n     })\n }\n \n /// Show logs for a service\n-#[verb(\"logs\")]\n+#[verb(\"logs\", \"services\")]\n fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n     // service: String → Required argument --service\n     // lines: Option<usize> → Optional argument --lines\n+    // Note: Second arg to #[verb] is the noun name\n     Ok(Logs {\n         service,\n         lines: lines.unwrap_or(50),\n         entries: vec![],\n@@ -169,12 +170,13 @@\n /// \n /// # Arguments\n /// * `service` - Service name (required)\n /// * `lines` - Number of lines to show (default: 50)\n-#[verb(\"logs\")]\n+#[verb(\"logs\", \"services\")]\n fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n     // service: String → Required argument --service\n     // lines: Option<usize> → Optional argument --lines\n+    // Note: Second arg to #[verb] is the noun name\n     Ok(Logs {\n         service,\n         lines: lines.unwrap_or(50),\n         entries: vec![],\n@@ -187,8 +189,12 @@\n - `Option<T>` → Optional argument `--name <value>`\n - `bool` → Flag `--name` (true if present)\n - `Vec<T>` → Multiple values `--name <value1> <value2> ...`\n \n+**Verb registration rules:**\n+- If function has both `#[noun]` and `#[verb]` → Verb is registered to that noun\n+- If function has only `#[verb]` → Must specify noun name: `#[verb(\"name\", \"noun_name\")]`\n+\n ## Examples\n \n Run the attribute macro example:\n \n@@ -314,10 +320,11 @@\n         healthy: true,\n     })\n }\n \n-#[verb(\"logs\")]\n+#[verb(\"logs\", \"services\")]\n fn show_logs(service: String) -> Result<String> {\n+    // Note: Second arg to #[verb] specifies the noun name\n     Ok(format!(\"Logs for {}\", service))\n }\n \n fn main() -> Result<()> {\n"
                },
                {
                    "date": 1762035141326,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,77 +1,27 @@\n # clap-noun-verb\n \n-A framework for building composable CLI patterns on top of clap. This crate provides the foundation for creating command-line interfaces with the `noun verb` pattern (e.g., `services status`, `collector up`), similar to how Python's Typer provides a simpler interface over Click.\n+A framework for building composable CLI patterns on top of clap using the **noun-verb pattern** (e.g., `services status`, `collector up`). Inspired by Python's Typer.\n \n-## Version 3.0.0 - Attribute Macros & Auto-Discovery\n+## v3.0.0 - Attribute Macros & Auto-Discovery\n \n-This crate has reached version 3.0.0 with revolutionary attribute macros:\n-\n - **Attribute Macros**: `#[noun]` and `#[verb]` for zero-boilerplate command registration\n-- **Auto-Discovery**: Commands automatically discovered at compile time using `linkme`\n-- **Type Inference**: Arguments automatically inferred from function signatures\n+- **Auto-Discovery**: Commands automatically discovered at compile time\n+- **Type Inference**: Arguments inferred from function signatures\n - **JSON Output**: All output automatically serialized to JSON (perfect for agents/MCP)\n-- **Production Ready**: Suitable for use in production applications\n \n-For details, see the [Quick Start](#quick-start) section.\n-\n-## Framework Philosophy\n-\n-**clap-noun-verb** is designed as a **framework** rather than a library of specific compositions. Instead of providing pre-built CLI patterns, it provides the tools and APIs that allow you to compose your own CLI patterns in flexible, extensible ways.\n-\n-### Key Framework Features\n-\n-- **Composable Command Structure**: Easy composition of nouns and verbs\n-- **Framework-Level APIs**: APIs that make it easy to build CLI frameworks\n-- **Extensible Traits**: Traits that can be easily extended and customized\n-- **Hierarchical Command Support**: Support for complex nested command structures\n-- **Type-Safe Composition**: Compile-time verification of command structure\n-- **Multiple Composition Methods**: Choose the composition style that fits your needs\n-\n-## Features\n-\n-- **Trait-based command definition** - `NounCommand` and `VerbCommand` traits for type-safe command structure\n-- **Builder pattern API** - Ergonomic command registration with method chaining\n-- **Automatic help generation** - Enhanced help text for noun-verb patterns\n-- **Type-safe command routing** - Compile-time verification of command structure\n-- **Zero-cost abstractions** - Thin wrapper over clap with no runtime overhead\n-- **Convenience macros** - Reduce boilerplate with `noun!` and `verb!` macros\n-- **Argument extraction helpers** - Type-safe argument extraction from `VerbArgs` with helper methods\n-- **Verb argument support** - Define arguments directly in verb macros\n-- **Command structure validation** - Validate command structure for duplicate names and conflicts\n-- **Global arguments access** - Verbs can access global arguments like `--verbose` and `--config` from parent commands\n-- **PathBuf convenience methods** - Specialized helpers for `PathBuf` argument extraction\n-- **Auto-validation option** - Optional automatic structure validation on build/run\n-\n ## Quick Start\n \n-Add this to your `Cargo.toml`:\n+Add to `Cargo.toml`:\n \n ```toml\n [dependencies]\n clap-noun-verb = \"3.0.0\"\n clap-noun-verb-macros = \"3.0.0\"\n ```\n \n-## Architecture\n+Use attribute macros to define commands:\n \n-Version 3.0.0 uses attribute macros for zero-boilerplate command registration:\n-\n-```\n-Function with #[verb] → Auto-registered → Auto-discovered → JSON output\n-```\n-\n-### Key Principles\n-\n-1. **Zero Boilerplate** - Just add `#[noun]` and `#[verb]` attributes\n-2. **Auto-Discovery** - Commands automatically discovered at compile time\n-3. **Type Inference** - Arguments inferred from function signatures\n-4. **JSON by Default** - Perfect for agents, MCP, and modern tooling\n-\n-## Quick Start\n-\n-The recommended approach in v3.0.0 uses attribute macros for zero-boilerplate command registration:\n-\n ```rust\n use clap_noun_verb_macros::{noun, verb};\n use clap_noun_verb::Result;\n use serde::Serialize;\n@@ -91,179 +41,59 @@\n         healthy: true,\n     })\n }\n \n-fn main() -> Result<()> {\n-    clap_noun_verb::run() // Auto-discovers all commands!\n-}\n-```\n-\n-**Usage:**\n-```bash\n-$ myapp services status\n-{\"services\":[\"api\",\"worker\"],\"healthy\":true}\n-```\n-\n-**Key Benefits:**\n-- ✅ **Zero boilerplate** - Just add attributes\n-- ✅ **Auto-discovery** - Commands discovered at compile time\n-- ✅ **Type inference** - Arguments inferred from function signature\n-- ✅ **JSON by default** - Perfect for agents/MCP\n-\n-## Framework Usage\n-\n-The framework provides a simple, opinionated API for 80% of use cases using attribute macros:\n-\n-```rust\n-use clap_noun_verb_macros::{noun, verb};\n-use clap_noun_verb::Result;\n-use serde::Serialize;\n-\n-#[derive(Serialize)]\n-struct Status {\n-    services: Vec<String>,\n-    healthy: bool,\n-}\n-\n-/// Show service status\n-#[noun(\"services\", \"Manage services\")]\n-#[verb(\"status\")]\n-fn show_status() -> Result<Status> {\n-    Ok(Status {\n-        services: vec![\"api\".to_string(), \"worker\".to_string()],\n-        healthy: true,\n-    })\n-}\n-\n /// Show logs for a service\n #[verb(\"logs\", \"services\")]\n fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n-    // service: String → Required argument --service\n-    // lines: Option<usize> → Optional argument --lines\n-    // Note: Second arg to #[verb] is the noun name\n     Ok(Logs {\n         service,\n         lines: lines.unwrap_or(50),\n         entries: vec![],\n     })\n }\n \n-#[derive(Serialize)]\n-struct Logs {\n-    service: String,\n-    lines: usize,\n-    entries: Vec<String>,\n-}\n-\n fn main() -> Result<()> {\n     clap_noun_verb::run() // Auto-discovers all commands!\n }\n ```\n \n-**That's it!** Just add `#[noun]` and `#[verb]` attributes to your functions.\n+**Usage:**\n+```bash\n+$ myapp services status\n+{\"services\":[\"api\",\"worker\"],\"healthy\":true}\n \n-### Arguments with Type Inference\n+$ myapp services logs api --lines 100\n+{\"service\":\"api\",\"lines\":100,\"entries\":[]}\n+```\n \n+## Type Inference\n+\n Arguments are automatically inferred from function signatures:\n \n-```rust\n-/// Show logs for a service\n-/// \n-/// # Arguments\n-/// * `service` - Service name (required)\n-/// * `lines` - Number of lines to show (default: 50)\n-#[verb(\"logs\", \"services\")]\n-fn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n-    // service: String → Required argument --service\n-    // lines: Option<usize> → Optional argument --lines\n-    // Note: Second arg to #[verb] is the noun name\n-    Ok(Logs {\n-        service,\n-        lines: lines.unwrap_or(50),\n-        entries: vec![],\n-    })\n-}\n-```\n-\n-**Type inference rules:**\n - `String` → Required argument `--name`\n - `Option<T>` → Optional argument `--name <value>`\n - `bool` → Flag `--name` (true if present)\n - `Vec<T>` → Multiple values `--name <value1> <value2> ...`\n \n-**Verb registration rules:**\n-- If function has both `#[noun]` and `#[verb]` → Verb is registered to that noun\n-- If function has only `#[verb]` → Must specify noun name: `#[verb(\"name\", \"noun_name\")]`\n+## Verb Registration\n \n+- Function has both `#[noun]` and `#[verb]` → Verb registered to that noun\n+- Function has only `#[verb]` → Specify noun: `#[verb(\"name\", \"noun_name\")]`\n+\n ## Examples\n \n-Run the attribute macro example:\n-\n ```bash\n cargo run --example attribute_macro -- services status\n-cargo run --example attribute_macro -- services logs api --lines 100\n+cargo run --example basic -- services status\n ```\n \n-## API Reference\n+See the [`examples/`](examples/) directory for more examples.\n \n-### Attribute Macros\n+## Comparison with clap\n \n-- **`#[noun(\"name\", \"description\")]`** - Register a noun command\n-- **`#[verb(\"name\")]`** - Register a verb command with auto-discovery\n+### Direct clap (verbose):\n \n-### Core Types\n-\n-- **`Result<T>`** - Error type used throughout the framework\n-- **All output types must implement `Serialize`** - For JSON output\n-\n-### Error Types\n-\n-The crate uses `thiserror` for comprehensive error handling:\n-\n-- **`NounVerbError::CommandNotFound`** - When a command is not found\n-- **`NounVerbError::ExecutionError`** - When command execution fails\n-- **`NounVerbError::ArgumentError`** - When argument parsing fails\n-\n-## Design Philosophy\n-\n-### Why Framework-Based?\n-\n-**clap-noun-verb** is designed as a **framework** that enables composition rather than providing specific compositions:\n-\n-1. **Composable by Design** - Users compose their own CLI patterns\n-2. **Multiple Composition Methods** - Choose the approach that fits your needs\n-3. **Extensible Architecture** - Easy to extend and customize for specific use cases\n-4. **Framework-Level APIs** - APIs that make it easy to build CLI frameworks\n-\n-### Why Noun-Verb Pattern?\n-\n-The noun-verb pattern provides several benefits:\n-\n-1. **Intuitive Structure** - Commands naturally group related functionality\n-2. **Scalable Organization** - Easy to add new verbs to existing nouns\n-3. **Consistent UX** - Users learn one pattern and can apply it everywhere\n-4. **Type Safety** - Compile-time verification of command structure\n-\n-### Why Trait-Based Architecture?\n-\n-- **Extensibility** - Easy to add new command types without modifying core\n-- **Type Safety** - Compile-time verification of command implementations\n-- **Testability** - Commands can be easily mocked and tested\n-- **Composability** - Commands can be combined and reused\n-\n-### Why Multiple Composition Methods?\n-\n-Different projects have different needs:\n-\n-- **Declarative** - For simple, static CLI structures\n-- **Builder** - For flexible, programmatic composition\n-- **Registry** - For dynamic, runtime composition\n-- **Tree** - For complex, hierarchical command structures\n-\n-## Framework vs Direct clap Usage\n-\n-### Direct clap (verbose enum-based):\n-\n ```rust\n use clap::{Parser, Subcommand};\n \n #[derive(Parser)]\n@@ -283,147 +113,69 @@\n #[derive(Subcommand)]\n enum ServiceCommands {\n     Status,\n     Logs { service: String },\n-    Restart { service: String },\n }\n \n fn main() {\n     let cli = Cli::parse();\n     match cli.command {\n         Commands::Services { command } => match command {\n             ServiceCommands::Status => println!(\"Services running\"),\n             ServiceCommands::Logs { service } => println!(\"Logs for {}\", service),\n-            ServiceCommands::Restart { service } => println!(\"Restarting {}\", service),\n         },\n     }\n }\n ```\n \n-### With clap-noun-verb Framework (attribute macros):\n+### With clap-noun-verb:\n \n ```rust\n-use clap_noun_verb_macros::{noun, verb};\n-use clap_noun_verb::Result;\n-use serde::Serialize;\n-\n-#[derive(Serialize)]\n-struct Status {\n-    services: Vec<String>,\n-    healthy: bool,\n-}\n-\n #[noun(\"services\", \"Manage services\")]\n #[verb(\"status\")]\n-fn show_status() -> Result<Status> {\n-    Ok(Status {\n-        services: vec![\"api\".to_string(), \"worker\".to_string()],\n-        healthy: true,\n-    })\n-}\n+fn show_status() -> Result<Status> { /* ... */ }\n \n #[verb(\"logs\", \"services\")]\n-fn show_logs(service: String) -> Result<String> {\n-    // Note: Second arg to #[verb] specifies the noun name\n-    Ok(format!(\"Logs for {}\", service))\n-}\n+fn show_logs(service: String) -> Result<Logs> { /* ... */ }\n \n fn main() -> Result<()> {\n     clap_noun_verb::run() // Auto-discovers all commands!\n }\n ```\n \n-The framework approach provides:\n-- **Zero boilerplate** - Just add attributes\n-- **Auto-discovery** - Commands automatically registered\n-- **Better organization** - Commands grouped by functionality\n-- **Type safety** - Compile-time verification\n-- **JSON output** - Perfect for agents/MCP\n+**Benefits:**\n+- ✅ Zero boilerplate - Just add attributes\n+- ✅ Auto-discovery - Commands automatically registered\n+- ✅ Better organization - Commands grouped by functionality\n+- ✅ JSON output - Perfect for agents/MCP\n \n-## CLI Patterns for Porting\n+## Design Philosophy\n \n-Here are common CLI patterns that could benefit from the noun-verb approach:\n+**clap-noun-verb** is a **framework** that enables composition rather than providing specific compositions:\n \n-### Example Patterns to Convert\n+- **Composable by Design** - Users compose their own CLI patterns\n+- **Type-Safe** - Compile-time verification of command structure\n+- **Zero-Cost** - Thin wrapper over clap with no runtime overhead\n+- **JSON-First** - Optimized for modern tooling and AI agents\n \n-**Services Management:**\n-```rust\n-// Current: services status|logs|restart|ai-manage\n-// Could be: services status, services logs, services restart, services ai-manage\n-```\n+## Migration from clap\n \n-**Collector Management:**\n-```rust\n-// Current: collector up|down|status|logs\n-// Could be: collector up, collector down, collector status, collector logs\n-```\n+1. Replace builder/enum-based commands with `#[noun]` and `#[verb]` attributes\n+2. Add `#[derive(Serialize)]` to output types\n+3. Return `Result<T>` where `T: Serialize` for JSON output\n+4. Call `clap_noun_verb::run()` in `main()`\n \n-**Report Generation:**\n-```rust\n-// Current: report --input --output --format\n-// Could be: report generate, report view, report export\n-```\n+## Documentation\n \n-**Template Operations:**\n-```rust\n-// Current: template <template_name> --output\n-// Could be: template generate, template list, template validate\n-```\n+- [Examples](examples/) - Working examples\n+- [Contributing](CONTRIBUTING.md) - Contribution guidelines\n+- [Changelog](CHANGELOG.md) - Version history\n \n-**AI Commands:**\n-```rust\n-// Current: ai-orchestrate, ai-predict, ai-optimize, ai-real, ai-monitor\n-// Could be: ai orchestrate, ai predict, ai optimize, ai real, ai monitor\n-```\n-\n-**Trace Operations:**\n-```rust\n-// Current: analyze, diff, graph, spans, repro\n-// Could be: trace analyze, trace diff, trace graph, trace spans, trace repro\n-```\n-\n-**Development Tools:**\n-```rust\n-// Current: dev, dry-run, fmt, lint\n-// Could be: dev test, dev lint, dev format, dev run\n-```\n-\n-This creates intuitive command structures like:\n-- `myapp services status`\n-- `myapp services logs <service>`\n-\n-## Migration Guide\n-\n-### From Direct clap or v1.x\n-\n-1. **Replace builder/enum-based commands** with attribute macros\n-2. **Add `#[derive(Serialize)]`** to output types\n-3. **Use `#[noun]` and `#[verb]`** attributes on functions\n-4. **Return `Result<T>`** where `T: Serialize` for JSON output\n-\n-```rust\n-// Old (v1.x or direct clap)\n-let cli = CliBuilder::new(\"myapp\")\n-    .noun(\"services\", \"Manage services\")\n-    .verb(\"services\", \"status\", \"Show status\", handler);\n-cli.run()\n-\n-// New (v3.0.0)\n-#[noun(\"services\", \"Manage services\")]\n-#[verb(\"status\")]\n-fn show_status() -> Result<Status> { ... }\n-fn main() -> Result<()> { clap_noun_verb::run() }\n-```\n-\n-## Contributing\n-\n-Contributions are welcome! Please see the [CONTRIBUTING.md](CONTRIBUTING.md) file for guidelines.\n-\n ## License\n \n-This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n+MIT OR Apache-2.0\n \n ## Acknowledgments\n \n-- Inspired by Python's [Typer](https://typer.tiangolo.com/) library\n-- Built on top of the excellent [clap](https://crates.io/crates/clap) crate\n-- Error handling powered by [thiserror](https://crates.io/crates/thiserror)\n+- Inspired by Python's [Typer](https://typer.tiangolo.com/)\n+- Built on [clap](https://crates.io/crates/clap)\n+- Error handling with [thiserror](https://crates.io/crates/thiserror)\n"
                }
            ],
            "date": 1762032999870,
            "name": "Commit-0",
            "content": "# clap-noun-verb\n\nA framework for building composable CLI patterns on top of clap. This crate provides the foundation for creating command-line interfaces with the `noun verb` pattern (e.g., `services status`, `collector up`), similar to how Python's Typer provides a simpler interface over Click.\n\n## Version 3.0.0 - Attribute Macros & Auto-Discovery\n\nThis crate has reached version 3.0.0 with revolutionary attribute macros:\n\n- **Attribute Macros**: `#[noun]` and `#[verb]` for zero-boilerplate command registration\n- **Auto-Discovery**: Commands automatically discovered at compile time using `linkme`\n- **Type Inference**: Arguments automatically inferred from function signatures\n- **JSON Output**: All output automatically serialized to JSON (perfect for agents/MCP)\n- **Production Ready**: Suitable for use in production applications\n\nFor details, see the [Quick Start](#quick-start) section.\n\n## Framework Philosophy\n\n**clap-noun-verb** is designed as a **framework** rather than a library of specific compositions. Instead of providing pre-built CLI patterns, it provides the tools and APIs that allow you to compose your own CLI patterns in flexible, extensible ways.\n\n### Key Framework Features\n\n- **Composable Command Structure**: Easy composition of nouns and verbs\n- **Framework-Level APIs**: APIs that make it easy to build CLI frameworks\n- **Extensible Traits**: Traits that can be easily extended and customized\n- **Hierarchical Command Support**: Support for complex nested command structures\n- **Type-Safe Composition**: Compile-time verification of command structure\n- **Multiple Composition Methods**: Choose the composition style that fits your needs\n\n## Features\n\n- **Trait-based command definition** - `NounCommand` and `VerbCommand` traits for type-safe command structure\n- **Builder pattern API** - Ergonomic command registration with method chaining\n- **Automatic help generation** - Enhanced help text for noun-verb patterns\n- **Type-safe command routing** - Compile-time verification of command structure\n- **Zero-cost abstractions** - Thin wrapper over clap with no runtime overhead\n- **Convenience macros** - Reduce boilerplate with `noun!` and `verb!` macros\n- **Argument extraction helpers** - Type-safe argument extraction from `VerbArgs` with helper methods\n- **Verb argument support** - Define arguments directly in verb macros\n- **Command structure validation** - Validate command structure for duplicate names and conflicts\n- **Global arguments access** - Verbs can access global arguments like `--verbose` and `--config` from parent commands\n- **PathBuf convenience methods** - Specialized helpers for `PathBuf` argument extraction\n- **Auto-validation option** - Optional automatic structure validation on build/run\n\n## Quick Start\n\nAdd this to your `Cargo.toml`:\n\n```toml\n[dependencies]\nclap-noun-verb = \"3.0.0\"\nclap-noun-verb-macros = \"3.0.0\"\n```\n\n## Architecture\n\nVersion 3.0.0 uses attribute macros for zero-boilerplate command registration:\n\n```\nFunction with #[verb] → Auto-registered → Auto-discovered → JSON output\n```\n\n### Key Principles\n\n1. **Zero Boilerplate** - Just add `#[noun]` and `#[verb]` attributes\n2. **Auto-Discovery** - Commands automatically discovered at compile time\n3. **Type Inference** - Arguments inferred from function signatures\n4. **JSON by Default** - Perfect for agents, MCP, and modern tooling\n\n## Quick Start\n\nThe recommended approach in v3.0.0 uses attribute macros for zero-boilerplate command registration:\n\n```rust\nuse clap_noun_verb_macros::{noun, verb};\nuse clap_noun_verb::Result;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct Status {\n    services: Vec<String>,\n    healthy: bool,\n}\n\n/// Show service status\n#[noun(\"services\", \"Manage services\")]\n#[verb(\"status\")]\nfn show_status() -> Result<Status> {\n    Ok(Status {\n        services: vec![\"api\".to_string(), \"worker\".to_string()],\n        healthy: true,\n    })\n}\n\nfn main() -> Result<()> {\n    clap_noun_verb::run() // Auto-discovers all commands!\n}\n```\n\n**Usage:**\n```bash\n$ myapp services status\n{\"services\":[\"api\",\"worker\"],\"healthy\":true}\n```\n\n**Key Benefits:**\n- ✅ **Zero boilerplate** - Just add attributes\n- ✅ **Auto-discovery** - Commands discovered at compile time\n- ✅ **Type inference** - Arguments inferred from function signature\n- ✅ **JSON by default** - Perfect for agents/MCP\n\n## Framework Usage\n\nThe framework provides a simple, opinionated API for 80% of use cases using attribute macros:\n\n```rust\nuse clap_noun_verb_macros::{noun, verb};\nuse clap_noun_verb::Result;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct Status {\n    services: Vec<String>,\n    healthy: bool,\n}\n\n/// Show service status\n#[noun(\"services\", \"Manage services\")]\n#[verb(\"status\")]\nfn show_status() -> Result<Status> {\n    Ok(Status {\n        services: vec![\"api\".to_string(), \"worker\".to_string()],\n        healthy: true,\n    })\n}\n\n/// Show logs for a service\n#[verb(\"logs\")]\nfn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n    // service: String → Required argument --service\n    // lines: Option<usize> → Optional argument --lines\n    Ok(Logs {\n        service,\n        lines: lines.unwrap_or(50),\n        entries: vec![],\n    })\n}\n\n#[derive(Serialize)]\nstruct Logs {\n    service: String,\n    lines: usize,\n    entries: Vec<String>,\n}\n\nfn main() -> Result<()> {\n    clap_noun_verb::run() // Auto-discovers all commands!\n}\n```\n\n**That's it!** Just add `#[noun]` and `#[verb]` attributes to your functions.\n\n### Arguments with Type Inference\n\nArguments are automatically inferred from function signatures:\n\n```rust\n/// Show logs for a service\n/// \n/// # Arguments\n/// * `service` - Service name (required)\n/// * `lines` - Number of lines to show (default: 50)\n#[verb(\"logs\")]\nfn show_logs(service: String, lines: Option<usize>) -> Result<Logs> {\n    // service: String → Required argument --service\n    // lines: Option<usize> → Optional argument --lines\n    Ok(Logs {\n        service,\n        lines: lines.unwrap_or(50),\n        entries: vec![],\n    })\n}\n```\n\n**Type inference rules:**\n- `String` → Required argument `--name`\n- `Option<T>` → Optional argument `--name <value>`\n- `bool` → Flag `--name` (true if present)\n- `Vec<T>` → Multiple values `--name <value1> <value2> ...`\n\n## Examples\n\nRun the attribute macro example:\n\n```bash\ncargo run --example attribute_macro -- services status\ncargo run --example attribute_macro -- services logs api --lines 100\n```\n\n## API Reference\n\n### Attribute Macros\n\n- **`#[noun(\"name\", \"description\")]`** - Register a noun command\n- **`#[verb(\"name\")]`** - Register a verb command with auto-discovery\n\n### Core Types\n\n- **`Result<T>`** - Error type used throughout the framework\n- **All output types must implement `Serialize`** - For JSON output\n\n### Error Types\n\nThe crate uses `thiserror` for comprehensive error handling:\n\n- **`NounVerbError::CommandNotFound`** - When a command is not found\n- **`NounVerbError::ExecutionError`** - When command execution fails\n- **`NounVerbError::ArgumentError`** - When argument parsing fails\n\n## Design Philosophy\n\n### Why Framework-Based?\n\n**clap-noun-verb** is designed as a **framework** that enables composition rather than providing specific compositions:\n\n1. **Composable by Design** - Users compose their own CLI patterns\n2. **Multiple Composition Methods** - Choose the approach that fits your needs\n3. **Extensible Architecture** - Easy to extend and customize for specific use cases\n4. **Framework-Level APIs** - APIs that make it easy to build CLI frameworks\n\n### Why Noun-Verb Pattern?\n\nThe noun-verb pattern provides several benefits:\n\n1. **Intuitive Structure** - Commands naturally group related functionality\n2. **Scalable Organization** - Easy to add new verbs to existing nouns\n3. **Consistent UX** - Users learn one pattern and can apply it everywhere\n4. **Type Safety** - Compile-time verification of command structure\n\n### Why Trait-Based Architecture?\n\n- **Extensibility** - Easy to add new command types without modifying core\n- **Type Safety** - Compile-time verification of command implementations\n- **Testability** - Commands can be easily mocked and tested\n- **Composability** - Commands can be combined and reused\n\n### Why Multiple Composition Methods?\n\nDifferent projects have different needs:\n\n- **Declarative** - For simple, static CLI structures\n- **Builder** - For flexible, programmatic composition\n- **Registry** - For dynamic, runtime composition\n- **Tree** - For complex, hierarchical command structures\n\n## Framework vs Direct clap Usage\n\n### Direct clap (verbose enum-based):\n\n```rust\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    Services {\n        #[command(subcommand)]\n        command: ServiceCommands,\n    },\n}\n\n#[derive(Subcommand)]\nenum ServiceCommands {\n    Status,\n    Logs { service: String },\n    Restart { service: String },\n}\n\nfn main() {\n    let cli = Cli::parse();\n    match cli.command {\n        Commands::Services { command } => match command {\n            ServiceCommands::Status => println!(\"Services running\"),\n            ServiceCommands::Logs { service } => println!(\"Logs for {}\", service),\n            ServiceCommands::Restart { service } => println!(\"Restarting {}\", service),\n        },\n    }\n}\n```\n\n### With clap-noun-verb Framework (attribute macros):\n\n```rust\nuse clap_noun_verb_macros::{noun, verb};\nuse clap_noun_verb::Result;\nuse serde::Serialize;\n\n#[derive(Serialize)]\nstruct Status {\n    services: Vec<String>,\n    healthy: bool,\n}\n\n#[noun(\"services\", \"Manage services\")]\n#[verb(\"status\")]\nfn show_status() -> Result<Status> {\n    Ok(Status {\n        services: vec![\"api\".to_string(), \"worker\".to_string()],\n        healthy: true,\n    })\n}\n\n#[verb(\"logs\")]\nfn show_logs(service: String) -> Result<String> {\n    Ok(format!(\"Logs for {}\", service))\n}\n\nfn main() -> Result<()> {\n    clap_noun_verb::run() // Auto-discovers all commands!\n}\n```\n\nThe framework approach provides:\n- **Zero boilerplate** - Just add attributes\n- **Auto-discovery** - Commands automatically registered\n- **Better organization** - Commands grouped by functionality\n- **Type safety** - Compile-time verification\n- **JSON output** - Perfect for agents/MCP\n\n## CLI Patterns for Porting\n\nHere are common CLI patterns that could benefit from the noun-verb approach:\n\n### Example Patterns to Convert\n\n**Services Management:**\n```rust\n// Current: services status|logs|restart|ai-manage\n// Could be: services status, services logs, services restart, services ai-manage\n```\n\n**Collector Management:**\n```rust\n// Current: collector up|down|status|logs\n// Could be: collector up, collector down, collector status, collector logs\n```\n\n**Report Generation:**\n```rust\n// Current: report --input --output --format\n// Could be: report generate, report view, report export\n```\n\n**Template Operations:**\n```rust\n// Current: template <template_name> --output\n// Could be: template generate, template list, template validate\n```\n\n**AI Commands:**\n```rust\n// Current: ai-orchestrate, ai-predict, ai-optimize, ai-real, ai-monitor\n// Could be: ai orchestrate, ai predict, ai optimize, ai real, ai monitor\n```\n\n**Trace Operations:**\n```rust\n// Current: analyze, diff, graph, spans, repro\n// Could be: trace analyze, trace diff, trace graph, trace spans, trace repro\n```\n\n**Development Tools:**\n```rust\n// Current: dev, dry-run, fmt, lint\n// Could be: dev test, dev lint, dev format, dev run\n```\n\nThis creates intuitive command structures like:\n- `myapp services status`\n- `myapp services logs <service>`\n\n## Migration Guide\n\n### From Direct clap or v1.x\n\n1. **Replace builder/enum-based commands** with attribute macros\n2. **Add `#[derive(Serialize)]`** to output types\n3. **Use `#[noun]` and `#[verb]`** attributes on functions\n4. **Return `Result<T>`** where `T: Serialize` for JSON output\n\n```rust\n// Old (v1.x or direct clap)\nlet cli = CliBuilder::new(\"myapp\")\n    .noun(\"services\", \"Manage services\")\n    .verb(\"services\", \"status\", \"Show status\", handler);\ncli.run()\n\n// New (v3.0.0)\n#[noun(\"services\", \"Manage services\")]\n#[verb(\"status\")]\nfn show_status() -> Result<Status> { ... }\nfn main() -> Result<()> { clap_noun_verb::run() }\n```\n\n## Contributing\n\nContributions are welcome! Please see the [CONTRIBUTING.md](CONTRIBUTING.md) file for guidelines.\n\n## License\n\nThis project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.\n\n## Acknowledgments\n\n- Inspired by Python's [Typer](https://typer.tiangolo.com/) library\n- Built on top of the excellent [clap](https://crates.io/crates/clap) crate\n- Error handling powered by [thiserror](https://crates.io/crates/thiserror)\n"
        }
    ]
}