{
    "sourceFile": "clap-noun-verb-macros/src/lib.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1762031171856,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762032949702,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,17 +49,16 @@\n             .to_compile_error().into(),\n     };\n \n     let fn_name = &input_fn.sig.ident;\n-    let init_fn_name = quote::format_ident!(\"__init_{}\", fn_name);\n+    let init_fn_name = quote::format_ident!(\"__init_noun_{}\", fn_name);\n \n     // Generate registration code\n     let expanded = quote! {\n         #input_fn\n \n         // Auto-generated registration\n-        #[::linkme::distributed_slice(::clap_noun_verb::cli::registry::__NOUN_REGISTRY)]\n-        #[linkme(crate = ::clap_noun_verb::cli::registry)]\n+        #[linkme::distributed_slice(::clap_noun_verb::cli::registry::__NOUN_REGISTRY)]\n         static #init_fn_name: fn() = || {\n             ::clap_noun_verb::cli::registry::CommandRegistry::register_noun(\n                 #name_str,\n                 #about_str,\n@@ -134,23 +133,34 @@\n     }\n }\n \n /// Extract docstring from function attributes\n+///\n+/// Doc comments in syn are stored as Meta::List with \"doc\" as the path.\n+/// Each doc comment line is a separate attribute.\n fn extract_docstring(input_fn: &ItemFn) -> String {\n     input_fn.attrs.iter()\n         .filter_map(|attr| {\n             if attr.path().is_ident(\"doc\") {\n-                // Doc comments in syn are stored as Meta::NameValue with a string literal\n-                // For now, we'll extract from the token stream\n+                // Doc comments in syn 2.0 are stored as Meta::NameValue\n+                // Format: #[doc = \"text\"]\n                 let meta = &attr.meta;\n-                if let syn::Meta::NameValue(nv) = meta {\n-                    if let syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) = &nv.value {\n-                        Some(s.value().trim().to_string())\n-                    } else {\n-                        None\n+                match meta {\n+                    syn::Meta::NameValue(nv) => {\n+                        if let syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) = &nv.value {\n+                            Some(s.value().trim().to_string())\n+                        } else {\n+                            None\n+                        }\n                     }\n-                } else {\n-                    None\n+                    // Some doc comments might be in List format\n+                    syn::Meta::List(list) => {\n+                        // Extract tokens from list\n+                        let tokens = list.tokens.to_string();\n+                        // Remove quotes and extra formatting\n+                        tokens.trim_matches('\"').trim().to_string().into()\n+                    }\n+                    _ => None,\n                 }\n             } else {\n                 None\n             }\n@@ -251,15 +261,14 @@\n \n         // Wrapper function that adapts HandlerInput to function signature\n         fn #wrapper_name(input: ::clap_noun_verb::logic::HandlerInput) -> ::clap_noun_verb::error::Result<::clap_noun_verb::logic::HandlerOutput> {\n             #(#arg_extractions)*\n-            let result = #fn_name(#(#arg_calls),*);\n+            let result = #fn_name(#(#arg_calls),*)?;\n             ::clap_noun_verb::logic::HandlerOutput::from_data(result)\n         }\n \n         // Auto-generated registration\n-        #[::linkme::distributed_slice(::clap_noun_verb::cli::registry::__VERB_REGISTRY)]\n-        #[linkme(crate = ::clap_noun_verb::cli::registry)]\n+        #[linkme::distributed_slice(::clap_noun_verb::cli::registry::__VERB_REGISTRY)]\n         static #init_fn_name: fn() = || {\n             let noun_name = #noun_name_str;\n             if noun_name != \"__auto__\" {\n                 let args = vec![#(#arg_metadata),*];\n"
                },
                {
                    "date": 1762033026796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,9 +156,9 @@\n                     syn::Meta::List(list) => {\n                         // Extract tokens from list\n                         let tokens = list.tokens.to_string();\n                         // Remove quotes and extra formatting\n-                        tokens.trim_matches('\"').trim().to_string().into()\n+                        Some(tokens.trim_matches('\"').trim().to_string())\n                     }\n                     _ => None,\n                 }\n             } else {\n"
                },
                {
                    "date": 1762033499597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,329 @@\n+//! Procedural macros for clap-noun-verb\n+//!\n+//! This crate provides attribute macros `#[noun]` and `#[verb]` for\n+//! declarative CLI command registration.\n+\n+use proc_macro::TokenStream;\n+use quote::quote;\n+use syn::{parse_macro_input, ItemFn, parse::Parser};\n+\n+/// Attribute macro for registering a noun command\n+///\n+/// Usage:\n+/// ```rust,ignore\n+/// #[noun(\"services\", \"Manage services\")]\n+/// fn my_function() {}\n+/// ```\n+#[proc_macro_attribute]\n+pub fn noun(args: TokenStream, input: TokenStream) -> TokenStream {\n+    let input_fn = parse_macro_input!(input as ItemFn);\n+\n+    // Parse arguments: name and about\n+    let parser = syn::punctuated::Punctuated::<syn::Expr, syn::Token![,]>::parse_terminated;\n+    let args_vec: syn::punctuated::Punctuated<_, _> = match Parser::parse2(parser, proc_macro2::TokenStream::from(args)) {\n+        Ok(args) => args,\n+        Err(e) => return e.to_compile_error().into(),\n+    };\n+\n+    if args_vec.len() != 2 {\n+        return syn::Error::new_spanned(\n+            quote! { #args_vec },\n+            \"Expected exactly 2 arguments: name and about\"\n+        )\n+        .to_compile_error()\n+        .into();\n+    }\n+\n+    let name_expr = &args_vec[0];\n+    let about_expr = &args_vec[1];\n+\n+    let name_str = match name_expr {\n+        syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n+        _ => return syn::Error::new_spanned(name_expr, \"First argument must be a string literal\")\n+            .to_compile_error().into(),\n+    };\n+\n+    let about_str = match about_expr {\n+        syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n+        _ => return syn::Error::new_spanned(about_expr, \"Second argument must be a string literal\")\n+            .to_compile_error().into(),\n+    };\n+\n+    let fn_name = &input_fn.sig.ident;\n+    let init_fn_name = quote::format_ident!(\"__init_noun_{}\", fn_name);\n+\n+    // Generate registration code\n+    let expanded = quote! {\n+        #input_fn\n+\n+        // Auto-generated registration\n+        #[linkme::distributed_slice(::clap_noun_verb::cli::registry::__NOUN_REGISTRY)]\n+        static #init_fn_name: fn() = || {\n+            ::clap_noun_verb::cli::registry::CommandRegistry::register_noun(\n+                #name_str,\n+                #about_str,\n+            );\n+        };\n+    };\n+\n+    expanded.into()\n+}\n+\n+/// Attribute macro for registering a verb command\n+///\n+/// Usage:\n+/// ```rust,ignore\n+/// #[verb(\"status\")]\n+/// fn show_status() -> Result<Status> {}\n+/// ```\n+#[proc_macro_attribute]\n+pub fn verb(args: TokenStream, input: TokenStream) -> TokenStream {\n+    let input_fn = parse_macro_input!(input as ItemFn);\n+\n+    // Parse verb name from args\n+    let parser = syn::punctuated::Punctuated::<syn::Expr, syn::Token![,]>::parse_terminated;\n+    let args_vec: syn::punctuated::Punctuated<_, _> = match Parser::parse2(parser, proc_macro2::TokenStream::from(args)) {\n+        Ok(args) => args,\n+        Err(_) => {\n+            // If parsing fails, extract verb name from function name\n+            let verb_name = extract_verb_name_from_fn_name(&input_fn);\n+            return generate_verb_registration(input_fn, verb_name, None, None);\n+        }\n+    };\n+\n+    let verb_name = if args_vec.is_empty() {\n+        extract_verb_name_from_fn_name(&input_fn)\n+    } else {\n+        match &args_vec[0] {\n+            syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n+            _ => return syn::Error::new_spanned(&args_vec[0], \"First argument must be a string literal\")\n+                .to_compile_error().into(),\n+        }\n+    };\n+\n+    // Extract noun name if provided as second arg\n+    let noun_name = if args_vec.len() > 1 {\n+        match &args_vec[1] {\n+            syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => Some(s.value()),\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    };\n+\n+    // Extract docstring for help text\n+    let docstring = extract_docstring(&input_fn);\n+\n+    generate_verb_registration(input_fn, verb_name, noun_name, Some(docstring))\n+}\n+\n+/// Extract verb name from function name (remove \"show_\", \"get_\", etc.)\n+fn extract_verb_name_from_fn_name(input_fn: &ItemFn) -> String {\n+    let fn_name = input_fn.sig.ident.to_string();\n+\n+    // Remove common prefixes\n+    if let Some(stripped) = fn_name.strip_prefix(\"show_\") {\n+        stripped.to_string()\n+    } else if let Some(stripped) = fn_name.strip_prefix(\"get_\") {\n+        stripped.to_string()\n+    } else if let Some(stripped) = fn_name.strip_prefix(\"list_\") {\n+        stripped.to_string()\n+    } else {\n+        fn_name\n+    }\n+}\n+\n+/// Extract docstring from function attributes\n+///\n+/// Doc comments in syn are stored as Meta::List with \"doc\" as the path.\n+/// Each doc comment line is a separate attribute.\n+fn extract_docstring(input_fn: &ItemFn) -> String {\n+    input_fn.attrs.iter()\n+        .filter_map(|attr| {\n+            if attr.path().is_ident(\"doc\") {\n+                // Doc comments in syn 2.0 are stored as Meta::NameValue\n+                // Format: #[doc = \"text\"]\n+                let meta = &attr.meta;\n+                match meta {\n+                    syn::Meta::NameValue(nv) => {\n+                        if let syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) = &nv.value {\n+                            Some(s.value().trim().to_string())\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    // Some doc comments might be in List format\n+                    syn::Meta::List(list) => {\n+                        // Extract tokens from list\n+                        let tokens = list.tokens.to_string();\n+                        // Remove quotes and extra formatting\n+                        Some(tokens.trim_matches('\"').trim().to_string())\n+                    }\n+                    _ => None,\n+                }\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<Vec<_>>()\n+        .join(\" \")\n+        .trim()\n+        .to_string()\n+}\n+\n+/// Generate verb registration code with full type inference\n+fn generate_verb_registration(\n+    input_fn: ItemFn,\n+    verb_name: String,\n+    noun_name: Option<String>,\n+    about: Option<String>,\n+) -> TokenStream {\n+    let fn_name = &input_fn.sig.ident;\n+    let wrapper_name = quote::format_ident!(\"__{}_wrapper\", fn_name);\n+    let init_fn_name = quote::format_ident!(\"__init_{}\", fn_name);\n+\n+    // Analyze function signature for arguments\n+    let mut arg_extractions = Vec::new();\n+    let mut arg_calls = Vec::new();\n+\n+    for input in &input_fn.sig.inputs {\n+        if let syn::FnArg::Typed(pat_type) = input {\n+            let arg_name = match &*pat_type.pat {\n+                syn::Pat::Ident(ident) => &ident.ident,\n+                _ => continue,\n+            };\n+\n+            let arg_name_str = arg_name.to_string();\n+\n+            // Determine if optional (Option<T>) or required\n+            let is_option = is_option_type(&pat_type.ty);\n+            let inner_type = extract_inner_type(&pat_type.ty);\n+            let is_flag = is_bool_type(&pat_type.ty);\n+\n+            if is_flag {\n+                // Boolean flags\n+                arg_extractions.push(quote! {\n+                    let #arg_name = input.opts.get(#arg_name_str)\n+                        .map(|v| v.parse::<bool>().unwrap_or(false))\n+                        .unwrap_or(false);\n+                });\n+                arg_calls.push(quote! { #arg_name });\n+            } else if is_option {\n+                // Optional arguments\n+                arg_extractions.push(quote! {\n+                    let #arg_name = input.args.get(#arg_name_str)\n+                        .and_then(|v| v.parse::<#inner_type>().ok());\n+                });\n+                arg_calls.push(quote! { #arg_name });\n+            } else {\n+                // Required arguments\n+                arg_extractions.push(quote! {\n+                    let #arg_name = input.args.get(#arg_name_str)\n+                        .ok_or_else(|| ::clap_noun_verb::error::NounVerbError::missing_argument(#arg_name_str))?\n+                        .parse::<#inner_type>()\n+                        .map_err(|_| ::clap_noun_verb::error::NounVerbError::argument_error(\n+                            format!(\"Invalid value for argument '{}'\", #arg_name_str)\n+                        ))?;\n+                });\n+                arg_calls.push(quote! { #arg_name });\n+            }\n+        }\n+    }\n+\n+    // Generate argument metadata for registration\n+    let mut arg_metadata = Vec::new();\n+    for input in &input_fn.sig.inputs {\n+        if let syn::FnArg::Typed(pat_type) = input {\n+            let arg_name = match &*pat_type.pat {\n+                syn::Pat::Ident(ident) => ident.ident.to_string(),\n+                _ => continue,\n+            };\n+\n+            let is_option = is_option_type(&pat_type.ty);\n+            let is_flag = is_bool_type(&pat_type.ty);\n+\n+            arg_metadata.push(quote! {\n+                ::clap_noun_verb::cli::registry::ArgMetadata {\n+                    name: #arg_name.to_string(),\n+                    required: !#is_option,\n+                    is_flag: #is_flag,\n+                }\n+            });\n+        }\n+    }\n+\n+    // Generate wrapper function\n+    let noun_name_str = noun_name.as_ref().map(|s| s.as_str()).unwrap_or(\"__auto__\");\n+    let about_str = about.as_ref().map(|s| s.as_str()).unwrap_or(\"\");\n+\n+    let expanded = quote! {\n+        #input_fn\n+\n+        // Wrapper function that adapts HandlerInput to function signature\n+        fn #wrapper_name(input: ::clap_noun_verb::logic::HandlerInput) -> ::clap_noun_verb::error::Result<::clap_noun_verb::logic::HandlerOutput> {\n+            #(#arg_extractions)*\n+            let result = #fn_name(#(#arg_calls),*)?;\n+            ::clap_noun_verb::logic::HandlerOutput::from_data(result)\n+        }\n+\n+        // Auto-generated registration\n+        #[linkme::distributed_slice(::clap_noun_verb::cli::registry::__VERB_REGISTRY)]\n+        static #init_fn_name: fn() = || {\n+            let noun_name = #noun_name_str;\n+            if noun_name != \"__auto__\" {\n+                let args = vec![#(#arg_metadata),*];\n+                ::clap_noun_verb::cli::registry::CommandRegistry::register_verb_with_args::<_>(\n+                    noun_name,\n+                    #verb_name,\n+                    #about_str,\n+                    args,\n+                    #wrapper_name,\n+                );\n+            }\n+        };\n+    };\n+\n+    expanded.into()\n+}\n+\n+/// Check if type is Option<T>\n+fn is_option_type(ty: &syn::Type) -> bool {\n+    if let syn::Type::Path(type_path) = ty {\n+        if let Some(segment) = type_path.path.segments.last() {\n+            segment.ident == \"Option\"\n+        } else {\n+            false\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Check if type is bool\n+fn is_bool_type(ty: &syn::Type) -> bool {\n+    if let syn::Type::Path(type_path) = ty {\n+        if let Some(segment) = type_path.path.segments.last() {\n+            segment.ident == \"bool\"\n+        } else {\n+            false\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Extract inner type from Option<T> or return original\n+fn extract_inner_type(ty: &syn::Type) -> syn::Type {\n+    if let syn::Type::Path(type_path) = ty {\n+        if let Some(segment) = type_path.path.segments.last() {\n+            if segment.ident == \"Option\" {\n+                if let syn::PathArguments::AngleBracketed(args) = &segment.arguments {\n+                    if let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first() {\n+                        return inner_ty.clone();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    ty.clone()\n+}\n"
                },
                {
                    "date": 1762033515327,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -326,333 +326,4 @@\n         }\n     }\n     ty.clone()\n }\n-//! Procedural macros for clap-noun-verb\n-//!\n-//! This crate provides attribute macros `#[noun]` and `#[verb]` for\n-//! declarative CLI command registration.\n-\n-use proc_macro::TokenStream;\n-use quote::quote;\n-use syn::{parse_macro_input, ItemFn, parse::Parser};\n-\n-/// Attribute macro for registering a noun command\n-///\n-/// Usage:\n-/// ```rust,ignore\n-/// #[noun(\"services\", \"Manage services\")]\n-/// fn my_function() {}\n-/// ```\n-#[proc_macro_attribute]\n-pub fn noun(args: TokenStream, input: TokenStream) -> TokenStream {\n-    let input_fn = parse_macro_input!(input as ItemFn);\n-\n-    // Parse arguments: name and about\n-    let parser = syn::punctuated::Punctuated::<syn::Expr, syn::Token![,]>::parse_terminated;\n-    let args_vec: syn::punctuated::Punctuated<_, _> = match Parser::parse2(parser, proc_macro2::TokenStream::from(args)) {\n-        Ok(args) => args,\n-        Err(e) => return e.to_compile_error().into(),\n-    };\n-\n-    if args_vec.len() != 2 {\n-        return syn::Error::new_spanned(\n-            quote! { #args_vec },\n-            \"Expected exactly 2 arguments: name and about\"\n-        )\n-        .to_compile_error()\n-        .into();\n-    }\n-\n-    let name_expr = &args_vec[0];\n-    let about_expr = &args_vec[1];\n-\n-    let name_str = match name_expr {\n-        syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n-        _ => return syn::Error::new_spanned(name_expr, \"First argument must be a string literal\")\n-            .to_compile_error().into(),\n-    };\n-\n-    let about_str = match about_expr {\n-        syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n-        _ => return syn::Error::new_spanned(about_expr, \"Second argument must be a string literal\")\n-            .to_compile_error().into(),\n-    };\n-\n-    let fn_name = &input_fn.sig.ident;\n-    let init_fn_name = quote::format_ident!(\"__init_noun_{}\", fn_name);\n-\n-    // Generate registration code\n-    let expanded = quote! {\n-        #input_fn\n-\n-        // Auto-generated registration\n-        #[linkme::distributed_slice(::clap_noun_verb::cli::registry::__NOUN_REGISTRY)]\n-        static #init_fn_name: fn() = || {\n-            ::clap_noun_verb::cli::registry::CommandRegistry::register_noun(\n-                #name_str,\n-                #about_str,\n-            );\n-        };\n-    };\n-\n-    expanded.into()\n-}\n-\n-/// Attribute macro for registering a verb command\n-///\n-/// Usage:\n-/// ```rust,ignore\n-/// #[verb(\"status\")]\n-/// fn show_status() -> Result<Status> {}\n-/// ```\n-#[proc_macro_attribute]\n-pub fn verb(args: TokenStream, input: TokenStream) -> TokenStream {\n-    let input_fn = parse_macro_input!(input as ItemFn);\n-\n-    // Parse verb name from args\n-    let parser = syn::punctuated::Punctuated::<syn::Expr, syn::Token![,]>::parse_terminated;\n-    let args_vec: syn::punctuated::Punctuated<_, _> = match Parser::parse2(parser, proc_macro2::TokenStream::from(args)) {\n-        Ok(args) => args,\n-        Err(_) => {\n-            // If parsing fails, extract verb name from function name\n-            let verb_name = extract_verb_name_from_fn_name(&input_fn);\n-            return generate_verb_registration(input_fn, verb_name, None, None);\n-        }\n-    };\n-\n-    let verb_name = if args_vec.is_empty() {\n-        extract_verb_name_from_fn_name(&input_fn)\n-    } else {\n-        match &args_vec[0] {\n-            syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n-            _ => return syn::Error::new_spanned(&args_vec[0], \"First argument must be a string literal\")\n-                .to_compile_error().into(),\n-        }\n-    };\n-\n-    // Extract noun name if provided as second arg\n-    let noun_name = if args_vec.len() > 1 {\n-        match &args_vec[1] {\n-            syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => Some(s.value()),\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    };\n-\n-    // Extract docstring for help text\n-    let docstring = extract_docstring(&input_fn);\n-\n-    generate_verb_registration(input_fn, verb_name, noun_name, Some(docstring))\n-}\n-\n-/// Extract verb name from function name (remove \"show_\", \"get_\", etc.)\n-fn extract_verb_name_from_fn_name(input_fn: &ItemFn) -> String {\n-    let fn_name = input_fn.sig.ident.to_string();\n-\n-    // Remove common prefixes\n-    if let Some(stripped) = fn_name.strip_prefix(\"show_\") {\n-        stripped.to_string()\n-    } else if let Some(stripped) = fn_name.strip_prefix(\"get_\") {\n-        stripped.to_string()\n-    } else if let Some(stripped) = fn_name.strip_prefix(\"list_\") {\n-        stripped.to_string()\n-    } else {\n-        fn_name\n-    }\n-}\n-\n-/// Extract docstring from function attributes\n-///\n-/// Doc comments in syn are stored as Meta::List with \"doc\" as the path.\n-/// Each doc comment line is a separate attribute.\n-fn extract_docstring(input_fn: &ItemFn) -> String {\n-    input_fn.attrs.iter()\n-        .filter_map(|attr| {\n-            if attr.path().is_ident(\"doc\") {\n-                // Doc comments in syn 2.0 are stored as Meta::NameValue\n-                // Format: #[doc = \"text\"]\n-                let meta = &attr.meta;\n-                match meta {\n-                    syn::Meta::NameValue(nv) => {\n-                        if let syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) = &nv.value {\n-                            Some(s.value().trim().to_string())\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                    // Some doc comments might be in List format\n-                    syn::Meta::List(list) => {\n-                        // Extract tokens from list\n-                        let tokens = list.tokens.to_string();\n-                        // Remove quotes and extra formatting\n-                        Some(tokens.trim_matches('\"').trim().to_string())\n-                    }\n-                    _ => None,\n-                }\n-            } else {\n-                None\n-            }\n-        })\n-        .collect::<Vec<_>>()\n-        .join(\" \")\n-        .trim()\n-        .to_string()\n-}\n-\n-/// Generate verb registration code with full type inference\n-fn generate_verb_registration(\n-    input_fn: ItemFn,\n-    verb_name: String,\n-    noun_name: Option<String>,\n-    about: Option<String>,\n-) -> TokenStream {\n-    let fn_name = &input_fn.sig.ident;\n-    let wrapper_name = quote::format_ident!(\"__{}_wrapper\", fn_name);\n-    let init_fn_name = quote::format_ident!(\"__init_{}\", fn_name);\n-\n-    // Analyze function signature for arguments\n-    let mut arg_extractions = Vec::new();\n-    let mut arg_calls = Vec::new();\n-\n-    for input in &input_fn.sig.inputs {\n-        if let syn::FnArg::Typed(pat_type) = input {\n-            let arg_name = match &*pat_type.pat {\n-                syn::Pat::Ident(ident) => &ident.ident,\n-                _ => continue,\n-            };\n-\n-            let arg_name_str = arg_name.to_string();\n-\n-            // Determine if optional (Option<T>) or required\n-            let is_option = is_option_type(&pat_type.ty);\n-            let inner_type = extract_inner_type(&pat_type.ty);\n-            let is_flag = is_bool_type(&pat_type.ty);\n-\n-            if is_flag {\n-                // Boolean flags\n-                arg_extractions.push(quote! {\n-                    let #arg_name = input.opts.get(#arg_name_str)\n-                        .map(|v| v.parse::<bool>().unwrap_or(false))\n-                        .unwrap_or(false);\n-                });\n-                arg_calls.push(quote! { #arg_name });\n-            } else if is_option {\n-                // Optional arguments\n-                arg_extractions.push(quote! {\n-                    let #arg_name = input.args.get(#arg_name_str)\n-                        .and_then(|v| v.parse::<#inner_type>().ok());\n-                });\n-                arg_calls.push(quote! { #arg_name });\n-            } else {\n-                // Required arguments\n-                arg_extractions.push(quote! {\n-                    let #arg_name = input.args.get(#arg_name_str)\n-                        .ok_or_else(|| ::clap_noun_verb::error::NounVerbError::missing_argument(#arg_name_str))?\n-                        .parse::<#inner_type>()\n-                        .map_err(|_| ::clap_noun_verb::error::NounVerbError::argument_error(\n-                            format!(\"Invalid value for argument '{}'\", #arg_name_str)\n-                        ))?;\n-                });\n-                arg_calls.push(quote! { #arg_name });\n-            }\n-        }\n-    }\n-\n-    // Generate argument metadata for registration\n-    let mut arg_metadata = Vec::new();\n-    for input in &input_fn.sig.inputs {\n-        if let syn::FnArg::Typed(pat_type) = input {\n-            let arg_name = match &*pat_type.pat {\n-                syn::Pat::Ident(ident) => ident.ident.to_string(),\n-                _ => continue,\n-            };\n-\n-            let is_option = is_option_type(&pat_type.ty);\n-            let is_flag = is_bool_type(&pat_type.ty);\n-\n-            arg_metadata.push(quote! {\n-                ::clap_noun_verb::cli::registry::ArgMetadata {\n-                    name: #arg_name.to_string(),\n-                    required: !#is_option,\n-                    is_flag: #is_flag,\n-                }\n-            });\n-        }\n-    }\n-\n-    // Generate wrapper function\n-    let noun_name_str = noun_name.as_ref().map(|s| s.as_str()).unwrap_or(\"__auto__\");\n-    let about_str = about.as_ref().map(|s| s.as_str()).unwrap_or(\"\");\n-\n-    let expanded = quote! {\n-        #input_fn\n-\n-        // Wrapper function that adapts HandlerInput to function signature\n-        fn #wrapper_name(input: ::clap_noun_verb::logic::HandlerInput) -> ::clap_noun_verb::error::Result<::clap_noun_verb::logic::HandlerOutput> {\n-            #(#arg_extractions)*\n-            let result = #fn_name(#(#arg_calls),*)?;\n-            ::clap_noun_verb::logic::HandlerOutput::from_data(result)\n-        }\n-\n-        // Auto-generated registration\n-        #[linkme::distributed_slice(::clap_noun_verb::cli::registry::__VERB_REGISTRY)]\n-        static #init_fn_name: fn() = || {\n-            let noun_name = #noun_name_str;\n-            if noun_name != \"__auto__\" {\n-                let args = vec![#(#arg_metadata),*];\n-                ::clap_noun_verb::cli::registry::CommandRegistry::register_verb_with_args::<_>(\n-                    noun_name,\n-                    #verb_name,\n-                    #about_str,\n-                    args,\n-                    #wrapper_name,\n-                );\n-            }\n-        };\n-    };\n-\n-    expanded.into()\n-}\n-\n-/// Check if type is Option<T>\n-fn is_option_type(ty: &syn::Type) -> bool {\n-    if let syn::Type::Path(type_path) = ty {\n-        if let Some(segment) = type_path.path.segments.last() {\n-            segment.ident == \"Option\"\n-        } else {\n-            false\n-        }\n-    } else {\n-        false\n-    }\n-}\n-\n-/// Check if type is bool\n-fn is_bool_type(ty: &syn::Type) -> bool {\n-    if let syn::Type::Path(type_path) = ty {\n-        if let Some(segment) = type_path.path.segments.last() {\n-            segment.ident == \"bool\"\n-        } else {\n-            false\n-        }\n-    } else {\n-        false\n-    }\n-}\n-\n-/// Extract inner type from Option<T> or return original\n-fn extract_inner_type(ty: &syn::Type) -> syn::Type {\n-    if let syn::Type::Path(type_path) = ty {\n-        if let Some(segment) = type_path.path.segments.last() {\n-            if segment.ident == \"Option\" {\n-                if let syn::PathArguments::AngleBracketed(args) = &segment.arguments {\n-                    if let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first() {\n-                        return inner_ty.clone();\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    ty.clone()\n-}\n"
                },
                {
                    "date": 1762033869459,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -114,9 +114,9 @@\n     };\n \n     // Extract docstring for help text\n     let docstring = extract_docstring(&input_fn);\n-    \n+\n     // Parse argument descriptions from docstring\n     let arg_descriptions = parse_argument_descriptions(&docstring);\n \n     generate_verb_registration(input_fn, verb_name, noun_name, Some(docstring), arg_descriptions)\n@@ -176,68 +176,68 @@\n         .to_string()\n }\n \n /// Parse argument descriptions from docstring\n-/// \n+///\n /// Extracts individual argument descriptions from a `# Arguments` section\n /// in the docstring. Format:\n /// ```rust\n /// /// # Arguments\n /// /// * `arg_name` - Description of argument\n /// /// * `other_arg` - Another description\n /// ```\n-/// \n+///\n /// Returns a HashMap mapping argument names to their descriptions\n fn parse_argument_descriptions(docstring: &str) -> std::collections::HashMap<String, String> {\n     let mut descriptions = std::collections::HashMap::new();\n-    \n+\n     // Split docstring into lines\n     let lines: Vec<&str> = docstring.lines().collect();\n     let mut in_arguments_section = false;\n-    \n+\n     for line in lines {\n         let trimmed = line.trim();\n-        \n+\n         // Check if we've entered the Arguments section\n         if trimmed == \"# Arguments\" || trimmed.starts_with(\"# Arguments\") {\n             in_arguments_section = true;\n             continue;\n         }\n-        \n+\n         // If we hit another section heading, stop parsing\n         if in_arguments_section && trimmed.starts_with('#') && !trimmed.starts_with(\"# Arguments\") {\n             break;\n         }\n-        \n+\n         // Parse argument description line\n         // Format: `* `arg_name` - description` or `* arg_name - description`\n         if in_arguments_section && trimmed.starts_with('*') {\n             let rest = trimmed[1..].trim();\n-            \n+\n             // Extract argument name and description\n             // Support formats:\n             // - `* `arg_name` - description`\n             // - `* arg_name - description`\n             // - `* \\`arg_name\\` - description`\n             if let Some(dash_pos) = rest.find('-') {\n                 let before_dash = rest[..dash_pos].trim();\n                 let description = rest[dash_pos + 1..].trim().to_string();\n-                \n+\n                 // Extract argument name (remove backticks and asterisks)\n                 let arg_name = before_dash\n                     .trim_start_matches('*')\n                     .trim()\n                     .trim_matches('`')\n                     .trim()\n                     .to_string();\n-                \n+\n                 if !arg_name.is_empty() && !description.is_empty() {\n                     descriptions.insert(arg_name, description);\n                 }\n             }\n         }\n     }\n-    \n+\n     descriptions\n }\n \n /// Generate verb registration code with full type inference\n@@ -310,9 +310,9 @@\n             };\n \n             let is_option = is_option_type(&pat_type.ty);\n             let is_flag = is_bool_type(&pat_type.ty);\n-            \n+\n             // Get help text from docstring if available\n             let help_text = arg_descriptions.get(&arg_name);\n             let help_token = if let Some(help) = help_text {\n                 quote! { Some(#help.to_string()) }\n"
                },
                {
                    "date": 1762033978554,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,408 @@\n+//! Procedural macros for clap-noun-verb\n+//!\n+//! This crate provides attribute macros `#[noun]` and `#[verb]` for\n+//! declarative CLI command registration.\n+\n+use proc_macro::TokenStream;\n+use quote::quote;\n+use syn::{parse_macro_input, ItemFn, parse::Parser};\n+\n+/// Attribute macro for registering a noun command\n+///\n+/// Usage:\n+/// ```rust,ignore\n+/// #[noun(\"services\", \"Manage services\")]\n+/// fn my_function() {}\n+/// ```\n+#[proc_macro_attribute]\n+pub fn noun(args: TokenStream, input: TokenStream) -> TokenStream {\n+    let input_fn = parse_macro_input!(input as ItemFn);\n+\n+    // Parse arguments: name and about\n+    let parser = syn::punctuated::Punctuated::<syn::Expr, syn::Token![,]>::parse_terminated;\n+    let args_vec: syn::punctuated::Punctuated<_, _> = match Parser::parse2(parser, proc_macro2::TokenStream::from(args)) {\n+        Ok(args) => args,\n+        Err(e) => return e.to_compile_error().into(),\n+    };\n+\n+    if args_vec.len() != 2 {\n+        return syn::Error::new_spanned(\n+            quote! { #args_vec },\n+            \"Expected exactly 2 arguments: name and about\"\n+        )\n+        .to_compile_error()\n+        .into();\n+    }\n+\n+    let name_expr = &args_vec[0];\n+    let about_expr = &args_vec[1];\n+\n+    let name_str = match name_expr {\n+        syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n+        _ => return syn::Error::new_spanned(name_expr, \"First argument must be a string literal\")\n+            .to_compile_error().into(),\n+    };\n+\n+    let about_str = match about_expr {\n+        syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n+        _ => return syn::Error::new_spanned(about_expr, \"Second argument must be a string literal\")\n+            .to_compile_error().into(),\n+    };\n+\n+    let fn_name = &input_fn.sig.ident;\n+    let init_fn_name = quote::format_ident!(\"__init_noun_{}\", fn_name);\n+\n+    // Generate registration code\n+    let expanded = quote! {\n+        #input_fn\n+\n+        // Auto-generated registration\n+        #[linkme::distributed_slice(::clap_noun_verb::cli::registry::__NOUN_REGISTRY)]\n+        static #init_fn_name: fn() = || {\n+            ::clap_noun_verb::cli::registry::CommandRegistry::register_noun(\n+                #name_str,\n+                #about_str,\n+            );\n+        };\n+    };\n+\n+    expanded.into()\n+}\n+\n+/// Attribute macro for registering a verb command\n+///\n+/// Usage:\n+/// ```rust,ignore\n+/// #[verb(\"status\")]\n+/// fn show_status() -> Result<Status> {}\n+/// ```\n+#[proc_macro_attribute]\n+pub fn verb(args: TokenStream, input: TokenStream) -> TokenStream {\n+    let input_fn = parse_macro_input!(input as ItemFn);\n+\n+    // Parse verb name from args\n+    let parser = syn::punctuated::Punctuated::<syn::Expr, syn::Token![,]>::parse_terminated;\n+    let args_vec: syn::punctuated::Punctuated<_, _> = match Parser::parse2(parser, proc_macro2::TokenStream::from(args)) {\n+        Ok(args) => args,\n+        Err(_) => {\n+            // If parsing fails, extract verb name from function name\n+            let verb_name = extract_verb_name_from_fn_name(&input_fn);\n+            let docstring = extract_docstring(&input_fn);\n+            let arg_descriptions = parse_argument_descriptions(&docstring);\n+            return generate_verb_registration(input_fn, verb_name, None, None, arg_descriptions);\n+        }\n+    };\n+\n+    let verb_name = if args_vec.is_empty() {\n+        extract_verb_name_from_fn_name(&input_fn)\n+    } else {\n+        match &args_vec[0] {\n+            syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n+            _ => return syn::Error::new_spanned(&args_vec[0], \"First argument must be a string literal\")\n+                .to_compile_error().into(),\n+        }\n+    };\n+\n+    // Extract noun name if provided as second arg\n+    let noun_name = if args_vec.len() > 1 {\n+        match &args_vec[1] {\n+            syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => Some(s.value()),\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    };\n+\n+    // Extract docstring for help text\n+    let docstring = extract_docstring(&input_fn);\n+\n+    // Parse argument descriptions from docstring\n+    let arg_descriptions = parse_argument_descriptions(&docstring);\n+\n+    generate_verb_registration(input_fn, verb_name, noun_name, Some(docstring), arg_descriptions)\n+}\n+\n+/// Extract verb name from function name (remove \"show_\", \"get_\", etc.)\n+fn extract_verb_name_from_fn_name(input_fn: &ItemFn) -> String {\n+    let fn_name = input_fn.sig.ident.to_string();\n+\n+    // Remove common prefixes\n+    if let Some(stripped) = fn_name.strip_prefix(\"show_\") {\n+        stripped.to_string()\n+    } else if let Some(stripped) = fn_name.strip_prefix(\"get_\") {\n+        stripped.to_string()\n+    } else if let Some(stripped) = fn_name.strip_prefix(\"list_\") {\n+        stripped.to_string()\n+    } else {\n+        fn_name\n+    }\n+}\n+\n+/// Extract docstring from function attributes\n+///\n+/// Doc comments in syn are stored as Meta::List with \"doc\" as the path.\n+/// Each doc comment line is a separate attribute.\n+fn extract_docstring(input_fn: &ItemFn) -> String {\n+    input_fn.attrs.iter()\n+        .filter_map(|attr| {\n+            if attr.path().is_ident(\"doc\") {\n+                // Doc comments in syn 2.0 are stored as Meta::NameValue\n+                // Format: #[doc = \"text\"]\n+                let meta = &attr.meta;\n+                match meta {\n+                    syn::Meta::NameValue(nv) => {\n+                        if let syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) = &nv.value {\n+                            Some(s.value().trim().to_string())\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    // Some doc comments might be in List format\n+                    syn::Meta::List(list) => {\n+                        // Extract tokens from list\n+                        let tokens = list.tokens.to_string();\n+                        // Remove quotes and extra formatting\n+                        Some(tokens.trim_matches('\"').trim().to_string())\n+                    }\n+                    _ => None,\n+                }\n+            } else {\n+                None\n+            }\n+        })\n+        .collect::<Vec<_>>()\n+        .join(\" \")\n+        .trim()\n+        .to_string()\n+}\n+\n+/// Parse argument descriptions from docstring\n+///\n+/// Extracts individual argument descriptions from a `# Arguments` section\n+/// in the docstring. Format:\n+/// ```rust\n+/// /// # Arguments\n+/// /// * `arg_name` - Description of argument\n+/// /// * `other_arg` - Another description\n+/// ```\n+///\n+/// Returns a HashMap mapping argument names to their descriptions\n+fn parse_argument_descriptions(docstring: &str) -> std::collections::HashMap<String, String> {\n+    let mut descriptions = std::collections::HashMap::new();\n+\n+    // Split docstring into lines\n+    let lines: Vec<&str> = docstring.lines().collect();\n+    let mut in_arguments_section = false;\n+\n+    for line in lines {\n+        let trimmed = line.trim();\n+\n+        // Check if we've entered the Arguments section\n+        if trimmed == \"# Arguments\" || trimmed.starts_with(\"# Arguments\") {\n+            in_arguments_section = true;\n+            continue;\n+        }\n+\n+        // If we hit another section heading, stop parsing\n+        if in_arguments_section && trimmed.starts_with('#') && !trimmed.starts_with(\"# Arguments\") {\n+            break;\n+        }\n+\n+        // Parse argument description line\n+        // Format: `* `arg_name` - description` or `* arg_name - description`\n+        if in_arguments_section && trimmed.starts_with('*') {\n+            let rest = trimmed[1..].trim();\n+\n+            // Extract argument name and description\n+            // Support formats:\n+            // - `* `arg_name` - description`\n+            // - `* arg_name - description`\n+            // - `* \\`arg_name\\` - description`\n+            if let Some(dash_pos) = rest.find('-') {\n+                let before_dash = rest[..dash_pos].trim();\n+                let description = rest[dash_pos + 1..].trim().to_string();\n+\n+                // Extract argument name (remove backticks and asterisks)\n+                let arg_name = before_dash\n+                    .trim_start_matches('*')\n+                    .trim()\n+                    .trim_matches('`')\n+                    .trim()\n+                    .to_string();\n+\n+                if !arg_name.is_empty() && !description.is_empty() {\n+                    descriptions.insert(arg_name, description);\n+                }\n+            }\n+        }\n+    }\n+\n+    descriptions\n+}\n+\n+/// Generate verb registration code with full type inference\n+fn generate_verb_registration(\n+    input_fn: ItemFn,\n+    verb_name: String,\n+    noun_name: Option<String>,\n+    about: Option<String>,\n+    arg_descriptions: std::collections::HashMap<String, String>,\n+) -> TokenStream {\n+    let fn_name = &input_fn.sig.ident;\n+    let wrapper_name = quote::format_ident!(\"__{}_wrapper\", fn_name);\n+    let init_fn_name = quote::format_ident!(\"__init_{}\", fn_name);\n+\n+    // Analyze function signature for arguments\n+    let mut arg_extractions = Vec::new();\n+    let mut arg_calls = Vec::new();\n+\n+    for input in &input_fn.sig.inputs {\n+        if let syn::FnArg::Typed(pat_type) = input {\n+            let arg_name = match &*pat_type.pat {\n+                syn::Pat::Ident(ident) => &ident.ident,\n+                _ => continue,\n+            };\n+\n+            let arg_name_str = arg_name.to_string();\n+\n+            // Determine if optional (Option<T>) or required\n+            let is_option = is_option_type(&pat_type.ty);\n+            let inner_type = extract_inner_type(&pat_type.ty);\n+            let is_flag = is_bool_type(&pat_type.ty);\n+\n+            if is_flag {\n+                // Boolean flags\n+                arg_extractions.push(quote! {\n+                    let #arg_name = input.opts.get(#arg_name_str)\n+                        .map(|v| v.parse::<bool>().unwrap_or(false))\n+                        .unwrap_or(false);\n+                });\n+                arg_calls.push(quote! { #arg_name });\n+            } else if is_option {\n+                // Optional arguments\n+                arg_extractions.push(quote! {\n+                    let #arg_name = input.args.get(#arg_name_str)\n+                        .and_then(|v| v.parse::<#inner_type>().ok());\n+                });\n+                arg_calls.push(quote! { #arg_name });\n+            } else {\n+                // Required arguments\n+                arg_extractions.push(quote! {\n+                    let #arg_name = input.args.get(#arg_name_str)\n+                        .ok_or_else(|| ::clap_noun_verb::error::NounVerbError::missing_argument(#arg_name_str))?\n+                        .parse::<#inner_type>()\n+                        .map_err(|_| ::clap_noun_verb::error::NounVerbError::argument_error(\n+                            format!(\"Invalid value for argument '{}'\", #arg_name_str)\n+                        ))?;\n+                });\n+                arg_calls.push(quote! { #arg_name });\n+            }\n+        }\n+    }\n+\n+    // Generate argument metadata for registration\n+    let mut arg_metadata = Vec::new();\n+    for input in &input_fn.sig.inputs {\n+        if let syn::FnArg::Typed(pat_type) = input {\n+            let arg_name = match &*pat_type.pat {\n+                syn::Pat::Ident(ident) => ident.ident.to_string(),\n+                _ => continue,\n+            };\n+\n+            let is_option = is_option_type(&pat_type.ty);\n+            let is_flag = is_bool_type(&pat_type.ty);\n+\n+            // Get help text from docstring if available\n+            let help_text = arg_descriptions.get(&arg_name);\n+            let help_token = if let Some(help) = help_text {\n+                quote! { Some(#help.to_string()) }\n+            } else {\n+                quote! { None }\n+            };\n+\n+            arg_metadata.push(quote! {\n+                ::clap_noun_verb::cli::registry::ArgMetadata {\n+                    name: #arg_name.to_string(),\n+                    required: !#is_option,\n+                    is_flag: #is_flag,\n+                    help: #help_token,\n+                }\n+            });\n+        }\n+    }\n+\n+    // Generate wrapper function\n+    let noun_name_str = noun_name.as_ref().map(|s| s.as_str()).unwrap_or(\"__auto__\");\n+    let about_str = about.as_ref().map(|s| s.as_str()).unwrap_or(\"\");\n+\n+    let expanded = quote! {\n+        #input_fn\n+\n+        // Wrapper function that adapts HandlerInput to function signature\n+        fn #wrapper_name(input: ::clap_noun_verb::logic::HandlerInput) -> ::clap_noun_verb::error::Result<::clap_noun_verb::logic::HandlerOutput> {\n+            #(#arg_extractions)*\n+            let result = #fn_name(#(#arg_calls),*)?;\n+            ::clap_noun_verb::logic::HandlerOutput::from_data(result)\n+        }\n+\n+        // Auto-generated registration\n+        #[linkme::distributed_slice(::clap_noun_verb::cli::registry::__VERB_REGISTRY)]\n+        static #init_fn_name: fn() = || {\n+            let noun_name = #noun_name_str;\n+            if noun_name != \"__auto__\" {\n+                let args = vec![#(#arg_metadata),*];\n+                ::clap_noun_verb::cli::registry::CommandRegistry::register_verb_with_args::<_>(\n+                    noun_name,\n+                    #verb_name,\n+                    #about_str,\n+                    args,\n+                    #wrapper_name,\n+                );\n+            }\n+        };\n+    };\n+\n+    expanded.into()\n+}\n+\n+/// Check if type is Option<T>\n+fn is_option_type(ty: &syn::Type) -> bool {\n+    if let syn::Type::Path(type_path) = ty {\n+        if let Some(segment) = type_path.path.segments.last() {\n+            segment.ident == \"Option\"\n+        } else {\n+            false\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Check if type is bool\n+fn is_bool_type(ty: &syn::Type) -> bool {\n+    if let syn::Type::Path(type_path) = ty {\n+        if let Some(segment) = type_path.path.segments.last() {\n+            segment.ident == \"bool\"\n+        } else {\n+            false\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Extract inner type from Option<T> or return original\n+fn extract_inner_type(ty: &syn::Type) -> syn::Type {\n+    if let syn::Type::Path(type_path) = ty {\n+        if let Some(segment) = type_path.path.segments.last() {\n+            if segment.ident == \"Option\" {\n+                if let syn::PathArguments::AngleBracketed(args) = &segment.arguments {\n+                    if let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first() {\n+                        return inner_ty.clone();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    ty.clone()\n+}\n"
                }
            ],
            "date": 1762031171856,
            "name": "Commit-0",
            "content": "//! Procedural macros for clap-noun-verb\n//!\n//! This crate provides attribute macros `#[noun]` and `#[verb]` for\n//! declarative CLI command registration.\n\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn::{parse_macro_input, ItemFn, parse::Parser};\n\n/// Attribute macro for registering a noun command\n///\n/// Usage:\n/// ```rust,ignore\n/// #[noun(\"services\", \"Manage services\")]\n/// fn my_function() {}\n/// ```\n#[proc_macro_attribute]\npub fn noun(args: TokenStream, input: TokenStream) -> TokenStream {\n    let input_fn = parse_macro_input!(input as ItemFn);\n\n    // Parse arguments: name and about\n    let parser = syn::punctuated::Punctuated::<syn::Expr, syn::Token![,]>::parse_terminated;\n    let args_vec: syn::punctuated::Punctuated<_, _> = match Parser::parse2(parser, proc_macro2::TokenStream::from(args)) {\n        Ok(args) => args,\n        Err(e) => return e.to_compile_error().into(),\n    };\n\n    if args_vec.len() != 2 {\n        return syn::Error::new_spanned(\n            quote! { #args_vec },\n            \"Expected exactly 2 arguments: name and about\"\n        )\n        .to_compile_error()\n        .into();\n    }\n\n    let name_expr = &args_vec[0];\n    let about_expr = &args_vec[1];\n\n    let name_str = match name_expr {\n        syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n        _ => return syn::Error::new_spanned(name_expr, \"First argument must be a string literal\")\n            .to_compile_error().into(),\n    };\n\n    let about_str = match about_expr {\n        syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n        _ => return syn::Error::new_spanned(about_expr, \"Second argument must be a string literal\")\n            .to_compile_error().into(),\n    };\n\n    let fn_name = &input_fn.sig.ident;\n    let init_fn_name = quote::format_ident!(\"__init_{}\", fn_name);\n\n    // Generate registration code\n    let expanded = quote! {\n        #input_fn\n\n        // Auto-generated registration\n        #[::linkme::distributed_slice(::clap_noun_verb::cli::registry::__NOUN_REGISTRY)]\n        #[linkme(crate = ::clap_noun_verb::cli::registry)]\n        static #init_fn_name: fn() = || {\n            ::clap_noun_verb::cli::registry::CommandRegistry::register_noun(\n                #name_str,\n                #about_str,\n            );\n        };\n    };\n\n    expanded.into()\n}\n\n/// Attribute macro for registering a verb command\n///\n/// Usage:\n/// ```rust,ignore\n/// #[verb(\"status\")]\n/// fn show_status() -> Result<Status> {}\n/// ```\n#[proc_macro_attribute]\npub fn verb(args: TokenStream, input: TokenStream) -> TokenStream {\n    let input_fn = parse_macro_input!(input as ItemFn);\n\n    // Parse verb name from args\n    let parser = syn::punctuated::Punctuated::<syn::Expr, syn::Token![,]>::parse_terminated;\n    let args_vec: syn::punctuated::Punctuated<_, _> = match Parser::parse2(parser, proc_macro2::TokenStream::from(args)) {\n        Ok(args) => args,\n        Err(_) => {\n            // If parsing fails, extract verb name from function name\n            let verb_name = extract_verb_name_from_fn_name(&input_fn);\n            return generate_verb_registration(input_fn, verb_name, None, None);\n        }\n    };\n\n    let verb_name = if args_vec.is_empty() {\n        extract_verb_name_from_fn_name(&input_fn)\n    } else {\n        match &args_vec[0] {\n            syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => s.value(),\n            _ => return syn::Error::new_spanned(&args_vec[0], \"First argument must be a string literal\")\n                .to_compile_error().into(),\n        }\n    };\n\n    // Extract noun name if provided as second arg\n    let noun_name = if args_vec.len() > 1 {\n        match &args_vec[1] {\n            syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) => Some(s.value()),\n            _ => None,\n        }\n    } else {\n        None\n    };\n\n    // Extract docstring for help text\n    let docstring = extract_docstring(&input_fn);\n\n    generate_verb_registration(input_fn, verb_name, noun_name, Some(docstring))\n}\n\n/// Extract verb name from function name (remove \"show_\", \"get_\", etc.)\nfn extract_verb_name_from_fn_name(input_fn: &ItemFn) -> String {\n    let fn_name = input_fn.sig.ident.to_string();\n\n    // Remove common prefixes\n    if let Some(stripped) = fn_name.strip_prefix(\"show_\") {\n        stripped.to_string()\n    } else if let Some(stripped) = fn_name.strip_prefix(\"get_\") {\n        stripped.to_string()\n    } else if let Some(stripped) = fn_name.strip_prefix(\"list_\") {\n        stripped.to_string()\n    } else {\n        fn_name\n    }\n}\n\n/// Extract docstring from function attributes\nfn extract_docstring(input_fn: &ItemFn) -> String {\n    input_fn.attrs.iter()\n        .filter_map(|attr| {\n            if attr.path().is_ident(\"doc\") {\n                // Doc comments in syn are stored as Meta::NameValue with a string literal\n                // For now, we'll extract from the token stream\n                let meta = &attr.meta;\n                if let syn::Meta::NameValue(nv) = meta {\n                    if let syn::Expr::Lit(syn::ExprLit { lit: syn::Lit::Str(s), .. }) = &nv.value {\n                        Some(s.value().trim().to_string())\n                    } else {\n                        None\n                    }\n                } else {\n                    None\n                }\n            } else {\n                None\n            }\n        })\n        .collect::<Vec<_>>()\n        .join(\" \")\n        .trim()\n        .to_string()\n}\n\n/// Generate verb registration code with full type inference\nfn generate_verb_registration(\n    input_fn: ItemFn,\n    verb_name: String,\n    noun_name: Option<String>,\n    about: Option<String>,\n) -> TokenStream {\n    let fn_name = &input_fn.sig.ident;\n    let wrapper_name = quote::format_ident!(\"__{}_wrapper\", fn_name);\n    let init_fn_name = quote::format_ident!(\"__init_{}\", fn_name);\n\n    // Analyze function signature for arguments\n    let mut arg_extractions = Vec::new();\n    let mut arg_calls = Vec::new();\n\n    for input in &input_fn.sig.inputs {\n        if let syn::FnArg::Typed(pat_type) = input {\n            let arg_name = match &*pat_type.pat {\n                syn::Pat::Ident(ident) => &ident.ident,\n                _ => continue,\n            };\n\n            let arg_name_str = arg_name.to_string();\n\n            // Determine if optional (Option<T>) or required\n            let is_option = is_option_type(&pat_type.ty);\n            let inner_type = extract_inner_type(&pat_type.ty);\n            let is_flag = is_bool_type(&pat_type.ty);\n\n            if is_flag {\n                // Boolean flags\n                arg_extractions.push(quote! {\n                    let #arg_name = input.opts.get(#arg_name_str)\n                        .map(|v| v.parse::<bool>().unwrap_or(false))\n                        .unwrap_or(false);\n                });\n                arg_calls.push(quote! { #arg_name });\n            } else if is_option {\n                // Optional arguments\n                arg_extractions.push(quote! {\n                    let #arg_name = input.args.get(#arg_name_str)\n                        .and_then(|v| v.parse::<#inner_type>().ok());\n                });\n                arg_calls.push(quote! { #arg_name });\n            } else {\n                // Required arguments\n                arg_extractions.push(quote! {\n                    let #arg_name = input.args.get(#arg_name_str)\n                        .ok_or_else(|| ::clap_noun_verb::error::NounVerbError::missing_argument(#arg_name_str))?\n                        .parse::<#inner_type>()\n                        .map_err(|_| ::clap_noun_verb::error::NounVerbError::argument_error(\n                            format!(\"Invalid value for argument '{}'\", #arg_name_str)\n                        ))?;\n                });\n                arg_calls.push(quote! { #arg_name });\n            }\n        }\n    }\n\n    // Generate argument metadata for registration\n    let mut arg_metadata = Vec::new();\n    for input in &input_fn.sig.inputs {\n        if let syn::FnArg::Typed(pat_type) = input {\n            let arg_name = match &*pat_type.pat {\n                syn::Pat::Ident(ident) => ident.ident.to_string(),\n                _ => continue,\n            };\n\n            let is_option = is_option_type(&pat_type.ty);\n            let is_flag = is_bool_type(&pat_type.ty);\n\n            arg_metadata.push(quote! {\n                ::clap_noun_verb::cli::registry::ArgMetadata {\n                    name: #arg_name.to_string(),\n                    required: !#is_option,\n                    is_flag: #is_flag,\n                }\n            });\n        }\n    }\n\n    // Generate wrapper function\n    let noun_name_str = noun_name.as_ref().map(|s| s.as_str()).unwrap_or(\"__auto__\");\n    let about_str = about.as_ref().map(|s| s.as_str()).unwrap_or(\"\");\n\n    let expanded = quote! {\n        #input_fn\n\n        // Wrapper function that adapts HandlerInput to function signature\n        fn #wrapper_name(input: ::clap_noun_verb::logic::HandlerInput) -> ::clap_noun_verb::error::Result<::clap_noun_verb::logic::HandlerOutput> {\n            #(#arg_extractions)*\n            let result = #fn_name(#(#arg_calls),*);\n            ::clap_noun_verb::logic::HandlerOutput::from_data(result)\n        }\n\n        // Auto-generated registration\n        #[::linkme::distributed_slice(::clap_noun_verb::cli::registry::__VERB_REGISTRY)]\n        #[linkme(crate = ::clap_noun_verb::cli::registry)]\n        static #init_fn_name: fn() = || {\n            let noun_name = #noun_name_str;\n            if noun_name != \"__auto__\" {\n                let args = vec![#(#arg_metadata),*];\n                ::clap_noun_verb::cli::registry::CommandRegistry::register_verb_with_args::<_>(\n                    noun_name,\n                    #verb_name,\n                    #about_str,\n                    args,\n                    #wrapper_name,\n                );\n            }\n        };\n    };\n\n    expanded.into()\n}\n\n/// Check if type is Option<T>\nfn is_option_type(ty: &syn::Type) -> bool {\n    if let syn::Type::Path(type_path) = ty {\n        if let Some(segment) = type_path.path.segments.last() {\n            segment.ident == \"Option\"\n        } else {\n            false\n        }\n    } else {\n        false\n    }\n}\n\n/// Check if type is bool\nfn is_bool_type(ty: &syn::Type) -> bool {\n    if let syn::Type::Path(type_path) = ty {\n        if let Some(segment) = type_path.path.segments.last() {\n            segment.ident == \"bool\"\n        } else {\n            false\n        }\n    } else {\n        false\n    }\n}\n\n/// Extract inner type from Option<T> or return original\nfn extract_inner_type(ty: &syn::Type) -> syn::Type {\n    if let syn::Type::Path(type_path) = ty {\n        if let Some(segment) = type_path.path.segments.last() {\n            if segment.ident == \"Option\" {\n                if let syn::PathArguments::AngleBracketed(args) = &segment.arguments {\n                    if let Some(syn::GenericArgument::Type(inner_ty)) = args.args.first() {\n                        return inner_ty.clone();\n                    }\n                }\n            }\n        }\n    }\n    ty.clone()\n}\n"
        }
    ]
}