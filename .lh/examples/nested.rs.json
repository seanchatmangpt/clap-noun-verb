{
    "sourceFile": "examples/nested.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1762034411352,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762035018212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,55 +8,33 @@\n use serde::Serialize;\n \n // Business Logic Layer (Pure Functions - Reusable)\n fn run_tests() -> TestResult {\n-    TestResult {\n-        tests_run: 42,\n-        passed: 40,\n-        failed: 2,\n-    }\n+    TestResult { tests_run: 42, passed: 40, failed: 2 }\n }\n \n fn watch_tests() -> WatchResult {\n-    WatchResult {\n-        watching: true,\n-        message: \"Watching for test changes\".to_string(),\n-    }\n+    WatchResult { watching: true, message: \"Watching for test changes\".to_string() }\n }\n \n fn generate_coverage() -> CoverageResult {\n-    CoverageResult {\n-        coverage: 85.5,\n-        message: \"Coverage report generated\".to_string(),\n-    }\n+    CoverageResult { coverage: 85.5, message: \"Coverage report generated\".to_string() }\n }\n \n fn check_lint() -> LintResult {\n-    LintResult {\n-        issues: 3,\n-        message: \"Found 3 linting issues\".to_string(),\n-    }\n+    LintResult { issues: 3, message: \"Found 3 linting issues\".to_string() }\n }\n \n fn fix_lint() -> LintResult {\n-    LintResult {\n-        issues: 0,\n-        message: \"All linting issues fixed\".to_string(),\n-    }\n+    LintResult { issues: 0, message: \"All linting issues fixed\".to_string() }\n }\n \n fn check_format() -> FormatResult {\n-    FormatResult {\n-        needs_formatting: false,\n-        message: \"Code is properly formatted\".to_string(),\n-    }\n+    FormatResult { needs_formatting: false, message: \"Code is properly formatted\".to_string() }\n }\n \n fn apply_format() -> FormatResult {\n-    FormatResult {\n-        needs_formatting: false,\n-        message: \"Formatting applied\".to_string(),\n-    }\n+    FormatResult { needs_formatting: false, message: \"Formatting applied\".to_string() }\n }\n \n #[derive(Serialize, Debug)]\n struct TestResult {\n@@ -126,12 +104,9 @@\n     score: f64,\n }\n \n fn analyze_performance() -> AnalysisResult {\n-    AnalysisResult {\n-        bottlenecks: vec![\"database\".to_string(), \"cache\".to_string()],\n-        score: 7.5,\n-    }\n+    AnalysisResult { bottlenecks: vec![\"database\".to_string(), \"cache\".to_string()], score: 7.5 }\n }\n \n fn analyze_quality() -> AnalysisResult {\n     AnalysisResult {\n@@ -146,110 +121,112 @@\n     active: bool,\n }\n \n fn start_monitoring() -> MonitorResult {\n-    MonitorResult {\n-        status: \"Active\".to_string(),\n-        active: true,\n-    }\n+    MonitorResult { status: \"Active\".to_string(), active: true }\n }\n \n fn get_monitor_status() -> MonitorResult {\n-    MonitorResult {\n-        status: \"Active\".to_string(),\n-        active: true,\n-    }\n+    MonitorResult { status: \"Active\".to_string(), active: true }\n }\n \n // CLI Layer (Input Validation + Output Shaping Only)\n // Using multiple top-level nouns instead of nesting\n \n /// Run tests\n #[noun(\"test\", \"Testing utilities\")]\n-#[verb(\"run\")]\n+#[verb] // Verb name \"run\" auto-inferred, noun \"test\" auto-detected\n fn run_tests_cmd() -> Result<TestResult> {\n     Ok(run_tests())\n }\n \n /// Watch for changes and rerun tests\n-#[verb(\"watch\", \"test\")]\n+#[noun(\"test\", \"Testing utilities\")]\n+#[verb] // Verb name \"watch\" auto-inferred, noun \"test\" auto-detected\n fn watch_tests_cmd() -> Result<WatchResult> {\n     Ok(watch_tests())\n }\n \n /// Generate test coverage report\n-#[verb(\"coverage\", \"test\")]\n+#[noun(\"test\", \"Testing utilities\")]\n+#[verb] // Verb name \"coverage\" auto-inferred, noun \"test\" auto-detected\n fn generate_coverage_cmd() -> Result<CoverageResult> {\n     Ok(generate_coverage())\n }\n \n /// Check code style\n #[noun(\"lint\", \"Code linting tools\")]\n-#[verb(\"check\")]\n+#[verb] // Verb name \"check\" auto-inferred, noun \"lint\" auto-detected\n fn check_lint_cmd() -> Result<LintResult> {\n     Ok(check_lint())\n }\n \n /// Auto-fix linting issues\n-#[verb(\"fix\", \"lint\")]\n+#[noun(\"lint\", \"Code linting tools\")]\n+#[verb] // Verb name \"fix\" auto-inferred, noun \"lint\" auto-detected\n fn fix_lint_cmd() -> Result<LintResult> {\n     Ok(fix_lint())\n }\n \n /// Check formatting\n #[noun(\"format\", \"Code formatting tools\")]\n-#[verb(\"check\")]\n+#[verb] // Verb name \"check\" auto-inferred, noun \"format\" auto-detected\n fn check_format_cmd() -> Result<FormatResult> {\n     Ok(check_format())\n }\n \n /// Apply formatting\n-#[verb(\"apply\", \"format\")]\n+#[noun(\"format\", \"Code formatting tools\")]\n+#[verb] // Verb name \"apply\" auto-inferred, noun \"format\" auto-detected\n fn apply_format_cmd() -> Result<FormatResult> {\n     Ok(apply_format())\n }\n \n /// Run AI-orchestrated tests\n #[noun(\"orchestrate\", \"AI test orchestration\")]\n-#[verb(\"run\")]\n+#[verb] // Verb name \"run\" auto-inferred, noun \"orchestrate\" auto-detected\n fn run_ai_tests_cmd() -> Result<AIOrchestrateResult> {\n     Ok(run_ai_tests())\n }\n \n /// Predict test failures\n-#[verb(\"predict\", \"orchestrate\")]\n+#[noun(\"orchestrate\", \"AI test orchestration\")]\n+#[verb] // Verb name \"predict\" auto-inferred, noun \"orchestrate\" auto-detected\n fn predict_failures_cmd() -> Result<AIOrchestrateResult> {\n     Ok(predict_failures())\n }\n \n /// Optimize test execution\n-#[verb(\"optimize\", \"orchestrate\")]\n+#[noun(\"orchestrate\", \"AI test orchestration\")]\n+#[verb] // Verb name \"optimize\" auto-inferred, noun \"orchestrate\" auto-detected\n fn optimize_tests_cmd() -> Result<AIOrchestrateResult> {\n     Ok(optimize_tests())\n }\n \n /// Analyze performance bottlenecks\n #[noun(\"analyze\", \"AI-powered analysis\")]\n-#[verb(\"performance\")]\n+#[verb(\"performance\")] // Custom verb name (not inferrable from function name)\n fn analyze_performance_cmd() -> Result<AnalysisResult> {\n     Ok(analyze_performance())\n }\n \n /// Analyze code quality\n-#[verb(\"quality\", \"analyze\")]\n+#[noun(\"analyze\", \"AI-powered analysis\")]\n+#[verb] // Verb name \"quality\" auto-inferred, noun \"analyze\" auto-detected\n fn analyze_quality_cmd() -> Result<AnalysisResult> {\n     Ok(analyze_quality())\n }\n \n /// Start AI monitoring\n #[noun(\"monitor\", \"AI monitoring\")]\n-#[verb(\"start\")]\n+#[verb] // Verb name \"start\" auto-inferred, noun \"monitor\" auto-detected\n fn start_monitoring_cmd() -> Result<MonitorResult> {\n     Ok(start_monitoring())\n }\n \n /// Check monitoring status\n-#[verb(\"status\", \"monitor\")]\n+#[noun(\"monitor\", \"AI monitoring\")]\n+#[verb] // Verb name \"status\" auto-inferred, noun \"monitor\" auto-detected\n fn get_monitor_status_cmd() -> Result<MonitorResult> {\n     Ok(get_monitor_status())\n }\n \n"
                },
                {
                    "date": 1762035131529,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,236 @@\n+//! Multiple nouns example demonstrating compound commands\n+//!\n+//! Note: v3 attribute macro API doesn't support nested nouns.\n+//! This example shows multiple top-level nouns instead.\n+\n+use clap_noun_verb::Result;\n+use clap_noun_verb_macros::{noun, verb};\n+use serde::Serialize;\n+\n+// Business Logic Layer (Pure Functions - Reusable)\n+fn run_tests() -> TestResult {\n+    TestResult { tests_run: 42, passed: 40, failed: 2 }\n+}\n+\n+fn watch_tests() -> WatchResult {\n+    WatchResult { watching: true, message: \"Watching for test changes\".to_string() }\n+}\n+\n+fn generate_coverage() -> CoverageResult {\n+    CoverageResult { coverage: 85.5, message: \"Coverage report generated\".to_string() }\n+}\n+\n+fn check_lint() -> LintResult {\n+    LintResult { issues: 3, message: \"Found 3 linting issues\".to_string() }\n+}\n+\n+fn fix_lint() -> LintResult {\n+    LintResult { issues: 0, message: \"All linting issues fixed\".to_string() }\n+}\n+\n+fn check_format() -> FormatResult {\n+    FormatResult { needs_formatting: false, message: \"Code is properly formatted\".to_string() }\n+}\n+\n+fn apply_format() -> FormatResult {\n+    FormatResult { needs_formatting: false, message: \"Formatting applied\".to_string() }\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct TestResult {\n+    tests_run: usize,\n+    passed: usize,\n+    failed: usize,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct WatchResult {\n+    watching: bool,\n+    message: String,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct CoverageResult {\n+    coverage: f64,\n+    message: String,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct LintResult {\n+    issues: usize,\n+    message: String,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct FormatResult {\n+    needs_formatting: bool,\n+    message: String,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct AIOrchestrateResult {\n+    tests_run: usize,\n+    optimized: bool,\n+    message: String,\n+}\n+\n+fn run_ai_tests() -> AIOrchestrateResult {\n+    AIOrchestrateResult {\n+        tests_run: 42,\n+        optimized: true,\n+        message: \"AI-orchestrated tests completed\".to_string(),\n+    }\n+}\n+\n+fn predict_failures() -> AIOrchestrateResult {\n+    AIOrchestrateResult {\n+        tests_run: 0,\n+        optimized: false,\n+        message: \"Predicted 2 potential failures\".to_string(),\n+    }\n+}\n+\n+fn optimize_tests() -> AIOrchestrateResult {\n+    AIOrchestrateResult {\n+        tests_run: 0,\n+        optimized: true,\n+        message: \"Test execution optimized by 15%\".to_string(),\n+    }\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct AnalysisResult {\n+    bottlenecks: Vec<String>,\n+    score: f64,\n+}\n+\n+fn analyze_performance() -> AnalysisResult {\n+    AnalysisResult { bottlenecks: vec![\"database\".to_string(), \"cache\".to_string()], score: 7.5 }\n+}\n+\n+fn analyze_quality() -> AnalysisResult {\n+    AnalysisResult {\n+        bottlenecks: vec![\"code coverage\".to_string(), \"documentation\".to_string()],\n+        score: 8.2,\n+    }\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct MonitorResult {\n+    status: String,\n+    active: bool,\n+}\n+\n+fn start_monitoring() -> MonitorResult {\n+    MonitorResult { status: \"Active\".to_string(), active: true }\n+}\n+\n+fn get_monitor_status() -> MonitorResult {\n+    MonitorResult { status: \"Active\".to_string(), active: true }\n+}\n+\n+// CLI Layer (Input Validation + Output Shaping Only)\n+// Using multiple top-level nouns instead of nesting\n+\n+/// Run tests\n+#[noun(\"test\", \"Testing utilities\")]\n+#[verb] // Verb name \"run\" auto-inferred, noun \"test\" auto-detected\n+fn run_tests_cmd() -> Result<TestResult> {\n+    Ok(run_tests())\n+}\n+\n+/// Watch for changes and rerun tests\n+#[noun(\"test\", \"Testing utilities\")]\n+#[verb] // Verb name \"watch\" auto-inferred, noun \"test\" auto-detected\n+fn watch_tests_cmd() -> Result<WatchResult> {\n+    Ok(watch_tests())\n+}\n+\n+/// Generate test coverage report\n+#[noun(\"test\", \"Testing utilities\")]\n+#[verb] // Verb name \"coverage\" auto-inferred, noun \"test\" auto-detected\n+fn generate_coverage_cmd() -> Result<CoverageResult> {\n+    Ok(generate_coverage())\n+}\n+\n+/// Check code style\n+#[noun(\"lint\", \"Code linting tools\")]\n+#[verb] // Verb name \"check\" auto-inferred, noun \"lint\" auto-detected\n+fn check_lint_cmd() -> Result<LintResult> {\n+    Ok(check_lint())\n+}\n+\n+/// Auto-fix linting issues\n+#[noun(\"lint\", \"Code linting tools\")]\n+#[verb] // Verb name \"fix\" auto-inferred, noun \"lint\" auto-detected\n+fn fix_lint_cmd() -> Result<LintResult> {\n+    Ok(fix_lint())\n+}\n+\n+/// Check formatting\n+#[noun(\"format\", \"Code formatting tools\")]\n+#[verb] // Verb name \"check\" auto-inferred, noun \"format\" auto-detected\n+fn check_format_cmd() -> Result<FormatResult> {\n+    Ok(check_format())\n+}\n+\n+/// Apply formatting\n+#[noun(\"format\", \"Code formatting tools\")]\n+#[verb] // Verb name \"apply\" auto-inferred, noun \"format\" auto-detected\n+fn apply_format_cmd() -> Result<FormatResult> {\n+    Ok(apply_format())\n+}\n+\n+/// Run AI-orchestrated tests\n+#[noun(\"orchestrate\", \"AI test orchestration\")]\n+#[verb] // Verb name \"run\" auto-inferred, noun \"orchestrate\" auto-detected\n+fn run_ai_tests_cmd() -> Result<AIOrchestrateResult> {\n+    Ok(run_ai_tests())\n+}\n+\n+/// Predict test failures\n+#[noun(\"orchestrate\", \"AI test orchestration\")]\n+#[verb] // Verb name \"predict\" auto-inferred, noun \"orchestrate\" auto-detected\n+fn predict_failures_cmd() -> Result<AIOrchestrateResult> {\n+    Ok(predict_failures())\n+}\n+\n+/// Optimize test execution\n+#[noun(\"orchestrate\", \"AI test orchestration\")]\n+#[verb] // Verb name \"optimize\" auto-inferred, noun \"orchestrate\" auto-detected\n+fn optimize_tests_cmd() -> Result<AIOrchestrateResult> {\n+    Ok(optimize_tests())\n+}\n+\n+/// Analyze performance bottlenecks\n+#[noun(\"analyze\", \"AI-powered analysis\")]\n+#[verb(\"performance\")] // Custom verb name (not inferrable from function name)\n+fn analyze_performance_cmd() -> Result<AnalysisResult> {\n+    Ok(analyze_performance())\n+}\n+\n+/// Analyze code quality\n+#[noun(\"analyze\", \"AI-powered analysis\")]\n+#[verb] // Verb name \"quality\" auto-inferred, noun \"analyze\" auto-detected\n+fn analyze_quality_cmd() -> Result<AnalysisResult> {\n+    Ok(analyze_quality())\n+}\n+\n+/// Start AI monitoring\n+#[noun(\"monitor\", \"AI monitoring\")]\n+#[verb] // Verb name \"start\" auto-inferred, noun \"monitor\" auto-detected\n+fn start_monitoring_cmd() -> Result<MonitorResult> {\n+    Ok(start_monitoring())\n+}\n+\n+/// Check monitoring status\n+#[noun(\"monitor\", \"AI monitoring\")]\n+#[verb] // Verb name \"status\" auto-inferred, noun \"monitor\" auto-detected\n+fn get_monitor_status_cmd() -> Result<MonitorResult> {\n+    Ok(get_monitor_status())\n+}\n+\n+fn main() -> Result<()> {\n+    // Auto-discover all registered commands and run\n+    clap_noun_verb::run()\n+}\n"
                },
                {
                    "date": 1762035217589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -233,240 +233,4 @@\n fn main() -> Result<()> {\n     // Auto-discover all registered commands and run\n     clap_noun_verb::run()\n }\n-//! Multiple nouns example demonstrating compound commands\n-//!\n-//! Note: v3 attribute macro API doesn't support nested nouns.\n-//! This example shows multiple top-level nouns instead.\n-\n-use clap_noun_verb::Result;\n-use clap_noun_verb_macros::{noun, verb};\n-use serde::Serialize;\n-\n-// Business Logic Layer (Pure Functions - Reusable)\n-fn run_tests() -> TestResult {\n-    TestResult { tests_run: 42, passed: 40, failed: 2 }\n-}\n-\n-fn watch_tests() -> WatchResult {\n-    WatchResult { watching: true, message: \"Watching for test changes\".to_string() }\n-}\n-\n-fn generate_coverage() -> CoverageResult {\n-    CoverageResult { coverage: 85.5, message: \"Coverage report generated\".to_string() }\n-}\n-\n-fn check_lint() -> LintResult {\n-    LintResult { issues: 3, message: \"Found 3 linting issues\".to_string() }\n-}\n-\n-fn fix_lint() -> LintResult {\n-    LintResult { issues: 0, message: \"All linting issues fixed\".to_string() }\n-}\n-\n-fn check_format() -> FormatResult {\n-    FormatResult { needs_formatting: false, message: \"Code is properly formatted\".to_string() }\n-}\n-\n-fn apply_format() -> FormatResult {\n-    FormatResult { needs_formatting: false, message: \"Formatting applied\".to_string() }\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct TestResult {\n-    tests_run: usize,\n-    passed: usize,\n-    failed: usize,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct WatchResult {\n-    watching: bool,\n-    message: String,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct CoverageResult {\n-    coverage: f64,\n-    message: String,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct LintResult {\n-    issues: usize,\n-    message: String,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct FormatResult {\n-    needs_formatting: bool,\n-    message: String,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct AIOrchestrateResult {\n-    tests_run: usize,\n-    optimized: bool,\n-    message: String,\n-}\n-\n-fn run_ai_tests() -> AIOrchestrateResult {\n-    AIOrchestrateResult {\n-        tests_run: 42,\n-        optimized: true,\n-        message: \"AI-orchestrated tests completed\".to_string(),\n-    }\n-}\n-\n-fn predict_failures() -> AIOrchestrateResult {\n-    AIOrchestrateResult {\n-        tests_run: 0,\n-        optimized: false,\n-        message: \"Predicted 2 potential failures\".to_string(),\n-    }\n-}\n-\n-fn optimize_tests() -> AIOrchestrateResult {\n-    AIOrchestrateResult {\n-        tests_run: 0,\n-        optimized: true,\n-        message: \"Test execution optimized by 15%\".to_string(),\n-    }\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct AnalysisResult {\n-    bottlenecks: Vec<String>,\n-    score: f64,\n-}\n-\n-fn analyze_performance() -> AnalysisResult {\n-    AnalysisResult { bottlenecks: vec![\"database\".to_string(), \"cache\".to_string()], score: 7.5 }\n-}\n-\n-fn analyze_quality() -> AnalysisResult {\n-    AnalysisResult {\n-        bottlenecks: vec![\"code coverage\".to_string(), \"documentation\".to_string()],\n-        score: 8.2,\n-    }\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct MonitorResult {\n-    status: String,\n-    active: bool,\n-}\n-\n-fn start_monitoring() -> MonitorResult {\n-    MonitorResult { status: \"Active\".to_string(), active: true }\n-}\n-\n-fn get_monitor_status() -> MonitorResult {\n-    MonitorResult { status: \"Active\".to_string(), active: true }\n-}\n-\n-// CLI Layer (Input Validation + Output Shaping Only)\n-// Using multiple top-level nouns instead of nesting\n-\n-/// Run tests\n-#[noun(\"test\", \"Testing utilities\")]\n-#[verb] // Verb name \"run\" auto-inferred, noun \"test\" auto-detected\n-fn run_tests_cmd() -> Result<TestResult> {\n-    Ok(run_tests())\n-}\n-\n-/// Watch for changes and rerun tests\n-#[noun(\"test\", \"Testing utilities\")]\n-#[verb] // Verb name \"watch\" auto-inferred, noun \"test\" auto-detected\n-fn watch_tests_cmd() -> Result<WatchResult> {\n-    Ok(watch_tests())\n-}\n-\n-/// Generate test coverage report\n-#[noun(\"test\", \"Testing utilities\")]\n-#[verb] // Verb name \"coverage\" auto-inferred, noun \"test\" auto-detected\n-fn generate_coverage_cmd() -> Result<CoverageResult> {\n-    Ok(generate_coverage())\n-}\n-\n-/// Check code style\n-#[noun(\"lint\", \"Code linting tools\")]\n-#[verb] // Verb name \"check\" auto-inferred, noun \"lint\" auto-detected\n-fn check_lint_cmd() -> Result<LintResult> {\n-    Ok(check_lint())\n-}\n-\n-/// Auto-fix linting issues\n-#[noun(\"lint\", \"Code linting tools\")]\n-#[verb] // Verb name \"fix\" auto-inferred, noun \"lint\" auto-detected\n-fn fix_lint_cmd() -> Result<LintResult> {\n-    Ok(fix_lint())\n-}\n-\n-/// Check formatting\n-#[noun(\"format\", \"Code formatting tools\")]\n-#[verb] // Verb name \"check\" auto-inferred, noun \"format\" auto-detected\n-fn check_format_cmd() -> Result<FormatResult> {\n-    Ok(check_format())\n-}\n-\n-/// Apply formatting\n-#[noun(\"format\", \"Code formatting tools\")]\n-#[verb] // Verb name \"apply\" auto-inferred, noun \"format\" auto-detected\n-fn apply_format_cmd() -> Result<FormatResult> {\n-    Ok(apply_format())\n-}\n-\n-/// Run AI-orchestrated tests\n-#[noun(\"orchestrate\", \"AI test orchestration\")]\n-#[verb] // Verb name \"run\" auto-inferred, noun \"orchestrate\" auto-detected\n-fn run_ai_tests_cmd() -> Result<AIOrchestrateResult> {\n-    Ok(run_ai_tests())\n-}\n-\n-/// Predict test failures\n-#[noun(\"orchestrate\", \"AI test orchestration\")]\n-#[verb] // Verb name \"predict\" auto-inferred, noun \"orchestrate\" auto-detected\n-fn predict_failures_cmd() -> Result<AIOrchestrateResult> {\n-    Ok(predict_failures())\n-}\n-\n-/// Optimize test execution\n-#[noun(\"orchestrate\", \"AI test orchestration\")]\n-#[verb] // Verb name \"optimize\" auto-inferred, noun \"orchestrate\" auto-detected\n-fn optimize_tests_cmd() -> Result<AIOrchestrateResult> {\n-    Ok(optimize_tests())\n-}\n-\n-/// Analyze performance bottlenecks\n-#[noun(\"analyze\", \"AI-powered analysis\")]\n-#[verb(\"performance\")] // Custom verb name (not inferrable from function name)\n-fn analyze_performance_cmd() -> Result<AnalysisResult> {\n-    Ok(analyze_performance())\n-}\n-\n-/// Analyze code quality\n-#[noun(\"analyze\", \"AI-powered analysis\")]\n-#[verb] // Verb name \"quality\" auto-inferred, noun \"analyze\" auto-detected\n-fn analyze_quality_cmd() -> Result<AnalysisResult> {\n-    Ok(analyze_quality())\n-}\n-\n-/// Start AI monitoring\n-#[noun(\"monitor\", \"AI monitoring\")]\n-#[verb] // Verb name \"start\" auto-inferred, noun \"monitor\" auto-detected\n-fn start_monitoring_cmd() -> Result<MonitorResult> {\n-    Ok(start_monitoring())\n-}\n-\n-/// Check monitoring status\n-#[noun(\"monitor\", \"AI monitoring\")]\n-#[verb] // Verb name \"status\" auto-inferred, noun \"monitor\" auto-detected\n-fn get_monitor_status_cmd() -> Result<MonitorResult> {\n-    Ok(get_monitor_status())\n-}\n-\n-fn main() -> Result<()> {\n-    // Auto-discover all registered commands and run\n-    clap_noun_verb::run()\n-}\n"
                }
            ],
            "date": 1762034411352,
            "name": "Commit-0",
            "content": "//! Multiple nouns example demonstrating compound commands\n//!\n//! Note: v3 attribute macro API doesn't support nested nouns.\n//! This example shows multiple top-level nouns instead.\n\nuse clap_noun_verb::Result;\nuse clap_noun_verb_macros::{noun, verb};\nuse serde::Serialize;\n\n// Business Logic Layer (Pure Functions - Reusable)\nfn run_tests() -> TestResult {\n    TestResult {\n        tests_run: 42,\n        passed: 40,\n        failed: 2,\n    }\n}\n\nfn watch_tests() -> WatchResult {\n    WatchResult {\n        watching: true,\n        message: \"Watching for test changes\".to_string(),\n    }\n}\n\nfn generate_coverage() -> CoverageResult {\n    CoverageResult {\n        coverage: 85.5,\n        message: \"Coverage report generated\".to_string(),\n    }\n}\n\nfn check_lint() -> LintResult {\n    LintResult {\n        issues: 3,\n        message: \"Found 3 linting issues\".to_string(),\n    }\n}\n\nfn fix_lint() -> LintResult {\n    LintResult {\n        issues: 0,\n        message: \"All linting issues fixed\".to_string(),\n    }\n}\n\nfn check_format() -> FormatResult {\n    FormatResult {\n        needs_formatting: false,\n        message: \"Code is properly formatted\".to_string(),\n    }\n}\n\nfn apply_format() -> FormatResult {\n    FormatResult {\n        needs_formatting: false,\n        message: \"Formatting applied\".to_string(),\n    }\n}\n\n#[derive(Serialize, Debug)]\nstruct TestResult {\n    tests_run: usize,\n    passed: usize,\n    failed: usize,\n}\n\n#[derive(Serialize, Debug)]\nstruct WatchResult {\n    watching: bool,\n    message: String,\n}\n\n#[derive(Serialize, Debug)]\nstruct CoverageResult {\n    coverage: f64,\n    message: String,\n}\n\n#[derive(Serialize, Debug)]\nstruct LintResult {\n    issues: usize,\n    message: String,\n}\n\n#[derive(Serialize, Debug)]\nstruct FormatResult {\n    needs_formatting: bool,\n    message: String,\n}\n\n#[derive(Serialize, Debug)]\nstruct AIOrchestrateResult {\n    tests_run: usize,\n    optimized: bool,\n    message: String,\n}\n\nfn run_ai_tests() -> AIOrchestrateResult {\n    AIOrchestrateResult {\n        tests_run: 42,\n        optimized: true,\n        message: \"AI-orchestrated tests completed\".to_string(),\n    }\n}\n\nfn predict_failures() -> AIOrchestrateResult {\n    AIOrchestrateResult {\n        tests_run: 0,\n        optimized: false,\n        message: \"Predicted 2 potential failures\".to_string(),\n    }\n}\n\nfn optimize_tests() -> AIOrchestrateResult {\n    AIOrchestrateResult {\n        tests_run: 0,\n        optimized: true,\n        message: \"Test execution optimized by 15%\".to_string(),\n    }\n}\n\n#[derive(Serialize, Debug)]\nstruct AnalysisResult {\n    bottlenecks: Vec<String>,\n    score: f64,\n}\n\nfn analyze_performance() -> AnalysisResult {\n    AnalysisResult {\n        bottlenecks: vec![\"database\".to_string(), \"cache\".to_string()],\n        score: 7.5,\n    }\n}\n\nfn analyze_quality() -> AnalysisResult {\n    AnalysisResult {\n        bottlenecks: vec![\"code coverage\".to_string(), \"documentation\".to_string()],\n        score: 8.2,\n    }\n}\n\n#[derive(Serialize, Debug)]\nstruct MonitorResult {\n    status: String,\n    active: bool,\n}\n\nfn start_monitoring() -> MonitorResult {\n    MonitorResult {\n        status: \"Active\".to_string(),\n        active: true,\n    }\n}\n\nfn get_monitor_status() -> MonitorResult {\n    MonitorResult {\n        status: \"Active\".to_string(),\n        active: true,\n    }\n}\n\n// CLI Layer (Input Validation + Output Shaping Only)\n// Using multiple top-level nouns instead of nesting\n\n/// Run tests\n#[noun(\"test\", \"Testing utilities\")]\n#[verb(\"run\")]\nfn run_tests_cmd() -> Result<TestResult> {\n    Ok(run_tests())\n}\n\n/// Watch for changes and rerun tests\n#[verb(\"watch\", \"test\")]\nfn watch_tests_cmd() -> Result<WatchResult> {\n    Ok(watch_tests())\n}\n\n/// Generate test coverage report\n#[verb(\"coverage\", \"test\")]\nfn generate_coverage_cmd() -> Result<CoverageResult> {\n    Ok(generate_coverage())\n}\n\n/// Check code style\n#[noun(\"lint\", \"Code linting tools\")]\n#[verb(\"check\")]\nfn check_lint_cmd() -> Result<LintResult> {\n    Ok(check_lint())\n}\n\n/// Auto-fix linting issues\n#[verb(\"fix\", \"lint\")]\nfn fix_lint_cmd() -> Result<LintResult> {\n    Ok(fix_lint())\n}\n\n/// Check formatting\n#[noun(\"format\", \"Code formatting tools\")]\n#[verb(\"check\")]\nfn check_format_cmd() -> Result<FormatResult> {\n    Ok(check_format())\n}\n\n/// Apply formatting\n#[verb(\"apply\", \"format\")]\nfn apply_format_cmd() -> Result<FormatResult> {\n    Ok(apply_format())\n}\n\n/// Run AI-orchestrated tests\n#[noun(\"orchestrate\", \"AI test orchestration\")]\n#[verb(\"run\")]\nfn run_ai_tests_cmd() -> Result<AIOrchestrateResult> {\n    Ok(run_ai_tests())\n}\n\n/// Predict test failures\n#[verb(\"predict\", \"orchestrate\")]\nfn predict_failures_cmd() -> Result<AIOrchestrateResult> {\n    Ok(predict_failures())\n}\n\n/// Optimize test execution\n#[verb(\"optimize\", \"orchestrate\")]\nfn optimize_tests_cmd() -> Result<AIOrchestrateResult> {\n    Ok(optimize_tests())\n}\n\n/// Analyze performance bottlenecks\n#[noun(\"analyze\", \"AI-powered analysis\")]\n#[verb(\"performance\")]\nfn analyze_performance_cmd() -> Result<AnalysisResult> {\n    Ok(analyze_performance())\n}\n\n/// Analyze code quality\n#[verb(\"quality\", \"analyze\")]\nfn analyze_quality_cmd() -> Result<AnalysisResult> {\n    Ok(analyze_quality())\n}\n\n/// Start AI monitoring\n#[noun(\"monitor\", \"AI monitoring\")]\n#[verb(\"start\")]\nfn start_monitoring_cmd() -> Result<MonitorResult> {\n    Ok(start_monitoring())\n}\n\n/// Check monitoring status\n#[verb(\"status\", \"monitor\")]\nfn get_monitor_status_cmd() -> Result<MonitorResult> {\n    Ok(get_monitor_status())\n}\n\nfn main() -> Result<()> {\n    // Auto-discover all registered commands and run\n    clap_noun_verb::run()\n}\n"
        }
    ]
}