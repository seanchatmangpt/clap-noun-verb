{
    "sourceFile": "examples/framework.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1762034411361,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762035018211,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,144 @@\n+//! Framework-level composition example using v3 attribute macro API\n+//!\n+//! This example demonstrates how to use clap-noun-verb v3's attribute macro API\n+//! for building composable CLI applications with automatic type inference,\n+//! JSON output, and separation of concerns.\n+\n+use clap_noun_verb::Result;\n+use clap_noun_verb_macros::{noun, verb};\n+use serde::Serialize;\n+\n+// Business Logic Layer (Pure Functions - Reusable)\n+\n+fn get_service_status() -> ServiceStatus {\n+    ServiceStatus {\n+        services: vec![\n+            ServiceInfo {\n+                name: \"web-server\".to_string(),\n+                state: \"Running\".to_string(),\n+                port: 8080,\n+            },\n+            ServiceInfo { name: \"database\".to_string(), state: \"Running\".to_string(), port: 5432 },\n+            ServiceInfo { name: \"redis\".to_string(), state: \"Running\".to_string(), port: 6379 },\n+        ],\n+    }\n+}\n+\n+fn get_service_logs(service: String) -> Logs {\n+    Logs {\n+        service: service.clone(),\n+        entries: vec![\n+            format!(\"[2024-01-01 10:00:00] INFO: {} started\", service),\n+            format!(\"[2024-01-01 10:00:01] INFO: {} listening\", service),\n+        ],\n+    }\n+}\n+\n+fn restart_service(service: String) -> RestartResult {\n+    RestartResult { service, success: true }\n+}\n+\n+fn get_collector_status() -> CollectorStatus {\n+    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+fn start_collector() -> CollectorStatus {\n+    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+fn stop_collector() -> CollectorStatus {\n+    CollectorStatus { state: \"Stopped\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct ServiceInfo {\n+    name: String,\n+    state: String,\n+    port: u16,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct ServiceStatus {\n+    services: Vec<ServiceInfo>,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct Logs {\n+    service: String,\n+    entries: Vec<String>,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct RestartResult {\n+    service: String,\n+    success: bool,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct CollectorStatus {\n+    state: String,\n+    http_port: u16,\n+    grpc_port: u16,\n+}\n+\n+// CLI Layer (Input Validation + Output Shaping Only)\n+// All business logic is separated into pure functions above\n+\n+/// Show status of all services\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"status\" auto-inferred from function name\n+fn show_status() -> Result<ServiceStatus> {\n+    Ok(get_service_status())\n+}\n+\n+/// Show logs for a service\n+///\n+/// # Arguments\n+/// * `service` - Service name\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"logs\" auto-inferred, noun \"services\" auto-detected\n+fn show_logs(service: String) -> Result<Logs> {\n+    Ok(get_service_logs(service))\n+}\n+\n+/// Restart a service\n+///\n+/// # Arguments\n+/// * `service` - Service name to restart\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"restart\" auto-inferred, noun \"services\" auto-detected\n+fn restart_service_cmd(service: String) -> Result<RestartResult> {\n+    Ok(restart_service(service))\n+}\n+\n+/// Start the collector\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb(\"up\")] // Custom verb name (not inferrable from function name)\n+fn start_collector_cmd() -> Result<CollectorStatus> {\n+    Ok(start_collector())\n+}\n+\n+/// Stop the collector\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb(\"down\")] // Custom verb name\n+fn stop_collector_cmd() -> Result<CollectorStatus> {\n+    Ok(stop_collector())\n+}\n+\n+/// Show collector status\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb] // Verb name \"status\" auto-inferred, noun \"collector\" auto-detected\n+fn show_collector_status() -> Result<CollectorStatus> {\n+    Ok(get_collector_status())\n+}\n+\n+fn main() -> Result<()> {\n+    // Auto-discover all registered commands and run\n+    // The framework automatically:\n+    // - Discovers all #[noun] and #[verb] functions\n+    // - Builds the CLI structure\n+    // - Handles argument parsing and validation\n+    // - Executes the appropriate handler\n+    // - Serializes output to JSON\n+    clap_noun_verb::run()\n+}\n"
                },
                {
                    "date": 1762035076779,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -141,167 +141,4 @@\n     // - Executes the appropriate handler\n     // - Serializes output to JSON\n     clap_noun_verb::run()\n }\n-//! Framework-level composition example using v3 attribute macro API\n-//!\n-//! This example demonstrates how to use clap-noun-verb v3's attribute macro API\n-//! for building composable CLI applications with automatic type inference,\n-//! JSON output, and separation of concerns.\n-\n-use clap_noun_verb::Result;\n-use clap_noun_verb_macros::{noun, verb};\n-use serde::Serialize;\n-\n-// Business Logic Layer (Pure Functions - Reusable)\n-\n-fn get_service_status() -> ServiceStatus {\n-    ServiceStatus {\n-        services: vec![\n-            ServiceInfo {\n-                name: \"web-server\".to_string(),\n-                state: \"Running\".to_string(),\n-                port: 8080,\n-            },\n-            ServiceInfo {\n-                name: \"database\".to_string(),\n-                state: \"Running\".to_string(),\n-                port: 5432,\n-            },\n-            ServiceInfo {\n-                name: \"redis\".to_string(),\n-                state: \"Running\".to_string(),\n-                port: 6379,\n-            },\n-        ],\n-    }\n-}\n-\n-fn get_service_logs(service: String) -> Logs {\n-    Logs {\n-        service: service.clone(),\n-        entries: vec![\n-            format!(\"[2024-01-01 10:00:00] INFO: {} started\", service),\n-            format!(\"[2024-01-01 10:00:01] INFO: {} listening\", service),\n-        ],\n-    }\n-}\n-\n-fn restart_service(service: String) -> RestartResult {\n-    RestartResult {\n-        service,\n-        success: true,\n-    }\n-}\n-\n-fn get_collector_status() -> CollectorStatus {\n-    CollectorStatus {\n-        state: \"Running\".to_string(),\n-        http_port: 4318,\n-        grpc_port: 4317,\n-    }\n-}\n-\n-fn start_collector() -> CollectorStatus {\n-    CollectorStatus {\n-        state: \"Running\".to_string(),\n-        http_port: 4318,\n-        grpc_port: 4317,\n-    }\n-}\n-\n-fn stop_collector() -> CollectorStatus {\n-    CollectorStatus {\n-        state: \"Stopped\".to_string(),\n-        http_port: 4318,\n-        grpc_port: 4317,\n-    }\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct ServiceInfo {\n-    name: String,\n-    state: String,\n-    port: u16,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct ServiceStatus {\n-    services: Vec<ServiceInfo>,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct Logs {\n-    service: String,\n-    entries: Vec<String>,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct RestartResult {\n-    service: String,\n-    success: bool,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct CollectorStatus {\n-    state: String,\n-    http_port: u16,\n-    grpc_port: u16,\n-}\n-\n-// CLI Layer (Input Validation + Output Shaping Only)\n-// All business logic is separated into pure functions above\n-\n-/// Show status of all services\n-#[noun(\"services\", \"Manage application services\")]\n-#[verb(\"status\")]\n-fn show_status() -> Result<ServiceStatus> {\n-    Ok(get_service_status())\n-}\n-\n-/// Show logs for a service\n-///\n-/// # Arguments\n-/// * `service` - Service name\n-#[verb(\"logs\", \"services\")]\n-fn show_logs(service: String) -> Result<Logs> {\n-    Ok(get_service_logs(service))\n-}\n-\n-/// Restart a service\n-///\n-/// # Arguments\n-/// * `service` - Service name to restart\n-#[verb(\"restart\", \"services\")]\n-fn restart_service_cmd(service: String) -> Result<RestartResult> {\n-    Ok(restart_service(service))\n-}\n-\n-/// Start the collector\n-#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n-#[verb(\"up\")]\n-fn start_collector_cmd() -> Result<CollectorStatus> {\n-    Ok(start_collector())\n-}\n-\n-/// Stop the collector\n-#[verb(\"down\", \"collector\")]\n-fn stop_collector_cmd() -> Result<CollectorStatus> {\n-    Ok(stop_collector())\n-}\n-\n-/// Show collector status\n-#[verb(\"status\", \"collector\")]\n-fn show_collector_status() -> Result<CollectorStatus> {\n-    Ok(get_collector_status())\n-}\n-\n-fn main() -> Result<()> {\n-    // Auto-discover all registered commands and run\n-    // The framework automatically:\n-    // - Discovers all #[noun] and #[verb] functions\n-    // - Builds the CLI structure\n-    // - Handles argument parsing and validation\n-    // - Executes the appropriate handler\n-    // - Serializes output to JSON\n-    clap_noun_verb::run()\n-}\n"
                },
                {
                    "date": 1762035131490,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,144 @@\n+//! Framework-level composition example using v3 attribute macro API\n+//!\n+//! This example demonstrates how to use clap-noun-verb v3's attribute macro API\n+//! for building composable CLI applications with automatic type inference,\n+//! JSON output, and separation of concerns.\n+\n+use clap_noun_verb::Result;\n+use clap_noun_verb_macros::{noun, verb};\n+use serde::Serialize;\n+\n+// Business Logic Layer (Pure Functions - Reusable)\n+\n+fn get_service_status() -> ServiceStatus {\n+    ServiceStatus {\n+        services: vec![\n+            ServiceInfo {\n+                name: \"web-server\".to_string(),\n+                state: \"Running\".to_string(),\n+                port: 8080,\n+            },\n+            ServiceInfo { name: \"database\".to_string(), state: \"Running\".to_string(), port: 5432 },\n+            ServiceInfo { name: \"redis\".to_string(), state: \"Running\".to_string(), port: 6379 },\n+        ],\n+    }\n+}\n+\n+fn get_service_logs(service: String) -> Logs {\n+    Logs {\n+        service: service.clone(),\n+        entries: vec![\n+            format!(\"[2024-01-01 10:00:00] INFO: {} started\", service),\n+            format!(\"[2024-01-01 10:00:01] INFO: {} listening\", service),\n+        ],\n+    }\n+}\n+\n+fn restart_service(service: String) -> RestartResult {\n+    RestartResult { service, success: true }\n+}\n+\n+fn get_collector_status() -> CollectorStatus {\n+    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+fn start_collector() -> CollectorStatus {\n+    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+fn stop_collector() -> CollectorStatus {\n+    CollectorStatus { state: \"Stopped\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct ServiceInfo {\n+    name: String,\n+    state: String,\n+    port: u16,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct ServiceStatus {\n+    services: Vec<ServiceInfo>,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct Logs {\n+    service: String,\n+    entries: Vec<String>,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct RestartResult {\n+    service: String,\n+    success: bool,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct CollectorStatus {\n+    state: String,\n+    http_port: u16,\n+    grpc_port: u16,\n+}\n+\n+// CLI Layer (Input Validation + Output Shaping Only)\n+// All business logic is separated into pure functions above\n+\n+/// Show status of all services\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"status\" auto-inferred from function name\n+fn show_status() -> Result<ServiceStatus> {\n+    Ok(get_service_status())\n+}\n+\n+/// Show logs for a service\n+///\n+/// # Arguments\n+/// * `service` - Service name\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"logs\" auto-inferred, noun \"services\" auto-detected\n+fn show_logs(service: String) -> Result<Logs> {\n+    Ok(get_service_logs(service))\n+}\n+\n+/// Restart a service\n+///\n+/// # Arguments\n+/// * `service` - Service name to restart\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"restart\" auto-inferred, noun \"services\" auto-detected\n+fn restart_service_cmd(service: String) -> Result<RestartResult> {\n+    Ok(restart_service(service))\n+}\n+\n+/// Start the collector\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb(\"up\")] // Custom verb name (not inferrable from function name)\n+fn start_collector_cmd() -> Result<CollectorStatus> {\n+    Ok(start_collector())\n+}\n+\n+/// Stop the collector\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb(\"down\")] // Custom verb name\n+fn stop_collector_cmd() -> Result<CollectorStatus> {\n+    Ok(stop_collector())\n+}\n+\n+/// Show collector status\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb] // Verb name \"status\" auto-inferred, noun \"collector\" auto-detected\n+fn show_collector_status() -> Result<CollectorStatus> {\n+    Ok(get_collector_status())\n+}\n+\n+fn main() -> Result<()> {\n+    // Auto-discover all registered commands and run\n+    // The framework automatically:\n+    // - Discovers all #[noun] and #[verb] functions\n+    // - Builds the CLI structure\n+    // - Handles argument parsing and validation\n+    // - Executes the appropriate handler\n+    // - Serializes output to JSON\n+    clap_noun_verb::run()\n+}\n"
                },
                {
                    "date": 1762035217587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -141,148 +141,4 @@\n     // - Executes the appropriate handler\n     // - Serializes output to JSON\n     clap_noun_verb::run()\n }\n-//! Framework-level composition example using v3 attribute macro API\n-//!\n-//! This example demonstrates how to use clap-noun-verb v3's attribute macro API\n-//! for building composable CLI applications with automatic type inference,\n-//! JSON output, and separation of concerns.\n-\n-use clap_noun_verb::Result;\n-use clap_noun_verb_macros::{noun, verb};\n-use serde::Serialize;\n-\n-// Business Logic Layer (Pure Functions - Reusable)\n-\n-fn get_service_status() -> ServiceStatus {\n-    ServiceStatus {\n-        services: vec![\n-            ServiceInfo {\n-                name: \"web-server\".to_string(),\n-                state: \"Running\".to_string(),\n-                port: 8080,\n-            },\n-            ServiceInfo { name: \"database\".to_string(), state: \"Running\".to_string(), port: 5432 },\n-            ServiceInfo { name: \"redis\".to_string(), state: \"Running\".to_string(), port: 6379 },\n-        ],\n-    }\n-}\n-\n-fn get_service_logs(service: String) -> Logs {\n-    Logs {\n-        service: service.clone(),\n-        entries: vec![\n-            format!(\"[2024-01-01 10:00:00] INFO: {} started\", service),\n-            format!(\"[2024-01-01 10:00:01] INFO: {} listening\", service),\n-        ],\n-    }\n-}\n-\n-fn restart_service(service: String) -> RestartResult {\n-    RestartResult { service, success: true }\n-}\n-\n-fn get_collector_status() -> CollectorStatus {\n-    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n-}\n-\n-fn start_collector() -> CollectorStatus {\n-    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n-}\n-\n-fn stop_collector() -> CollectorStatus {\n-    CollectorStatus { state: \"Stopped\".to_string(), http_port: 4318, grpc_port: 4317 }\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct ServiceInfo {\n-    name: String,\n-    state: String,\n-    port: u16,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct ServiceStatus {\n-    services: Vec<ServiceInfo>,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct Logs {\n-    service: String,\n-    entries: Vec<String>,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct RestartResult {\n-    service: String,\n-    success: bool,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct CollectorStatus {\n-    state: String,\n-    http_port: u16,\n-    grpc_port: u16,\n-}\n-\n-// CLI Layer (Input Validation + Output Shaping Only)\n-// All business logic is separated into pure functions above\n-\n-/// Show status of all services\n-#[noun(\"services\", \"Manage application services\")]\n-#[verb] // Verb name \"status\" auto-inferred from function name\n-fn show_status() -> Result<ServiceStatus> {\n-    Ok(get_service_status())\n-}\n-\n-/// Show logs for a service\n-///\n-/// # Arguments\n-/// * `service` - Service name\n-#[noun(\"services\", \"Manage application services\")]\n-#[verb] // Verb name \"logs\" auto-inferred, noun \"services\" auto-detected\n-fn show_logs(service: String) -> Result<Logs> {\n-    Ok(get_service_logs(service))\n-}\n-\n-/// Restart a service\n-///\n-/// # Arguments\n-/// * `service` - Service name to restart\n-#[noun(\"services\", \"Manage application services\")]\n-#[verb] // Verb name \"restart\" auto-inferred, noun \"services\" auto-detected\n-fn restart_service_cmd(service: String) -> Result<RestartResult> {\n-    Ok(restart_service(service))\n-}\n-\n-/// Start the collector\n-#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n-#[verb(\"up\")] // Custom verb name (not inferrable from function name)\n-fn start_collector_cmd() -> Result<CollectorStatus> {\n-    Ok(start_collector())\n-}\n-\n-/// Stop the collector\n-#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n-#[verb(\"down\")] // Custom verb name\n-fn stop_collector_cmd() -> Result<CollectorStatus> {\n-    Ok(stop_collector())\n-}\n-\n-/// Show collector status\n-#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n-#[verb] // Verb name \"status\" auto-inferred, noun \"collector\" auto-detected\n-fn show_collector_status() -> Result<CollectorStatus> {\n-    Ok(get_collector_status())\n-}\n-\n-fn main() -> Result<()> {\n-    // Auto-discover all registered commands and run\n-    // The framework automatically:\n-    // - Discovers all #[noun] and #[verb] functions\n-    // - Builds the CLI structure\n-    // - Handles argument parsing and validation\n-    // - Executes the appropriate handler\n-    // - Serializes output to JSON\n-    clap_noun_verb::run()\n-}\n"
                },
                {
                    "date": 1762035225868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,144 @@\n+//! Framework-level composition example using v3 attribute macro API\n+//!\n+//! This example demonstrates how to use clap-noun-verb v3's attribute macro API\n+//! for building composable CLI applications with automatic type inference,\n+//! JSON output, and separation of concerns.\n+\n+use clap_noun_verb::Result;\n+use clap_noun_verb_macros::{noun, verb};\n+use serde::Serialize;\n+\n+// Business Logic Layer (Pure Functions - Reusable)\n+\n+fn get_service_status() -> ServiceStatus {\n+    ServiceStatus {\n+        services: vec![\n+            ServiceInfo {\n+                name: \"web-server\".to_string(),\n+                state: \"Running\".to_string(),\n+                port: 8080,\n+            },\n+            ServiceInfo { name: \"database\".to_string(), state: \"Running\".to_string(), port: 5432 },\n+            ServiceInfo { name: \"redis\".to_string(), state: \"Running\".to_string(), port: 6379 },\n+        ],\n+    }\n+}\n+\n+fn get_service_logs(service: String) -> Logs {\n+    Logs {\n+        service: service.clone(),\n+        entries: vec![\n+            format!(\"[2024-01-01 10:00:00] INFO: {} started\", service),\n+            format!(\"[2024-01-01 10:00:01] INFO: {} listening\", service),\n+        ],\n+    }\n+}\n+\n+fn restart_service(service: String) -> RestartResult {\n+    RestartResult { service, success: true }\n+}\n+\n+fn get_collector_status() -> CollectorStatus {\n+    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+fn start_collector() -> CollectorStatus {\n+    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+fn stop_collector() -> CollectorStatus {\n+    CollectorStatus { state: \"Stopped\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct ServiceInfo {\n+    name: String,\n+    state: String,\n+    port: u16,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct ServiceStatus {\n+    services: Vec<ServiceInfo>,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct Logs {\n+    service: String,\n+    entries: Vec<String>,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct RestartResult {\n+    service: String,\n+    success: bool,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct CollectorStatus {\n+    state: String,\n+    http_port: u16,\n+    grpc_port: u16,\n+}\n+\n+// CLI Layer (Input Validation + Output Shaping Only)\n+// All business logic is separated into pure functions above\n+\n+/// Show status of all services\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"status\" auto-inferred from function name\n+fn show_status() -> Result<ServiceStatus> {\n+    Ok(get_service_status())\n+}\n+\n+/// Show logs for a service\n+///\n+/// # Arguments\n+/// * `service` - Service name\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"logs\" auto-inferred, noun \"services\" auto-detected\n+fn show_logs(service: String) -> Result<Logs> {\n+    Ok(get_service_logs(service))\n+}\n+\n+/// Restart a service\n+///\n+/// # Arguments\n+/// * `service` - Service name to restart\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"restart\" auto-inferred, noun \"services\" auto-detected\n+fn restart_service_cmd(service: String) -> Result<RestartResult> {\n+    Ok(restart_service(service))\n+}\n+\n+/// Start the collector\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb(\"up\")] // Custom verb name (not inferrable from function name)\n+fn start_collector_cmd() -> Result<CollectorStatus> {\n+    Ok(start_collector())\n+}\n+\n+/// Stop the collector\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb(\"down\")] // Custom verb name\n+fn stop_collector_cmd() -> Result<CollectorStatus> {\n+    Ok(stop_collector())\n+}\n+\n+/// Show collector status\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb] // Verb name \"status\" auto-inferred, noun \"collector\" auto-detected\n+fn show_collector_status() -> Result<CollectorStatus> {\n+    Ok(get_collector_status())\n+}\n+\n+fn main() -> Result<()> {\n+    // Auto-discover all registered commands and run\n+    // The framework automatically:\n+    // - Discovers all #[noun] and #[verb] functions\n+    // - Builds the CLI structure\n+    // - Handles argument parsing and validation\n+    // - Executes the appropriate handler\n+    // - Serializes output to JSON\n+    clap_noun_verb::run()\n+}\n"
                },
                {
                    "date": 1762035357718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,144 @@\n+//! Framework-level composition example using v3 attribute macro API\n+//!\n+//! This example demonstrates how to use clap-noun-verb v3's attribute macro API\n+//! for building composable CLI applications with automatic type inference,\n+//! JSON output, and separation of concerns.\n+\n+use clap_noun_verb::Result;\n+use clap_noun_verb_macros::{noun, verb};\n+use serde::Serialize;\n+\n+// Business Logic Layer (Pure Functions - Reusable)\n+\n+fn get_service_status() -> ServiceStatus {\n+    ServiceStatus {\n+        services: vec![\n+            ServiceInfo {\n+                name: \"web-server\".to_string(),\n+                state: \"Running\".to_string(),\n+                port: 8080,\n+            },\n+            ServiceInfo { name: \"database\".to_string(), state: \"Running\".to_string(), port: 5432 },\n+            ServiceInfo { name: \"redis\".to_string(), state: \"Running\".to_string(), port: 6379 },\n+        ],\n+    }\n+}\n+\n+fn get_service_logs(service: String) -> Logs {\n+    Logs {\n+        service: service.clone(),\n+        entries: vec![\n+            format!(\"[2024-01-01 10:00:00] INFO: {} started\", service),\n+            format!(\"[2024-01-01 10:00:01] INFO: {} listening\", service),\n+        ],\n+    }\n+}\n+\n+fn restart_service(service: String) -> RestartResult {\n+    RestartResult { service, success: true }\n+}\n+\n+fn get_collector_status() -> CollectorStatus {\n+    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+fn start_collector() -> CollectorStatus {\n+    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+fn stop_collector() -> CollectorStatus {\n+    CollectorStatus { state: \"Stopped\".to_string(), http_port: 4318, grpc_port: 4317 }\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct ServiceInfo {\n+    name: String,\n+    state: String,\n+    port: u16,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct ServiceStatus {\n+    services: Vec<ServiceInfo>,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct Logs {\n+    service: String,\n+    entries: Vec<String>,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct RestartResult {\n+    service: String,\n+    success: bool,\n+}\n+\n+#[derive(Serialize, Debug)]\n+struct CollectorStatus {\n+    state: String,\n+    http_port: u16,\n+    grpc_port: u16,\n+}\n+\n+// CLI Layer (Input Validation + Output Shaping Only)\n+// All business logic is separated into pure functions above\n+\n+/// Show status of all services\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"status\" auto-inferred from function name\n+fn show_status() -> Result<ServiceStatus> {\n+    Ok(get_service_status())\n+}\n+\n+/// Show logs for a service\n+///\n+/// # Arguments\n+/// * `service` - Service name\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"logs\" auto-inferred, noun \"services\" auto-detected\n+fn show_logs(service: String) -> Result<Logs> {\n+    Ok(get_service_logs(service))\n+}\n+\n+/// Restart a service\n+///\n+/// # Arguments\n+/// * `service` - Service name to restart\n+#[noun(\"services\", \"Manage application services\")]\n+#[verb] // Verb name \"restart\" auto-inferred, noun \"services\" auto-detected\n+fn restart_service_cmd(service: String) -> Result<RestartResult> {\n+    Ok(restart_service(service))\n+}\n+\n+/// Start the collector\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb(\"up\")] // Custom verb name (not inferrable from function name)\n+fn start_collector_cmd() -> Result<CollectorStatus> {\n+    Ok(start_collector())\n+}\n+\n+/// Stop the collector\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb(\"down\")] // Custom verb name\n+fn stop_collector_cmd() -> Result<CollectorStatus> {\n+    Ok(stop_collector())\n+}\n+\n+/// Show collector status\n+#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n+#[verb] // Verb name \"status\" auto-inferred, noun \"collector\" auto-detected\n+fn show_collector_status() -> Result<CollectorStatus> {\n+    Ok(get_collector_status())\n+}\n+\n+fn main() -> Result<()> {\n+    // Auto-discover all registered commands and run\n+    // The framework automatically:\n+    // - Discovers all #[noun] and #[verb] functions\n+    // - Builds the CLI structure\n+    // - Handles argument parsing and validation\n+    // - Executes the appropriate handler\n+    // - Serializes output to JSON\n+    clap_noun_verb::run()\n+}\n"
                },
                {
                    "date": 1762035440778,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -141,292 +141,4 @@\n     // - Executes the appropriate handler\n     // - Serializes output to JSON\n     clap_noun_verb::run()\n }\n-//! Framework-level composition example using v3 attribute macro API\n-//!\n-//! This example demonstrates how to use clap-noun-verb v3's attribute macro API\n-//! for building composable CLI applications with automatic type inference,\n-//! JSON output, and separation of concerns.\n-\n-use clap_noun_verb::Result;\n-use clap_noun_verb_macros::{noun, verb};\n-use serde::Serialize;\n-\n-// Business Logic Layer (Pure Functions - Reusable)\n-\n-fn get_service_status() -> ServiceStatus {\n-    ServiceStatus {\n-        services: vec![\n-            ServiceInfo {\n-                name: \"web-server\".to_string(),\n-                state: \"Running\".to_string(),\n-                port: 8080,\n-            },\n-            ServiceInfo { name: \"database\".to_string(), state: \"Running\".to_string(), port: 5432 },\n-            ServiceInfo { name: \"redis\".to_string(), state: \"Running\".to_string(), port: 6379 },\n-        ],\n-    }\n-}\n-\n-fn get_service_logs(service: String) -> Logs {\n-    Logs {\n-        service: service.clone(),\n-        entries: vec![\n-            format!(\"[2024-01-01 10:00:00] INFO: {} started\", service),\n-            format!(\"[2024-01-01 10:00:01] INFO: {} listening\", service),\n-        ],\n-    }\n-}\n-\n-fn restart_service(service: String) -> RestartResult {\n-    RestartResult { service, success: true }\n-}\n-\n-fn get_collector_status() -> CollectorStatus {\n-    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n-}\n-\n-fn start_collector() -> CollectorStatus {\n-    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n-}\n-\n-fn stop_collector() -> CollectorStatus {\n-    CollectorStatus { state: \"Stopped\".to_string(), http_port: 4318, grpc_port: 4317 }\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct ServiceInfo {\n-    name: String,\n-    state: String,\n-    port: u16,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct ServiceStatus {\n-    services: Vec<ServiceInfo>,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct Logs {\n-    service: String,\n-    entries: Vec<String>,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct RestartResult {\n-    service: String,\n-    success: bool,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct CollectorStatus {\n-    state: String,\n-    http_port: u16,\n-    grpc_port: u16,\n-}\n-\n-// CLI Layer (Input Validation + Output Shaping Only)\n-// All business logic is separated into pure functions above\n-\n-/// Show status of all services\n-#[noun(\"services\", \"Manage application services\")]\n-#[verb] // Verb name \"status\" auto-inferred from function name\n-fn show_status() -> Result<ServiceStatus> {\n-    Ok(get_service_status())\n-}\n-\n-/// Show logs for a service\n-///\n-/// # Arguments\n-/// * `service` - Service name\n-#[noun(\"services\", \"Manage application services\")]\n-#[verb] // Verb name \"logs\" auto-inferred, noun \"services\" auto-detected\n-fn show_logs(service: String) -> Result<Logs> {\n-    Ok(get_service_logs(service))\n-}\n-\n-/// Restart a service\n-///\n-/// # Arguments\n-/// * `service` - Service name to restart\n-#[noun(\"services\", \"Manage application services\")]\n-#[verb] // Verb name \"restart\" auto-inferred, noun \"services\" auto-detected\n-fn restart_service_cmd(service: String) -> Result<RestartResult> {\n-    Ok(restart_service(service))\n-}\n-\n-/// Start the collector\n-#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n-#[verb(\"up\")] // Custom verb name (not inferrable from function name)\n-fn start_collector_cmd() -> Result<CollectorStatus> {\n-    Ok(start_collector())\n-}\n-\n-/// Stop the collector\n-#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n-#[verb(\"down\")] // Custom verb name\n-fn stop_collector_cmd() -> Result<CollectorStatus> {\n-    Ok(stop_collector())\n-}\n-\n-/// Show collector status\n-#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n-#[verb] // Verb name \"status\" auto-inferred, noun \"collector\" auto-detected\n-fn show_collector_status() -> Result<CollectorStatus> {\n-    Ok(get_collector_status())\n-}\n-\n-fn main() -> Result<()> {\n-    // Auto-discover all registered commands and run\n-    // The framework automatically:\n-    // - Discovers all #[noun] and #[verb] functions\n-    // - Builds the CLI structure\n-    // - Handles argument parsing and validation\n-    // - Executes the appropriate handler\n-    // - Serializes output to JSON\n-    clap_noun_verb::run()\n-}\n-//! Framework-level composition example using v3 attribute macro API\n-//!\n-//! This example demonstrates how to use clap-noun-verb v3's attribute macro API\n-//! for building composable CLI applications with automatic type inference,\n-//! JSON output, and separation of concerns.\n-\n-use clap_noun_verb::Result;\n-use clap_noun_verb_macros::{noun, verb};\n-use serde::Serialize;\n-\n-// Business Logic Layer (Pure Functions - Reusable)\n-\n-fn get_service_status() -> ServiceStatus {\n-    ServiceStatus {\n-        services: vec![\n-            ServiceInfo {\n-                name: \"web-server\".to_string(),\n-                state: \"Running\".to_string(),\n-                port: 8080,\n-            },\n-            ServiceInfo { name: \"database\".to_string(), state: \"Running\".to_string(), port: 5432 },\n-            ServiceInfo { name: \"redis\".to_string(), state: \"Running\".to_string(), port: 6379 },\n-        ],\n-    }\n-}\n-\n-fn get_service_logs(service: String) -> Logs {\n-    Logs {\n-        service: service.clone(),\n-        entries: vec![\n-            format!(\"[2024-01-01 10:00:00] INFO: {} started\", service),\n-            format!(\"[2024-01-01 10:00:01] INFO: {} listening\", service),\n-        ],\n-    }\n-}\n-\n-fn restart_service(service: String) -> RestartResult {\n-    RestartResult { service, success: true }\n-}\n-\n-fn get_collector_status() -> CollectorStatus {\n-    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n-}\n-\n-fn start_collector() -> CollectorStatus {\n-    CollectorStatus { state: \"Running\".to_string(), http_port: 4318, grpc_port: 4317 }\n-}\n-\n-fn stop_collector() -> CollectorStatus {\n-    CollectorStatus { state: \"Stopped\".to_string(), http_port: 4318, grpc_port: 4317 }\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct ServiceInfo {\n-    name: String,\n-    state: String,\n-    port: u16,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct ServiceStatus {\n-    services: Vec<ServiceInfo>,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct Logs {\n-    service: String,\n-    entries: Vec<String>,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct RestartResult {\n-    service: String,\n-    success: bool,\n-}\n-\n-#[derive(Serialize, Debug)]\n-struct CollectorStatus {\n-    state: String,\n-    http_port: u16,\n-    grpc_port: u16,\n-}\n-\n-// CLI Layer (Input Validation + Output Shaping Only)\n-// All business logic is separated into pure functions above\n-\n-/// Show status of all services\n-#[noun(\"services\", \"Manage application services\")]\n-#[verb] // Verb name \"status\" auto-inferred from function name\n-fn show_status() -> Result<ServiceStatus> {\n-    Ok(get_service_status())\n-}\n-\n-/// Show logs for a service\n-///\n-/// # Arguments\n-/// * `service` - Service name\n-#[noun(\"services\", \"Manage application services\")]\n-#[verb] // Verb name \"logs\" auto-inferred, noun \"services\" auto-detected\n-fn show_logs(service: String) -> Result<Logs> {\n-    Ok(get_service_logs(service))\n-}\n-\n-/// Restart a service\n-///\n-/// # Arguments\n-/// * `service` - Service name to restart\n-#[noun(\"services\", \"Manage application services\")]\n-#[verb] // Verb name \"restart\" auto-inferred, noun \"services\" auto-detected\n-fn restart_service_cmd(service: String) -> Result<RestartResult> {\n-    Ok(restart_service(service))\n-}\n-\n-/// Start the collector\n-#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n-#[verb(\"up\")] // Custom verb name (not inferrable from function name)\n-fn start_collector_cmd() -> Result<CollectorStatus> {\n-    Ok(start_collector())\n-}\n-\n-/// Stop the collector\n-#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n-#[verb(\"down\")] // Custom verb name\n-fn stop_collector_cmd() -> Result<CollectorStatus> {\n-    Ok(stop_collector())\n-}\n-\n-/// Show collector status\n-#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n-#[verb] // Verb name \"status\" auto-inferred, noun \"collector\" auto-detected\n-fn show_collector_status() -> Result<CollectorStatus> {\n-    Ok(get_collector_status())\n-}\n-\n-fn main() -> Result<()> {\n-    // Auto-discover all registered commands and run\n-    // The framework automatically:\n-    // - Discovers all #[noun] and #[verb] functions\n-    // - Builds the CLI structure\n-    // - Handles argument parsing and validation\n-    // - Executes the appropriate handler\n-    // - Serializes output to JSON\n-    clap_noun_verb::run()\n-}\n"
                }
            ],
            "date": 1762034411361,
            "name": "Commit-0",
            "content": "//! Framework-level composition example using v3 attribute macro API\n//!\n//! This example demonstrates how to use clap-noun-verb v3's attribute macro API\n//! for building composable CLI applications with automatic type inference,\n//! JSON output, and separation of concerns.\n\nuse clap_noun_verb::Result;\nuse clap_noun_verb_macros::{noun, verb};\nuse serde::Serialize;\n\n// Business Logic Layer (Pure Functions - Reusable)\n\nfn get_service_status() -> ServiceStatus {\n    ServiceStatus {\n        services: vec![\n            ServiceInfo {\n                name: \"web-server\".to_string(),\n                state: \"Running\".to_string(),\n                port: 8080,\n            },\n            ServiceInfo {\n                name: \"database\".to_string(),\n                state: \"Running\".to_string(),\n                port: 5432,\n            },\n            ServiceInfo {\n                name: \"redis\".to_string(),\n                state: \"Running\".to_string(),\n                port: 6379,\n            },\n        ],\n    }\n}\n\nfn get_service_logs(service: String) -> Logs {\n    Logs {\n        service: service.clone(),\n        entries: vec![\n            format!(\"[2024-01-01 10:00:00] INFO: {} started\", service),\n            format!(\"[2024-01-01 10:00:01] INFO: {} listening\", service),\n        ],\n    }\n}\n\nfn restart_service(service: String) -> RestartResult {\n    RestartResult {\n        service,\n        success: true,\n    }\n}\n\nfn get_collector_status() -> CollectorStatus {\n    CollectorStatus {\n        state: \"Running\".to_string(),\n        http_port: 4318,\n        grpc_port: 4317,\n    }\n}\n\nfn start_collector() -> CollectorStatus {\n    CollectorStatus {\n        state: \"Running\".to_string(),\n        http_port: 4318,\n        grpc_port: 4317,\n    }\n}\n\nfn stop_collector() -> CollectorStatus {\n    CollectorStatus {\n        state: \"Stopped\".to_string(),\n        http_port: 4318,\n        grpc_port: 4317,\n    }\n}\n\n#[derive(Serialize, Debug)]\nstruct ServiceInfo {\n    name: String,\n    state: String,\n    port: u16,\n}\n\n#[derive(Serialize, Debug)]\nstruct ServiceStatus {\n    services: Vec<ServiceInfo>,\n}\n\n#[derive(Serialize, Debug)]\nstruct Logs {\n    service: String,\n    entries: Vec<String>,\n}\n\n#[derive(Serialize, Debug)]\nstruct RestartResult {\n    service: String,\n    success: bool,\n}\n\n#[derive(Serialize, Debug)]\nstruct CollectorStatus {\n    state: String,\n    http_port: u16,\n    grpc_port: u16,\n}\n\n// CLI Layer (Input Validation + Output Shaping Only)\n// All business logic is separated into pure functions above\n\n/// Show status of all services\n#[noun(\"services\", \"Manage application services\")]\n#[verb(\"status\")]\nfn show_status() -> Result<ServiceStatus> {\n    Ok(get_service_status())\n}\n\n/// Show logs for a service\n///\n/// # Arguments\n/// * `service` - Service name\n#[verb(\"logs\", \"services\")]\nfn show_logs(service: String) -> Result<Logs> {\n    Ok(get_service_logs(service))\n}\n\n/// Restart a service\n///\n/// # Arguments\n/// * `service` - Service name to restart\n#[verb(\"restart\", \"services\")]\nfn restart_service_cmd(service: String) -> Result<RestartResult> {\n    Ok(restart_service(service))\n}\n\n/// Start the collector\n#[noun(\"collector\", \"Manage OpenTelemetry collector\")]\n#[verb(\"up\")]\nfn start_collector_cmd() -> Result<CollectorStatus> {\n    Ok(start_collector())\n}\n\n/// Stop the collector\n#[verb(\"down\", \"collector\")]\nfn stop_collector_cmd() -> Result<CollectorStatus> {\n    Ok(stop_collector())\n}\n\n/// Show collector status\n#[verb(\"status\", \"collector\")]\nfn show_collector_status() -> Result<CollectorStatus> {\n    Ok(get_collector_status())\n}\n\nfn main() -> Result<()> {\n    // Auto-discover all registered commands and run\n    // The framework automatically:\n    // - Discovers all #[noun] and #[verb] functions\n    // - Builds the CLI structure\n    // - Handles argument parsing and validation\n    // - Executes the appropriate handler\n    // - Serializes output to JSON\n    clap_noun_verb::run()\n}\n"
        }
    ]
}