{
    "sourceFile": "src/error.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762034186812,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762034186812,
            "name": "Commit-0",
            "content": "//! Error types for clap-noun-verb\n\nuse thiserror::Error;\n\n/// Errors that can occur in the noun-verb CLI framework\n#[derive(Error, Debug)]\npub enum NounVerbError {\n    /// Command not found\n    #[error(\"Command '{noun}' not found\")]\n    CommandNotFound { noun: String },\n\n    /// Verb not found for a given noun\n    #[error(\"Verb '{verb}' not found for noun '{noun}'\")]\n    VerbNotFound { noun: String, verb: String },\n\n    /// Invalid command structure\n    #[error(\"Invalid command structure: {message}\")]\n    InvalidStructure { message: String },\n\n    /// Command execution error\n    #[error(\"Command execution failed: {message}\")]\n    ExecutionError { message: String },\n\n    /// Argument parsing error\n    #[error(\"Argument parsing failed: {message}\")]\n    ArgumentError { message: String },\n\n    /// Generic error wrapper\n    #[error(\"Error: {0}\")]\n    Generic(String),\n}\n\nimpl NounVerbError {\n    /// Create a command not found error\n    pub fn command_not_found(noun: impl Into<String>) -> Self {\n        Self::CommandNotFound { noun: noun.into() }\n    }\n\n    /// Create a verb not found error\n    pub fn verb_not_found(noun: impl Into<String>, verb: impl Into<String>) -> Self {\n        Self::VerbNotFound { noun: noun.into(), verb: verb.into() }\n    }\n\n    /// Create an invalid structure error\n    pub fn invalid_structure(message: impl Into<String>) -> Self {\n        Self::InvalidStructure { message: message.into() }\n    }\n\n    /// Create an execution error\n    pub fn execution_error(message: impl Into<String>) -> Self {\n        Self::ExecutionError { message: message.into() }\n    }\n\n    /// Create an argument error\n    pub fn argument_error(message: impl Into<String>) -> Self {\n        Self::ArgumentError { message: message.into() }\n    }\n\n    /// Create a missing argument error (helper for common case)\n    pub fn missing_argument(name: impl Into<String>) -> Self {\n        Self::ArgumentError { message: format!(\"Required argument '{}' is missing\", name.into()) }\n    }\n\n    /// Create a validation error with constraints\n    pub fn validation_error(\n        name: impl Into<String>,\n        value: impl Into<String>,\n        constraints: Option<&str>,\n    ) -> Self {\n        let name = name.into();\n        let value = value.into();\n        if let Some(constraints) = constraints {\n            Self::ArgumentError {\n                message: format!(\n                    \"Invalid value '{}' for argument '{}'. {}\",\n                    value, name, constraints\n                ),\n            }\n        } else {\n            Self::ArgumentError {\n                message: format!(\"Invalid value '{}' for argument '{}'\", value, name),\n            }\n        }\n    }\n\n    /// Create a validation error with range constraints\n    pub fn validation_range_error(\n        name: impl Into<String>,\n        value: impl Into<String>,\n        min: Option<&str>,\n        max: Option<&str>,\n    ) -> Self {\n        let name = name.into();\n        let value = value.into();\n        let constraint_msg = match (min, max) {\n            (Some(min), Some(max)) => format!(\"Must be between {} and {}\", min, max),\n            (Some(min), None) => format!(\"Must be >= {}\", min),\n            (None, Some(max)) => format!(\"Must be <= {}\", max),\n            (None, None) => \"Invalid value\".to_string(),\n        };\n        Self::validation_error(name, value, Some(&constraint_msg))\n    }\n\n    /// Create a validation error with length constraints\n    pub fn validation_length_error(\n        name: impl Into<String>,\n        value: impl Into<String>,\n        min: Option<usize>,\n        max: Option<usize>,\n    ) -> Self {\n        let name = name.into();\n        let value = value.into();\n        let constraint_msg = match (min, max) {\n            (Some(min), Some(max)) => format!(\"Length must be between {} and {} characters\", min, max),\n            (Some(min), None) => format!(\"Length must be at least {} characters\", min),\n            (None, Some(max)) => format!(\"Length must be at most {} characters\", max),\n            (None, None) => \"Invalid length\".to_string(),\n        };\n        Self::validation_error(name, value, Some(&constraint_msg))\n    }\n}\n\n/// Result type alias for noun-verb operations\npub type Result<T> = std::result::Result<T, NounVerbError>;\n"
        }
    ]
}