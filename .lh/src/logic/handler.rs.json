{
    "sourceFile": "src/logic/handler.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762037755634,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762037755634,
            "name": "Commit-0",
            "content": "//! Command handlers - bridge between CLI and business logic\n//!\n//! Command handlers accept validated arguments from the CLI layer and\n//! delegate to core business logic functions.\n\nuse crate::error::Result;\n\n/// Trait for command handlers that delegate to business logic\n///\n/// Handlers validate inputs and delegate to pure business logic functions.\n/// This separates CLI concerns from business logic.\npub trait CommandHandler: Send + Sync {\n    /// Execute the command with validated inputs\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if command execution fails.\n    fn execute(&self, input: HandlerInput) -> Result<HandlerOutput>;\n}\n\n/// Input to a command handler (validated by CLI layer)\n#[derive(Debug, Clone)]\npub struct HandlerInput {\n    /// Validated arguments as key-value pairs\n    pub args: std::collections::HashMap<String, String>,\n    /// Validated options as key-value pairs\n    pub opts: std::collections::HashMap<String, String>,\n    /// Context information (noun, verb names, etc.)\n    pub context: HandlerContext,\n}\n\n/// Output from a command handler\n///\n/// In v3, output is automatically serialized to JSON for agent/MCP consumption.\n/// The `data` field contains any type that implements `Serialize`.\n#[derive(Debug, Clone)]\npub struct HandlerOutput {\n    /// Result data (auto-serialized to JSON)\n    pub data: serde_json::Value,\n    /// Success message (optional)\n    pub message: Option<String>,\n}\n\nimpl HandlerOutput {\n    /// Create a new handler output from any serializable type\n    pub fn from_data<T: serde::Serialize>(data: T) -> Result<Self> {\n        Ok(Self {\n            data: serde_json::to_value(data).map_err(|e| {\n                crate::error::NounVerbError::execution_error(format!(\n                    \"Failed to serialize output: {}\",\n                    e\n                ))\n            })?,\n            message: None,\n        })\n    }\n\n    /// Create output with a message\n    pub fn with_message(mut self, message: String) -> Self {\n        self.message = Some(message);\n        self\n    }\n\n    /// Serialize output to JSON string\n    pub fn to_json(&self) -> Result<String> {\n        serde_json::to_string(&self.data).map_err(|e| {\n            crate::error::NounVerbError::execution_error(format!(\n                \"Failed to serialize to JSON: {}\",\n                e\n            ))\n        })\n    }\n}\n\n/// Context information for handler execution\n#[derive(Debug, Clone)]\npub struct HandlerContext {\n    /// Noun name (if applicable)\n    pub noun: Option<String>,\n    /// Verb name\n    pub verb: String,\n    /// Additional context data\n    pub data: std::collections::HashMap<String, String>,\n}\n\nimpl HandlerContext {\n    /// Create a new handler context\n    pub fn new(verb: impl Into<String>) -> Self {\n        Self { noun: None, verb: verb.into(), data: std::collections::HashMap::new() }\n    }\n\n    /// Set the noun name\n    pub fn with_noun(mut self, noun: impl Into<String>) -> Self {\n        self.noun = Some(noun.into());\n        self\n    }\n\n    /// Add context data\n    pub fn with_data(mut self, key: impl Into<String>, value: impl Into<String>) -> Self {\n        self.data.insert(key.into(), value.into());\n        self\n    }\n}\n"
        }
    ]
}