{
    "sourceFile": "src/cli/router.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1762037755610,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1762037755610,
            "name": "Commit-0",
            "content": "//! CLI router - validation and delegation only\n//!\n//! This router enforces the pattern: validate arguments, then\n//! delegate to business logic. No business logic is executed here.\n\nuse crate::error::{NounVerbError, Result};\nuse crate::noun::NounCommand;\nuse crate::runtime::Executor;\nuse crate::verb::VerbCommand as LegacyVerbCommand;\nuse clap::ArgMatches;\nuse std::collections::HashMap;\n\n/// Router - validates and delegates only\n///\n/// This router enforces that CLI code can ONLY validate arguments\n/// and delegate to business logic. It does NOT execute business logic.\npub struct CommandRouter {\n    /// Nouns registered with the router\n    nouns: HashMap<String, Box<dyn NounCommand>>,\n    /// Executor for running commands with interceptors\n    #[allow(dead_code)] // Reserved for future use\n    executor: Executor,\n}\n\nimpl CommandRouter {\n    /// Create a new command router\n    pub fn new() -> Self {\n        Self { nouns: HashMap::new(), executor: Executor::new() }\n    }\n\n    /// Create a router with custom executor\n    pub fn with_executor(executor: Executor) -> Self {\n        Self { nouns: HashMap::new(), executor }\n    }\n\n    /// Register a noun command\n    pub fn register_noun(&mut self, noun: Box<dyn NounCommand>) {\n        self.nouns.insert(noun.name().to_string(), noun);\n    }\n\n    /// Route a command based on clap matches\n    ///\n    /// This method validates arguments and delegates to business logic.\n    /// It does NOT execute business logic directly.\n    pub fn route(&self, matches: &ArgMatches) -> Result<()> {\n        // Get the top-level subcommand (noun)\n        let (noun_name, noun_matches) = matches\n            .subcommand()\n            .ok_or_else(|| NounVerbError::invalid_structure(\"No subcommand found\"))?;\n\n        // Find the noun command\n        let noun =\n            self.nouns.get(noun_name).ok_or_else(|| NounVerbError::command_not_found(noun_name))?;\n\n        // Route the command recursively with root matches for global args\n        self.route_recursive(noun.as_ref(), noun_name, noun_matches, matches)\n    }\n\n    /// Recursively route commands through nested noun-verb structure\n    #[allow(clippy::only_used_in_recursion)]\n    fn route_recursive(\n        &self,\n        noun: &dyn NounCommand,\n        noun_name: &str,\n        matches: &ArgMatches,\n        root_matches: &ArgMatches,\n    ) -> Result<()> {\n        // Check if there's a subcommand (either verb or sub-noun)\n        if let Some((sub_name, sub_matches)) = matches.subcommand() {\n            // First check if it's a verb\n            if let Some(verb) = noun.verbs().iter().find(|v| v.name() == sub_name) {\n                // Validate args, then delegate to business logic\n                // Note: This requires VerbCommand trait with validate() and delegate()\n                self.route_legacy_verb(\n                    verb.as_ref(),\n                    sub_name,\n                    sub_matches,\n                    root_matches,\n                    noun_name,\n                )\n            } else if let Some(sub_noun) = noun.sub_nouns().iter().find(|n| n.name() == sub_name) {\n                // Recursively route to sub-noun, passing root matches for global args\n                self.route_recursive(sub_noun.as_ref(), sub_name, sub_matches, root_matches)\n            } else {\n                // Neither verb nor sub-noun found\n                Err(NounVerbError::verb_not_found(noun_name, sub_name))\n            }\n        } else {\n            // No subcommand, try direct noun execution\n            // Nouns validate and delegate through their handle_direct method\n            self.handle_direct_noun(noun, matches, noun_name)\n        }\n    }\n\n    /// Route a verb (for compatibility with existing verbs)\n    ///\n    /// This method handles verbs that still use the `run()` method.\n    /// Future implementation will use validate + delegate pattern.\n    fn route_legacy_verb(\n        &self,\n        verb: &dyn LegacyVerbCommand,\n        verb_name: &str,\n        sub_matches: &ArgMatches,\n        root_matches: &ArgMatches,\n        noun_name: &str,\n    ) -> Result<()> {\n        // Create VerbArgs for compatibility with legacy verb commands\n        use crate::verb::{VerbArgs, VerbContext};\n        let context = VerbContext::new(verb_name).with_noun(noun_name);\n        let args = VerbArgs::new(sub_matches.clone())\n            .with_parent(root_matches.clone())\n            .with_context(context);\n\n        // Execute verb (legacy pattern for backward compatibility)\n        verb.run(&args)\n    }\n\n    /// Handle direct noun execution\n    ///\n    /// Nouns validate and delegate to business logic through their handle_direct method.\n    fn handle_direct_noun(\n        &self,\n        noun: &dyn NounCommand,\n        matches: &ArgMatches,\n        noun_name: &str,\n    ) -> Result<()> {\n        // Nouns handle validation and delegation through handle_direct\n        use crate::verb::{VerbArgs, VerbContext};\n        let context = VerbContext::new(\"\").with_noun(noun_name);\n        let args = VerbArgs::new(matches.clone()).with_context(context);\n\n        noun.handle_direct(&args)\n    }\n}\n\nimpl Default for CommandRouter {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n"
        }
    ]
}