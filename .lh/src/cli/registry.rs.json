{
    "sourceFile": "src/cli/registry.rs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1762032949698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762033461285,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,41 +51,59 @@\n     handler_fn: Box<dyn Fn(HandlerInput) -> Result<HandlerOutput> + Send + Sync>,\n }\n \n impl CommandRegistry {\n-    /// Initialize the registry\n+    /// Initialize the registry (called once during first access)\n     pub fn init() -> &'static Mutex<CommandRegistry> {\n-        REGISTRY.get_or_init(|| {\n-            let registry = Mutex::new(CommandRegistry {\n+        // Create and store the registry first\n+        let stored = REGISTRY.get_or_init(|| {\n+            Mutex::new(CommandRegistry {\n                 nouns: HashMap::new(),\n                 verbs: HashMap::new(),\n-            });\n+            })\n+        });\n \n-            // Run all registrations after creating the registry\n-            for init_fn in __NOUN_REGISTRY {\n-                init_fn();\n-            }\n-            for init_fn in __VERB_REGISTRY {\n-                init_fn();\n-            }\n+        // Now run registrations after the registry is stored\n+        // This is safe because REGISTRY.get() will return the stored value\n+        // without recursion\n+        for init_fn in __NOUN_REGISTRY {\n+            init_fn();\n+        }\n+        for init_fn in __VERB_REGISTRY {\n+            init_fn();\n+        }\n \n-            registry\n-        })\n+        stored\n     }\n \n     /// Get the global registry instance\n     pub fn get() -> &'static Mutex<CommandRegistry> {\n         Self::init()\n     }\n \n     /// Register a noun (called by macro-generated code)\n+    ///\n+    /// NOTE: This is called during initialization, so we use REGISTRY.get()\n+    /// directly to avoid recursion. Once init() completes, REGISTRY.get()\n+    /// will return the stored registry.\n     pub fn register_noun(name: &'static str, about: &'static str) {\n-        let registry = Self::get();\n-        let mut reg = registry.lock().unwrap();\n-        reg.nouns.insert(name.to_string(), NounMetadata {\n-            name: name.to_string(),\n-            about: about.to_string(),\n-        });\n+        // Try to get the registry - if init() is in progress, this will\n+        // wait for it to complete\n+        if let Some(registry) = REGISTRY.get() {\n+            let mut reg = registry.lock().unwrap();\n+            reg.nouns.insert(name.to_string(), NounMetadata {\n+                name: name.to_string(),\n+                about: about.to_string(),\n+            });\n+        } else {\n+            // This shouldn't happen, but fallback to init() if needed\n+            let registry = Self::init();\n+            let mut reg = registry.lock().unwrap();\n+            reg.nouns.insert(name.to_string(), NounMetadata {\n+                name: name.to_string(),\n+                about: about.to_string(),\n+            });\n+        }\n     }\n \n     /// Register a verb (called by macro-generated code)\n     pub fn register_verb<F>(noun_name: &'static str, verb_name: &'static str, about: &'static str, handler: F)\n"
                },
                {
                    "date": 1762033515328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,57 +53,58 @@\n \n impl CommandRegistry {\n     /// Initialize the registry (called once during first access)\n     pub fn init() -> &'static Mutex<CommandRegistry> {\n-        // Create and store the registry first\n-        let stored = REGISTRY.get_or_init(|| {\n-            Mutex::new(CommandRegistry {\n+        // Use get_or_init to create and store the registry\n+        // During initialization, we'll run registration functions\n+        // which will call register_noun/register_verb_with_args\n+        // These will call REGISTRY.get() which will return None\n+        // until initialization completes, so we need a different approach\n+        REGISTRY.get_or_init(|| {\n+            // Create empty registry\n+            let registry = Mutex::new(CommandRegistry {\n                 nouns: HashMap::new(),\n                 verbs: HashMap::new(),\n-            })\n+            });\n+\n+            // Store it temporarily so registration functions can access it\n+            // We'll return it at the end\n+            registry\n         });\n \n-        // Now run registrations after the registry is stored\n-        // This is safe because REGISTRY.get() will return the stored value\n-        // without recursion\n+        // After registry is stored, run registration functions\n+        // Now REGISTRY.get() will return the stored value\n         for init_fn in __NOUN_REGISTRY {\n             init_fn();\n         }\n         for init_fn in __VERB_REGISTRY {\n             init_fn();\n         }\n \n-        stored\n+        // Return the stored registry\n+        REGISTRY.get().expect(\"Registry should be initialized\")\n     }\n \n     /// Get the global registry instance\n     pub fn get() -> &'static Mutex<CommandRegistry> {\n         Self::init()\n     }\n \n     /// Register a noun (called by macro-generated code)\n-    ///\n-    /// NOTE: This is called during initialization, so we use REGISTRY.get()\n-    /// directly to avoid recursion. Once init() completes, REGISTRY.get()\n-    /// will return the stored registry.\n     pub fn register_noun(name: &'static str, about: &'static str) {\n-        // Try to get the registry - if init() is in progress, this will\n-        // wait for it to complete\n-        if let Some(registry) = REGISTRY.get() {\n-            let mut reg = registry.lock().unwrap();\n-            reg.nouns.insert(name.to_string(), NounMetadata {\n-                name: name.to_string(),\n-                about: about.to_string(),\n-            });\n-        } else {\n-            // This shouldn't happen, but fallback to init() if needed\n-            let registry = Self::init();\n-            let mut reg = registry.lock().unwrap();\n-            reg.nouns.insert(name.to_string(), NounMetadata {\n-                name: name.to_string(),\n-                about: about.to_string(),\n-            });\n-        }\n+        // Get the registry - this will initialize it if needed\n+        // During initialization, this will wait until init() completes\n+        let registry = REGISTRY.get_or_init(|| {\n+            Mutex::new(CommandRegistry {\n+                nouns: HashMap::new(),\n+                verbs: HashMap::new(),\n+            })\n+        });\n+        let mut reg = registry.lock().unwrap();\n+        reg.nouns.insert(name.to_string(), NounMetadata {\n+            name: name.to_string(),\n+            about: about.to_string(),\n+        });\n     }\n \n     /// Register a verb (called by macro-generated code)\n     pub fn register_verb<F>(noun_name: &'static str, verb_name: &'static str, about: &'static str, handler: F)\n"
                },
                {
                    "date": 1762033540492,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -124,9 +124,16 @@\n     )\n     where\n         F: Fn(HandlerInput) -> Result<HandlerOutput> + Send + Sync + 'static,\n     {\n-        let registry = Self::get();\n+        // Get the registry - this will initialize it if needed\n+        // During initialization, this will wait until init() completes\n+        let registry = REGISTRY.get_or_init(|| {\n+            Mutex::new(CommandRegistry {\n+                nouns: HashMap::new(),\n+                verbs: HashMap::new(),\n+            })\n+        });\n         let mut reg = registry.lock().unwrap();\n         reg.verbs.entry(noun_name.to_string())\n             .or_insert_with(HashMap::new)\n             .insert(verb_name.to_string(), VerbMetadata {\n"
                },
                {
                    "date": 1762034418831,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,49 @@\n use std::collections::HashMap;\n use std::sync::{Mutex, OnceLock};\n use linkme::distributed_slice;\n \n+/// Apply validation constraints to a clap Arg\n+///\n+/// This function applies min/max value and length validators based on the\n+/// validation metadata stored in ArgMetadata.\n+fn apply_validators(arg: &mut clap::Arg, arg_meta: &ArgMetadata) {\n+    // For numeric types with min/max values, apply range validators\n+    if arg_meta.min_value.is_some() || arg_meta.max_value.is_some() {\n+        // Try to parse as integers first\n+        let min_i64 = arg_meta.min_value.as_ref()\n+            .and_then(|v| v.parse::<i64>().ok());\n+        let max_i64 = arg_meta.max_value.as_ref()\n+            .and_then(|v| v.parse::<i64>().ok());\n+        let min_u64 = arg_meta.min_value.as_ref()\n+            .and_then(|v| v.parse::<u64>().ok());\n+        let max_u64 = arg_meta.max_value.as_ref()\n+            .and_then(|v| v.parse::<u64>().ok());\n+\n+        // Apply range validators based on what we can parse\n+        if let (Some(min), Some(max)) = (min_i64, max_i64) {\n+            *arg = arg.clone().value_parser(clap::value_parser!(i64).range(min..=max));\n+        } else if let Some(min) = min_i64 {\n+            *arg = arg.clone().value_parser(clap::value_parser!(i64).range(min..));\n+        } else if let Some(max) = max_i64 {\n+            *arg = arg.clone().value_parser(clap::value_parser!(i64).range(..=max));\n+        } else if let (Some(min), Some(max)) = (min_u64, max_u64) {\n+            *arg = arg.clone().value_parser(clap::value_parser!(u64).range(min..=max));\n+        } else if let Some(min) = min_u64 {\n+            *arg = arg.clone().value_parser(clap::value_parser!(u64).range(min..));\n+        } else if let Some(max) = max_u64 {\n+            *arg = arg.clone().value_parser(clap::value_parser!(u64).range(..=max));\n+        }\n+    }\n+\n+    // For string types with min_length, ensure non-empty\n+    if let Some(min_len) = arg_meta.min_length {\n+        if min_len > 0 {\n+            *arg = arg.clone().value_parser(clap::builder::NonEmptyStringValueParser::new());\n+        }\n+    }\n+}\n+\n /// Distributed slice for noun registrations\n #[distributed_slice]\n pub static __NOUN_REGISTRY: [fn()] = [..];\n \n@@ -39,8 +80,13 @@\n pub struct ArgMetadata {\n     pub name: String,\n     pub required: bool,\n     pub is_flag: bool,\n+    pub help: Option<String>,\n+    pub min_value: Option<String>,\n+    pub max_value: Option<String>,\n+    pub min_length: Option<usize>,\n+    pub max_length: Option<usize>,\n }\n \n /// Metadata for a registered verb\n struct VerbMetadata {\n@@ -200,10 +246,20 @@\n                             arg = arg.value_name(value_name);\n                             if arg_meta.required {\n                                 arg = arg.required(true);\n                             }\n+\n+                            // Apply auto-inferred and explicit validation constraints\n+                            // Try to apply validators based on the stored metadata\n+                            apply_validators(&mut arg, arg_meta);\n                         }\n \n+                        // Add help text from docstring if available\n+                        if let Some(help_text) = &arg_meta.help {\n+                            let help: &'static str = Box::leak(help_text.clone().into_boxed_str());\n+                            arg = arg.help(help);\n+                        }\n+\n                         verb_cmd = verb_cmd.arg(arg);\n                     }\n \n                     noun_cmd = noun_cmd.subcommand(verb_cmd);\n"
                },
                {
                    "date": 1762037367691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,16 @@\n //! Compile-time command registry for attribute macros\n //!\n //! This module provides a registry that collects functions marked with\n-//! #[verb] and #[noun] attributes at compile time using linkme.\n+//! `#[verb]` and `#[noun]` attributes at compile time using linkme.\n+//!\n+//! These attribute macros are provided by the `clap-noun-verb-macros` crate.\n \n use crate::error::Result;\n use crate::logic::{HandlerInput, HandlerOutput};\n+use linkme::distributed_slice;\n use std::collections::HashMap;\n use std::sync::{Mutex, OnceLock};\n-use linkme::distributed_slice;\n \n /// Apply validation constraints to a clap Arg\n ///\n /// This function applies min/max value and length validators based on the\n@@ -16,16 +18,12 @@\n fn apply_validators(arg: &mut clap::Arg, arg_meta: &ArgMetadata) {\n     // For numeric types with min/max values, apply range validators\n     if arg_meta.min_value.is_some() || arg_meta.max_value.is_some() {\n         // Try to parse as integers first\n-        let min_i64 = arg_meta.min_value.as_ref()\n-            .and_then(|v| v.parse::<i64>().ok());\n-        let max_i64 = arg_meta.max_value.as_ref()\n-            .and_then(|v| v.parse::<i64>().ok());\n-        let min_u64 = arg_meta.min_value.as_ref()\n-            .and_then(|v| v.parse::<u64>().ok());\n-        let max_u64 = arg_meta.max_value.as_ref()\n-            .and_then(|v| v.parse::<u64>().ok());\n+        let min_i64 = arg_meta.min_value.as_ref().and_then(|v| v.parse::<i64>().ok());\n+        let max_i64 = arg_meta.max_value.as_ref().and_then(|v| v.parse::<i64>().ok());\n+        let min_u64 = arg_meta.min_value.as_ref().and_then(|v| v.parse::<u64>().ok());\n+        let max_u64 = arg_meta.max_value.as_ref().and_then(|v| v.parse::<u64>().ok());\n \n         // Apply range validators based on what we can parse\n         if let (Some(min), Some(max)) = (min_i64, max_i64) {\n             *arg = arg.clone().value_parser(clap::value_parser!(i64).range(min..=max));\n@@ -106,12 +104,10 @@\n         // These will call REGISTRY.get() which will return None\n         // until initialization completes, so we need a different approach\n         REGISTRY.get_or_init(|| {\n             // Create empty registry\n-            let registry = Mutex::new(CommandRegistry {\n-                nouns: HashMap::new(),\n-                verbs: HashMap::new(),\n-            });\n+            let registry =\n+                Mutex::new(CommandRegistry { nouns: HashMap::new(), verbs: HashMap::new() });\n \n             // Store it temporarily so registration functions can access it\n             // We'll return it at the end\n             registry\n@@ -139,23 +135,24 @@\n     pub fn register_noun(name: &'static str, about: &'static str) {\n         // Get the registry - this will initialize it if needed\n         // During initialization, this will wait until init() completes\n         let registry = REGISTRY.get_or_init(|| {\n-            Mutex::new(CommandRegistry {\n-                nouns: HashMap::new(),\n-                verbs: HashMap::new(),\n-            })\n+            Mutex::new(CommandRegistry { nouns: HashMap::new(), verbs: HashMap::new() })\n         });\n         let mut reg = registry.lock().unwrap();\n-        reg.nouns.insert(name.to_string(), NounMetadata {\n-            name: name.to_string(),\n-            about: about.to_string(),\n-        });\n+        reg.nouns.insert(\n+            name.to_string(),\n+            NounMetadata { name: name.to_string(), about: about.to_string() },\n+        );\n     }\n \n     /// Register a verb (called by macro-generated code)\n-    pub fn register_verb<F>(noun_name: &'static str, verb_name: &'static str, about: &'static str, handler: F)\n-    where\n+    pub fn register_verb<F>(\n+        noun_name: &'static str,\n+        verb_name: &'static str,\n+        about: &'static str,\n+        handler: F,\n+    ) where\n         F: Fn(HandlerInput) -> Result<HandlerOutput> + Send + Sync + 'static,\n     {\n         Self::register_verb_with_args(noun_name, verb_name, about, Vec::new(), handler)\n     }\n@@ -166,52 +163,58 @@\n         verb_name: &'static str,\n         about: &'static str,\n         args: Vec<ArgMetadata>,\n         handler: F,\n-    )\n-    where\n+    ) where\n         F: Fn(HandlerInput) -> Result<HandlerOutput> + Send + Sync + 'static,\n     {\n         // Get the registry - this will initialize it if needed\n         // During initialization, this will wait until init() completes\n         let registry = REGISTRY.get_or_init(|| {\n-            Mutex::new(CommandRegistry {\n-                nouns: HashMap::new(),\n-                verbs: HashMap::new(),\n-            })\n+            Mutex::new(CommandRegistry { nouns: HashMap::new(), verbs: HashMap::new() })\n         });\n         let mut reg = registry.lock().unwrap();\n-        reg.verbs.entry(noun_name.to_string())\n-            .or_insert_with(HashMap::new)\n-            .insert(verb_name.to_string(), VerbMetadata {\n+        reg.verbs.entry(noun_name.to_string()).or_insert_with(HashMap::new).insert(\n+            verb_name.to_string(),\n+            VerbMetadata {\n                 noun_name: noun_name.to_string(),\n                 verb_name: verb_name.to_string(),\n                 about: about.to_string(),\n                 args,\n                 handler_fn: Box::new(handler),\n-            });\n+            },\n+        );\n     }\n \n     /// Get all registered nouns\n     pub fn get_nouns(&self) -> Vec<(&str, &str)> {\n-        self.nouns.iter()\n-            .map(|(name, meta)| (name.as_str(), meta.about.as_str()))\n-            .collect()\n+        self.nouns.iter().map(|(name, meta)| (name.as_str(), meta.about.as_str())).collect()\n     }\n \n     /// Get all verbs for a noun\n     pub fn get_verbs(&self, noun_name: &str) -> Vec<(&str, &str)> {\n-        self.verbs.get(noun_name)\n-            .map(|verbs| verbs.iter().map(|(name, meta)| (name.as_str(), meta.about.as_str())).collect())\n+        self.verbs\n+            .get(noun_name)\n+            .map(|verbs| {\n+                verbs.iter().map(|(name, meta)| (name.as_str(), meta.about.as_str())).collect()\n+            })\n             .unwrap_or_default()\n     }\n \n     /// Execute a verb handler\n-    pub fn execute_verb(&self, noun_name: &str, verb_name: &str, input: HandlerInput) -> Result<HandlerOutput> {\n-        let verbs = self.verbs.get(noun_name)\n+    pub fn execute_verb(\n+        &self,\n+        noun_name: &str,\n+        verb_name: &str,\n+        input: HandlerInput,\n+    ) -> Result<HandlerOutput> {\n+        let verbs = self\n+            .verbs\n+            .get(noun_name)\n             .ok_or_else(|| crate::error::NounVerbError::command_not_found(noun_name))?;\n \n-        let verb = verbs.get(verb_name)\n+        let verb = verbs\n+            .get(verb_name)\n             .ok_or_else(|| crate::error::NounVerbError::verb_not_found(noun_name, verb_name))?;\n \n         (verb.handler_fn)(input)\n     }\n@@ -235,10 +238,12 @@\n                     let mut verb_cmd = clap::Command::new(verb_name).about(about);\n \n                     // Add arguments from metadata\n                     for arg_meta in &verb_meta.args {\n-                        let arg_name: &'static str = Box::leak(arg_meta.name.clone().into_boxed_str());\n-                        let value_name: &'static str = Box::leak(arg_meta.name.to_uppercase().into_boxed_str());\n+                        let arg_name: &'static str =\n+                            Box::leak(arg_meta.name.clone().into_boxed_str());\n+                        let value_name: &'static str =\n+                            Box::leak(arg_meta.name.to_uppercase().into_boxed_str());\n                         let mut arg = clap::Arg::new(arg_name).long(arg_name);\n \n                         if arg_meta.is_flag {\n                             arg = arg.action(clap::ArgAction::SetTrue);\n@@ -274,9 +279,10 @@\n \n     /// Run CLI with auto-discovered commands\n     pub fn run(&self, args: Vec<String>) -> Result<()> {\n         let cmd = self.build_command();\n-        let matches = cmd.try_get_matches_from(args)\n+        let matches = cmd\n+            .try_get_matches_from(args)\n             .map_err(|e| crate::error::NounVerbError::argument_error(e.to_string()))?;\n \n         // Route command\n         if let Some((noun_name, noun_matches)) = matches.subcommand() {\n@@ -304,10 +310,9 @@\n \n                 let input = crate::logic::HandlerInput {\n                     args: args_map,\n                     opts: std::collections::HashMap::new(),\n-                    context: crate::logic::HandlerContext::new(verb_name)\n-                        .with_noun(noun_name),\n+                    context: crate::logic::HandlerContext::new(verb_name).with_noun(noun_name),\n                 };\n \n                 let output = self.execute_verb(noun_name, verb_name, input)?;\n                 let json = output.to_json()?;\n"
                }
            ],
            "date": 1762032949698,
            "name": "Commit-0",
            "content": "//! Compile-time command registry for attribute macros\n//!\n//! This module provides a registry that collects functions marked with\n//! #[verb] and #[noun] attributes at compile time using linkme.\n\nuse crate::error::Result;\nuse crate::logic::{HandlerInput, HandlerOutput};\nuse std::collections::HashMap;\nuse std::sync::{Mutex, OnceLock};\nuse linkme::distributed_slice;\n\n/// Distributed slice for noun registrations\n#[distributed_slice]\npub static __NOUN_REGISTRY: [fn()] = [..];\n\n/// Distributed slice for verb registrations\n#[distributed_slice]\npub static __VERB_REGISTRY: [fn()] = [..];\n\n/// Global registry for registered commands\nstatic REGISTRY: OnceLock<Mutex<CommandRegistry>> = OnceLock::new();\n\n/// Command registry for attribute macro discovered functions\npub struct CommandRegistry {\n    /// Registered nouns (name -> noun metadata)\n    nouns: HashMap<String, NounMetadata>,\n    /// Registered verbs (noun_name -> verb_name -> verb metadata)\n    verbs: HashMap<String, HashMap<String, VerbMetadata>>,\n}\n\n/// Metadata for a registered noun\nstruct NounMetadata {\n    name: String,\n    about: String,\n}\n\n/// Argument metadata for a verb function parameter\n#[derive(Clone)]\npub struct ArgMetadata {\n    pub name: String,\n    pub required: bool,\n    pub is_flag: bool,\n}\n\n/// Metadata for a registered verb\nstruct VerbMetadata {\n    noun_name: String,\n    verb_name: String,\n    about: String,\n    args: Vec<ArgMetadata>,\n    handler_fn: Box<dyn Fn(HandlerInput) -> Result<HandlerOutput> + Send + Sync>,\n}\n\nimpl CommandRegistry {\n    /// Initialize the registry\n    pub fn init() -> &'static Mutex<CommandRegistry> {\n        REGISTRY.get_or_init(|| {\n            let registry = Mutex::new(CommandRegistry {\n                nouns: HashMap::new(),\n                verbs: HashMap::new(),\n            });\n\n            // Run all registrations after creating the registry\n            for init_fn in __NOUN_REGISTRY {\n                init_fn();\n            }\n            for init_fn in __VERB_REGISTRY {\n                init_fn();\n            }\n\n            registry\n        })\n    }\n\n    /// Get the global registry instance\n    pub fn get() -> &'static Mutex<CommandRegistry> {\n        Self::init()\n    }\n\n    /// Register a noun (called by macro-generated code)\n    pub fn register_noun(name: &'static str, about: &'static str) {\n        let registry = Self::get();\n        let mut reg = registry.lock().unwrap();\n        reg.nouns.insert(name.to_string(), NounMetadata {\n            name: name.to_string(),\n            about: about.to_string(),\n        });\n    }\n\n    /// Register a verb (called by macro-generated code)\n    pub fn register_verb<F>(noun_name: &'static str, verb_name: &'static str, about: &'static str, handler: F)\n    where\n        F: Fn(HandlerInput) -> Result<HandlerOutput> + Send + Sync + 'static,\n    {\n        Self::register_verb_with_args(noun_name, verb_name, about, Vec::new(), handler)\n    }\n\n    /// Register a verb with argument metadata\n    pub fn register_verb_with_args<F>(\n        noun_name: &'static str,\n        verb_name: &'static str,\n        about: &'static str,\n        args: Vec<ArgMetadata>,\n        handler: F,\n    )\n    where\n        F: Fn(HandlerInput) -> Result<HandlerOutput> + Send + Sync + 'static,\n    {\n        let registry = Self::get();\n        let mut reg = registry.lock().unwrap();\n        reg.verbs.entry(noun_name.to_string())\n            .or_insert_with(HashMap::new)\n            .insert(verb_name.to_string(), VerbMetadata {\n                noun_name: noun_name.to_string(),\n                verb_name: verb_name.to_string(),\n                about: about.to_string(),\n                args,\n                handler_fn: Box::new(handler),\n            });\n    }\n\n    /// Get all registered nouns\n    pub fn get_nouns(&self) -> Vec<(&str, &str)> {\n        self.nouns.iter()\n            .map(|(name, meta)| (name.as_str(), meta.about.as_str()))\n            .collect()\n    }\n\n    /// Get all verbs for a noun\n    pub fn get_verbs(&self, noun_name: &str) -> Vec<(&str, &str)> {\n        self.verbs.get(noun_name)\n            .map(|verbs| verbs.iter().map(|(name, meta)| (name.as_str(), meta.about.as_str())).collect())\n            .unwrap_or_default()\n    }\n\n    /// Execute a verb handler\n    pub fn execute_verb(&self, noun_name: &str, verb_name: &str, input: HandlerInput) -> Result<HandlerOutput> {\n        let verbs = self.verbs.get(noun_name)\n            .ok_or_else(|| crate::error::NounVerbError::command_not_found(noun_name))?;\n\n        let verb = verbs.get(verb_name)\n            .ok_or_else(|| crate::error::NounVerbError::verb_not_found(noun_name, verb_name))?;\n\n        (verb.handler_fn)(input)\n    }\n\n    /// Build clap command structure from registry\n    pub fn build_command(&self) -> clap::Command {\n        let mut cmd = clap::Command::new(\"cli\");\n\n        for (noun_name, noun_meta) in &self.nouns {\n            let noun_name: &'static str = Box::leak(noun_name.clone().into_boxed_str());\n            let about: &'static str = Box::leak(noun_meta.about.clone().into_boxed_str());\n\n            let mut noun_cmd = clap::Command::new(noun_name).about(about);\n\n            // Add verbs as subcommands\n            if let Some(verbs) = self.verbs.get(noun_name) {\n                for (verb_name, verb_meta) in verbs {\n                    let verb_name: &'static str = Box::leak(verb_name.clone().into_boxed_str());\n                    let about: &'static str = Box::leak(verb_meta.about.clone().into_boxed_str());\n\n                    let mut verb_cmd = clap::Command::new(verb_name).about(about);\n\n                    // Add arguments from metadata\n                    for arg_meta in &verb_meta.args {\n                        let arg_name: &'static str = Box::leak(arg_meta.name.clone().into_boxed_str());\n                        let value_name: &'static str = Box::leak(arg_meta.name.to_uppercase().into_boxed_str());\n                        let mut arg = clap::Arg::new(arg_name).long(arg_name);\n\n                        if arg_meta.is_flag {\n                            arg = arg.action(clap::ArgAction::SetTrue);\n                        } else {\n                            arg = arg.value_name(value_name);\n                            if arg_meta.required {\n                                arg = arg.required(true);\n                            }\n                        }\n\n                        verb_cmd = verb_cmd.arg(arg);\n                    }\n\n                    noun_cmd = noun_cmd.subcommand(verb_cmd);\n                }\n            }\n\n            cmd = cmd.subcommand(noun_cmd);\n        }\n\n        cmd\n    }\n\n    /// Run CLI with auto-discovered commands\n    pub fn run(&self, args: Vec<String>) -> Result<()> {\n        let cmd = self.build_command();\n        let matches = cmd.try_get_matches_from(args)\n            .map_err(|e| crate::error::NounVerbError::argument_error(e.to_string()))?;\n\n        // Route command\n        if let Some((noun_name, noun_matches)) = matches.subcommand() {\n            if let Some((verb_name, verb_matches)) = noun_matches.subcommand() {\n                // Execute verb - extract arguments from matches\n                let mut args_map = std::collections::HashMap::new();\n\n                // Get verb metadata to know which arguments exist\n                if let Some(verbs) = self.verbs.get(noun_name) {\n                    if let Some(verb_meta) = verbs.get(verb_name) {\n                        // Extract each argument by name from clap matches\n                        for arg_meta in &verb_meta.args {\n                            let arg_name = &arg_meta.name;\n                            if let Some(value) = verb_matches.get_one::<String>(arg_name) {\n                                args_map.insert(arg_name.clone(), value.clone());\n                            } else if arg_meta.is_flag {\n                                // For flags, check if they're set\n                                if verb_matches.get_flag(arg_name) {\n                                    args_map.insert(arg_name.clone(), \"true\".to_string());\n                                }\n                            }\n                        }\n                    }\n                }\n\n                let input = crate::logic::HandlerInput {\n                    args: args_map,\n                    opts: std::collections::HashMap::new(),\n                    context: crate::logic::HandlerContext::new(verb_name)\n                        .with_noun(noun_name),\n                };\n\n                let output = self.execute_verb(noun_name, verb_name, input)?;\n                let json = output.to_json()?;\n                println!(\"{}\", json);\n            } else {\n                return Err(crate::error::NounVerbError::invalid_structure(\"No verb specified\"));\n            }\n        } else {\n            return Err(crate::error::NounVerbError::invalid_structure(\"No noun specified\"));\n        }\n\n        Ok(())\n    }\n}\n"
        }
    ]
}