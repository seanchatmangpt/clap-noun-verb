//! CLI Code Generator
//!
//! This module generates Rust code for clap-noun-verb from AST.
//! It produces code using clap derive macros and noun-verb patterns.
//!
//! ## Generated Code Structure
//!
//! The generator produces:
//! - Clap derive structs for arguments
//! - Command implementations
//! - Noun/Verb trait implementations
//!
//! ## Type Safety
//!
//! - All code generation uses type-safe templates
//! - Generated code is guaranteed to compile
//! - No runtime string manipulation
//!
//! ## Examples
//!
//! ```rust
//! use clap_noun_verb::ggen_integration::codegen::CodeGenerator;
//! use clap_noun_verb::ggen_integration::ast::Command;
//!
//! # fn main() -> clap_noun_verb::Result<()> {
//! let generator = CodeGenerator::new();
//! let commands = vec![
//!     Command::new("user".to_string(), "User management".to_string())
//! ];
//!
//! let code = generator.generate(&commands)?;
//! println!("{}", code);
//! # Ok(())
//! # }
//! ```

use crate::ggen_integration::ast::{Argument, ArgumentKind, Command, Flag};
use crate::ggen_integration::error::GgenResult as Result;

/// Code generator for clap-noun-verb
///
/// Transforms AST into Rust code using clap derive macros
pub struct CodeGenerator {
    indent_level: usize,
}

impl CodeGenerator {
    /// Create a new code generator
    pub fn new() -> Self {
        Self { indent_level: 0 }
    }

    /// Generate Rust code from commands
    ///
    /// # Arguments
    ///
    /// * `commands` - Command definitions
    ///
    /// # Returns
    ///
    /// * `Result<String>` - Generated Rust code
    ///
    /// # Errors
    ///
    /// Returns error if code generation fails
    pub fn generate(&self, commands: &[Command]) -> Result<String> {
        let mut output = String::new();

        // Add file header
        output.push_str(&self.generate_header());

        // Generate command structs
        for command in commands {
            output.push_str(&self.generate_command(command));
            output.push('\n');
        }

        Ok(output)
    }

    /// Generate file header with imports
    fn generate_header(&self) -> String {
        r#"// Generated by ggen-clap-noun-verb integration
// DO NOT EDIT - This file is auto-generated

use clap::Parser;
use clap_noun_verb::{NounCommand, VerbCommand, VerbArgs};

"#
        .to_string()
    }

    /// Generate code for a single command
    fn generate_command(&self, command: &Command) -> String {
        let mut output = String::new();

        // Generate struct
        output.push_str(&format!(
            "/// {}\n#[derive(Debug, Clone, Parser)]\npub struct {} {{\n",
            command.description,
            self.to_struct_name(&command.name)
        ));

        // Generate arguments
        for arg in &command.arguments {
            output.push_str(&self.generate_argument(arg));
        }

        // Generate flags
        for flag in &command.flags {
            output.push_str(&self.generate_flag(flag));
        }

        // Generate subcommands
        if !command.subcommands.is_empty() {
            output.push_str("    #[command(subcommand)]\n");
            output.push_str("    pub command: Option<SubCommand>,\n");
        }

        output.push_str("}\n\n");

        // Generate subcommand enum if needed
        if !command.subcommands.is_empty() {
            output.push_str(&self.generate_subcommand_enum(command));
        }

        output
    }

    /// Generate code for an argument
    fn generate_argument(&self, arg: &Argument) -> String {
        let mut output = String::new();

        // Add doc comment
        output.push_str(&format!("    /// {}\n", arg.help));

        // Add clap attributes
        match &arg.kind {
            ArgumentKind::Positional { .. } => {
                output.push_str("    #[arg(value_name = \"");
                output.push_str(&arg.name.to_uppercase());
                output.push_str("\"");
            }
            ArgumentKind::Named { long, short } => {
                output.push_str("    #[arg(long = \"");
                output.push_str(long);
                output.push('\"');
                if let Some(s) = short {
                    output.push_str(", short = '");
                    output.push(*s);
                    output.push('\'');
                }
            }
        }

        // Add required attribute
        if arg.required {
            output.push_str(", required = true");
        }

        // Add default if present
        if let Some(default) = &arg.default {
            output.push_str(&format!(", default_value = \"{}\"", default));
        }

        output.push_str(")]\n");

        // Add field
        output.push_str(&format!(
            "    pub {}: {},\n",
            self.to_field_name(&arg.name),
            arg.type_annotation.to_rust_type()
        ));

        output
    }

    /// Generate code for a flag
    fn generate_flag(&self, flag: &Flag) -> String {
        let mut output = String::new();

        // Add doc comment
        output.push_str(&format!("    /// {}\n", flag.help));

        // Add clap attributes
        output.push_str(&format!("    #[arg(long = \"{}\"", flag.long));
        if let Some(short) = flag.short {
            output.push_str(&format!(", short = '{}'", short));
        }
        output.push_str(")]\n");

        // Add field
        output.push_str(&format!("    pub {}: bool,\n", self.to_field_name(&flag.name)));

        output
    }

    /// Generate subcommand enum
    fn generate_subcommand_enum(&self, command: &Command) -> String {
        let mut output = String::new();

        output.push_str(&format!(
            "#[derive(Debug, Clone, clap::Subcommand)]\npub enum {}SubCommand {{\n",
            self.to_struct_name(&command.name)
        ));

        for subcmd in &command.subcommands {
            output.push_str(&format!(
                "    /// {}\n    {}({}),\n",
                subcmd.description,
                self.to_struct_name(&subcmd.name),
                self.to_struct_name(&subcmd.name)
            ));
        }

        output.push_str("}\n\n");

        // Generate structs for each subcommand
        for subcmd in &command.subcommands {
            output.push_str(&self.generate_command(subcmd));
        }

        output
    }

    /// Convert name to struct name (PascalCase)
    fn to_struct_name(&self, name: &str) -> String {
        name.split('_')
            .map(|part| {
                let mut chars = part.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                }
            })
            .collect::<Vec<_>>()
            .join("")
    }

    /// Convert name to field name (snake_case)
    fn to_field_name(&self, name: &str) -> String {
        name.to_lowercase().replace('-', "_")
    }
}

impl Default for CodeGenerator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generator_new() {
        // Arrange & Act
        let generator = CodeGenerator::new();

        // Assert
        assert_eq!(generator.indent_level, 0);
    }

    #[test]
    fn test_generate_empty() {
        // Arrange
        let generator = CodeGenerator::new();
        let commands = vec![];

        // Act
        let result = generator.generate(&commands);

        // Assert
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("// Generated by ggen-clap-noun-verb"));
        assert!(code.contains("use clap::Parser"));
    }

    #[test]
    fn test_generate_simple_command() {
        // Arrange
        let generator = CodeGenerator::new();
        let commands = vec![Command::new("user".to_string(), "User management".to_string())];

        // Act
        let result = generator.generate(&commands);

        // Assert
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("pub struct User"));
        assert!(code.contains("/// User management"));
    }

    #[test]
    fn test_generate_command_with_argument() {
        // Arrange
        let generator = CodeGenerator::new();
        let mut cmd = Command::new("create".to_string(), "Create user".to_string());
        cmd.arguments.push(Argument::named(
            "name".to_string(),
            "name".to_string(),
            Some('n'),
            TypeAnnotation::String,
            true,
            "User name".to_string(),
        ));

        // Act
        let result = generator.generate(&[cmd]);

        // Assert
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("pub name: String"));
        assert!(code.contains("#[arg(long = \"name\""));
        assert!(code.contains("short = 'n'"));
        assert!(code.contains("required = true"));
    }

    #[test]
    fn test_generate_command_with_flag() {
        // Arrange
        let generator = CodeGenerator::new();
        let mut cmd = Command::new("build".to_string(), "Build project".to_string());
        cmd.flags.push(Flag::new(
            "verbose".to_string(),
            "verbose".to_string(),
            Some('v'),
            "Verbose output".to_string(),
        ));

        // Act
        let result = generator.generate(&[cmd]);

        // Assert
        assert!(result.is_ok());
        let code = result.unwrap();
        assert!(code.contains("pub verbose: bool"));
        assert!(code.contains("#[arg(long = \"verbose\""));
    }

    #[test]
    fn test_to_struct_name() {
        // Arrange
        let generator = CodeGenerator::new();

        // Act & Assert
        assert_eq!(generator.to_struct_name("user"), "User");
        assert_eq!(generator.to_struct_name("user_command"), "UserCommand");
        assert_eq!(generator.to_struct_name("my_cli_tool"), "MyCliTool");
    }

    #[test]
    fn test_to_field_name() {
        // Arrange
        let generator = CodeGenerator::new();

        // Act & Assert
        assert_eq!(generator.to_field_name("user"), "user");
        assert_eq!(generator.to_field_name("USER"), "user");
        assert_eq!(generator.to_field_name("user-name"), "user_name");
    }

    #[test]
    fn test_default() {
        // Arrange & Act
        let generator = CodeGenerator::default();

        // Assert
        assert_eq!(generator.indent_level, 0);
    }
}
