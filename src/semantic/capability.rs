//! Capability metadata and distributed slice registration

use linkme::distributed_slice;

/// Capability metadata generated by `#[semantic_composable]` macro
///
/// This type encodes capability invariants:
/// - URI must be valid IRI
/// - RDF metadata is Turtle format
/// - MCP descriptor is valid JSON
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CapabilityMetadata {
    /// Unique capability URI
    pub uri: &'static str,
    /// Function name implementing capability
    pub function_name: &'static str,
    /// RDF Turtle metadata for SPARQL queries
    pub rdf_metadata: &'static str,
    /// MCP protocol descriptor JSON
    pub mcp_descriptor: &'static str,
}

/// Distributed slice for auto-discovered semantic capabilities
///
/// Capabilities registered via `#[semantic_composable]` macro are
/// automatically added to this slice using linkme.
#[distributed_slice]
pub static SEMANTIC_CAPABILITIES: [&'static CapabilityMetadata] = [..];

impl CapabilityMetadata {
    /// Get capability URI
    pub const fn uri(&self) -> &'static str {
        self.uri
    }

    /// Get implementing function name
    pub const fn function_name(&self) -> &'static str {
        self.function_name
    }

    /// Get RDF metadata in Turtle format
    pub const fn rdf_metadata(&self) -> &'static str {
        self.rdf_metadata
    }

    /// Get MCP protocol descriptor
    pub const fn mcp_descriptor(&self) -> &'static str {
        self.mcp_descriptor
    }
}

// =============================================================================
// Unit Tests - Chicago TDD
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_capability_metadata_accessors() {
        // Arrange: Create test metadata
        let metadata = CapabilityMetadata {
            uri: "urn:test:cap:reader",
            function_name: "read_file",
            rdf_metadata: "<urn:test:cap:reader> rdf:type cap:Capability .",
            mcp_descriptor: r#"{"protocol":"mcp","version":"2024.1"}"#,
        };

        // Act: Access fields
        let uri = metadata.uri();
        let function = metadata.function_name();
        let rdf = metadata.rdf_metadata();
        let mcp = metadata.mcp_descriptor();

        // Assert: All fields accessible
        assert_eq!(uri, "urn:test:cap:reader");
        assert_eq!(function, "read_file");
        assert!(rdf.contains("cap:Capability"));
        assert!(mcp.contains("mcp"));
    }

    #[test]
    fn test_capability_metadata_clone() {
        // Arrange: Original metadata
        let original = CapabilityMetadata {
            uri: "urn:test:cap:writer",
            function_name: "write_file",
            rdf_metadata: "test metadata",
            mcp_descriptor: "test descriptor",
        };

        // Act: Clone metadata
        let cloned = original.clone();

        // Assert: Clone is equal
        assert_eq!(original, cloned);
        assert_eq!(original.uri(), cloned.uri());
    }
}
