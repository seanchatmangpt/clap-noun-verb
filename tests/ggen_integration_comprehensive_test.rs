//! Comprehensive integration tests for ggen-clap-noun-verb module
//!
//! These tests verify the complete pipeline from AST to generated code.
//! They follow Chicago TDD principles with AAA pattern.

#![cfg(feature = "rdf")]

use clap_noun_verb::ggen_integration::{
    Argument, ArgumentKind, CodeGenerator, Command, Flag, GgenError, GgenResult, TurtleParser,
    TypeAnnotation,
};

// =============================================================================
// AST Tests - Verify type-safe construction
// =============================================================================

#[test]
fn test_command_builder_creates_valid_command() {
    // Arrange & Act
    let command = Command::new("deploy".to_string(), "Deploy application".to_string());

    // Assert
    assert_eq!(command.name, "deploy");
    assert_eq!(command.description, "Deploy application");
    assert!(command.arguments.is_empty());
    assert!(command.flags.is_empty());
    assert!(command.subcommands.is_empty());
}

#[test]
fn test_command_with_nested_subcommands() {
    // Arrange
    let mut parent = Command::new("git".to_string(), "Git commands".to_string());
    let mut sub1 = Command::new("commit".to_string(), "Commit changes".to_string());
    sub1.arguments.push(Argument::named(
        "message".to_string(),
        "message".to_string(),
        Some('m'),
        TypeAnnotation::String,
        true,
        "Commit message".to_string(),
    ));

    // Act
    parent.subcommands.push(sub1);

    // Assert
    assert!(parent.has_subcommands());
    assert_eq!(parent.subcommands.len(), 1);
    assert_eq!(parent.subcommands[0].name, "commit");
    assert!(parent.subcommands[0].has_arguments());
}

#[test]
fn test_positional_argument_construction() {
    // Arrange & Act
    let arg = Argument::positional(
        "filename".to_string(),
        0,
        TypeAnnotation::Path,
        true,
        "Input file path".to_string(),
    );

    // Assert
    assert_eq!(arg.name, "filename");
    assert!(arg.is_positional());
    assert!(!arg.is_named());
    assert!(arg.required);
    assert_eq!(arg.type_annotation, TypeAnnotation::Path);
    assert_eq!(arg.type_annotation.to_rust_type(), "std::path::PathBuf");
}

#[test]
fn test_named_argument_with_short_and_long() {
    // Arrange & Act
    let arg = Argument::named(
        "output".to_string(),
        "output-file".to_string(),
        Some('o'),
        TypeAnnotation::String,
        false,
        "Output file path".to_string(),
    );

    // Assert
    assert_eq!(arg.name, "output");
    assert!(!arg.is_positional());
    assert!(arg.is_named());
    assert!(!arg.required);

    if let ArgumentKind::Named { long, short } = &arg.kind {
        assert_eq!(long, "output-file");
        assert_eq!(*short, Some('o'));
    } else {
        panic!("Expected Named argument kind");
    }
}

#[test]
fn test_flag_construction() {
    // Arrange & Act
    let flag = Flag::new(
        "verbose".to_string(),
        "verbose".to_string(),
        Some('v'),
        "Enable verbose logging".to_string(),
    );

    // Assert
    assert_eq!(flag.name, "verbose");
    assert_eq!(flag.long, "verbose");
    assert_eq!(flag.short, Some('v'));
    assert!(!flag.default);
    assert_eq!(flag.help, "Enable verbose logging");
}

#[test]
fn test_type_annotation_conversions() {
    // Arrange & Act & Assert
    assert_eq!(TypeAnnotation::String.to_rust_type(), "String");
    assert_eq!(TypeAnnotation::Integer.to_rust_type(), "i64");
    assert_eq!(TypeAnnotation::Float.to_rust_type(), "f64");
    assert_eq!(TypeAnnotation::Boolean.to_rust_type(), "bool");
    assert_eq!(TypeAnnotation::Path.to_rust_type(), "std::path::PathBuf");

    let custom = TypeAnnotation::Custom("UserId".to_string());
    assert_eq!(custom.to_rust_type(), "UserId");
}

// =============================================================================
// Code Generator Tests - Verify generated code structure
// =============================================================================

#[test]
fn test_codegen_generates_header() {
    // Arrange
    let generator = CodeGenerator::new();
    let commands = vec![];

    // Act
    let result = generator.generate(&commands);

    // Assert
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("// Generated by ggen-clap-noun-verb"));
    assert!(code.contains("use clap::Parser"));
    assert!(code.contains("use clap_noun_verb"));
}

#[test]
fn test_codegen_simple_command_struct() {
    // Arrange
    let generator = CodeGenerator::new();
    let command = Command::new("build".to_string(), "Build the project".to_string());

    // Act
    let result = generator.generate(&[command]);

    // Assert
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("/// Build the project"));
    assert!(code.contains("pub struct Build"));
    assert!(code.contains("#[derive(Debug, Clone, Parser)]"));
}

#[test]
fn test_codegen_command_with_named_argument() {
    // Arrange
    let generator = CodeGenerator::new();
    let mut command = Command::new("serve".to_string(), "Start server".to_string());
    command.arguments.push(Argument::named(
        "port".to_string(),
        "port".to_string(),
        Some('p'),
        TypeAnnotation::Integer,
        true,
        "Port number".to_string(),
    ));

    // Act
    let result = generator.generate(&[command]);

    // Assert
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("pub port: i64"));
    assert!(code.contains("#[arg(long = \"port\""));
    assert!(code.contains("short = 'p'"));
    assert!(code.contains("required = true"));
    assert!(code.contains("/// Port number"));
}

#[test]
fn test_codegen_command_with_flag() {
    // Arrange
    let generator = CodeGenerator::new();
    let mut command = Command::new("run".to_string(), "Run application".to_string());
    command.flags.push(Flag::new(
        "debug".to_string(),
        "debug".to_string(),
        Some('d'),
        "Enable debug mode".to_string(),
    ));

    // Act
    let result = generator.generate(&[command]);

    // Assert
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("pub debug: bool"));
    assert!(code.contains("#[arg(long = \"debug\""));
    assert!(code.contains("short = 'd'"));
    assert!(code.contains("/// Enable debug mode"));
}

#[test]
fn test_codegen_command_with_positional_argument() {
    // Arrange
    let generator = CodeGenerator::new();
    let mut command = Command::new("cat".to_string(), "Concatenate files".to_string());
    command.arguments.push(Argument::positional(
        "file".to_string(),
        0,
        TypeAnnotation::Path,
        true,
        "File to display".to_string(),
    ));

    // Act
    let result = generator.generate(&[command]);

    // Assert
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("pub file: std::path::PathBuf"));
    assert!(code.contains("#[arg(value_name = \"FILE\""));
    assert!(code.contains("/// File to display"));
}

#[test]
fn test_codegen_command_with_subcommands() {
    // Arrange
    let generator = CodeGenerator::new();
    let mut parent = Command::new("docker".to_string(), "Docker CLI".to_string());
    let sub1 = Command::new("run".to_string(), "Run container".to_string());
    let sub2 = Command::new("stop".to_string(), "Stop container".to_string());
    parent.subcommands.push(sub1);
    parent.subcommands.push(sub2);

    // Act
    let result = generator.generate(&[parent]);

    // Assert
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("pub struct Docker"));
    assert!(code.contains("pub command: Option<SubCommand>"));
    assert!(code.contains("pub enum DockerSubCommand"));
    assert!(code.contains("Run(Run)"));
    assert!(code.contains("Stop(Stop)"));
    assert!(code.contains("pub struct Run"));
    assert!(code.contains("pub struct Stop"));
}

#[test]
fn test_codegen_name_conversions() {
    // Arrange
    let generator = CodeGenerator::new();
    let mut commands = vec![];

    // Snake case to PascalCase
    commands.push(Command::new("user_account".to_string(), "User account".to_string()));
    // Kebab case should convert to snake case for fields
    let mut kebab_cmd = Command::new("api".to_string(), "API".to_string());
    kebab_cmd.arguments.push(Argument::named(
        "api-key".to_string(),
        "api-key".to_string(),
        None,
        TypeAnnotation::String,
        true,
        "API key".to_string(),
    ));
    commands.push(kebab_cmd);

    // Act
    let result = generator.generate(&commands);

    // Assert
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("pub struct UserAccount"));
    assert!(code.contains("pub api_key: String")); // kebab to snake
}

// =============================================================================
// Parser Tests - Verify parsing logic
// =============================================================================

#[test]
fn test_parser_creation() {
    // Arrange & Act
    let result = TurtleParser::new();

    // Assert
    assert!(result.is_ok());
}

#[test]
fn test_parser_default_trait() {
    // Arrange & Act
    let parser = TurtleParser::default();

    // Assert - should create valid parser
    let result = parser.parse_string("");
    assert!(result.is_ok());
}

#[test]
fn test_parser_parse_empty_string() {
    // Arrange
    let parser = TurtleParser::new().unwrap();

    // Act
    let result = parser.parse_string("");

    // Assert - currently returns empty list (placeholder implementation)
    assert!(result.is_ok());
    assert_eq!(result.unwrap().len(), 0);
}

#[test]
fn test_parser_file_not_found_error() {
    // Arrange
    let parser = TurtleParser::new().unwrap();
    let path = std::path::Path::new("/nonexistent/path/to/file.ttl");

    // Act
    let result = parser.parse_file(path);

    // Assert
    assert!(result.is_err());
    let error = result.unwrap_err();
    assert!(matches!(
        error,
        clap_noun_verb::error::NounVerbError::NotFound(_)
    ));
}

// =============================================================================
// Error Handling Tests
// =============================================================================

#[test]
fn test_ggen_error_display_formats() {
    // Arrange
    let empty_error = GgenError::EmptyInput("test input".to_string());
    let syntax_error = GgenError::InvalidSyntax {
        line: 42,
        column: 10,
        message: "Unexpected token".to_string(),
    };
    let missing_prop = GgenError::MissingProperty {
        property: "name".to_string(),
        entity: "Command".to_string(),
    };

    // Act
    let empty_msg = empty_error.to_string();
    let syntax_msg = syntax_error.to_string();
    let prop_msg = missing_prop.to_string();

    // Assert
    assert!(empty_msg.contains("test input"));
    assert!(syntax_msg.contains("line 42"));
    assert!(syntax_msg.contains("column 10"));
    assert!(prop_msg.contains("name"));
    assert!(prop_msg.contains("Command"));
}

// =============================================================================
// Integration Tests - End-to-end pipeline
// =============================================================================

#[test]
fn test_full_pipeline_simple_cli() {
    // Arrange - Create AST for a simple CLI
    let mut command = Command::new("hello".to_string(), "Hello world CLI".to_string());
    command.arguments.push(Argument::named(
        "name".to_string(),
        "name".to_string(),
        Some('n'),
        TypeAnnotation::String,
        false,
        "Name to greet".to_string(),
    ));
    command.flags.push(Flag::new(
        "shout".to_string(),
        "shout".to_string(),
        Some('s'),
        "Shout the greeting".to_string(),
    ));

    // Act - Generate code
    let generator = CodeGenerator::new();
    let result = generator.generate(&[command]);

    // Assert - Verify complete generated code
    assert!(result.is_ok());
    let code = result.unwrap();

    // Verify header
    assert!(code.contains("// Generated by ggen-clap-noun-verb"));

    // Verify struct
    assert!(code.contains("pub struct Hello"));

    // Verify argument
    assert!(code.contains("pub name: String"));
    assert!(code.contains("#[arg(long = \"name\""));

    // Verify flag
    assert!(code.contains("pub shout: bool"));
    assert!(code.contains("#[arg(long = \"shout\""));
}

#[test]
fn test_full_pipeline_complex_cli_with_subcommands() {
    // Arrange - Create AST for complex CLI with subcommands
    let mut root = Command::new("cli".to_string(), "Main CLI".to_string());

    let mut config_cmd = Command::new("config".to_string(), "Configuration commands".to_string());
    let mut get_cmd = Command::new("get".to_string(), "Get config value".to_string());
    get_cmd.arguments.push(Argument::positional(
        "key".to_string(),
        0,
        TypeAnnotation::String,
        true,
        "Configuration key".to_string(),
    ));

    let mut set_cmd = Command::new("set".to_string(), "Set config value".to_string());
    set_cmd.arguments.push(Argument::positional(
        "key".to_string(),
        0,
        TypeAnnotation::String,
        true,
        "Configuration key".to_string(),
    ));
    set_cmd.arguments.push(Argument::positional(
        "value".to_string(),
        1,
        TypeAnnotation::String,
        true,
        "Configuration value".to_string(),
    ));

    config_cmd.subcommands.push(get_cmd);
    config_cmd.subcommands.push(set_cmd);
    root.subcommands.push(config_cmd);

    // Act
    let generator = CodeGenerator::new();
    let result = generator.generate(&[root]);

    // Assert
    assert!(result.is_ok());
    let code = result.unwrap();

    // Verify root struct
    assert!(code.contains("pub struct Cli"));
    assert!(code.contains("pub command: Option<SubCommand>"));

    // Verify subcommand enum
    assert!(code.contains("pub enum CliSubCommand"));
    assert!(code.contains("Config(Config)"));

    // Verify config struct
    assert!(code.contains("pub struct Config"));
    assert!(code.contains("pub command: Option<SubCommand>"));

    // Verify nested subcommand enum
    assert!(code.contains("pub enum ConfigSubCommand"));
    assert!(code.contains("Get(Get)"));
    assert!(code.contains("Set(Set)"));

    // Verify get and set structs
    assert!(code.contains("pub struct Get"));
    assert!(code.contains("pub struct Set"));
}
