//! Integration tests for ggen-clap-noun-verb
//!
//! These tests verify the end-to-end pipeline:
//! Turtle/RDF → Parser → AST → CodeGen → Rust code
//!
//! Tests follow Chicago TDD principles:
//! - State-based testing (verify outputs, not implementation)
//! - Real collaborators (use actual parser/codegen, not mocks)
//! - Behavior verification (verify what code does)
//! - AAA pattern (Arrange-Act-Assert)

#![cfg(feature = "rdf")]

use clap_noun_verb::ggen_integration::{
    ast::{Argument, ArgumentKind, Command, Flag, TypeAnnotation},
    codegen::CodeGenerator,
    parse_turtle, generate_cli_code,
};
use std::path::Path;
use tempfile::NamedTempFile;
use std::io::Write;

#[test]
fn test_parse_turtle_file_not_found() {
    // Arrange
    let path = Path::new("/nonexistent/spec.ttl");

    // Act
    let result = parse_turtle(path);

    // Assert - verify error is returned for missing file
    assert!(result.is_err());
}

#[test]
fn test_generate_empty_commands() {
    // Arrange
    let commands = vec![];

    // Act
    let result = generate_cli_code(&commands);

    // Assert - verify code is generated with header
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("// Generated by ggen-clap-noun-verb"));
    assert!(code.contains("use clap::Parser"));
}

#[test]
fn test_generate_simple_command() {
    // Arrange
    let commands = vec![Command::new(
        "user".to_string(),
        "User management commands".to_string(),
    )];

    // Act
    let result = generate_cli_code(&commands);

    // Assert - verify struct is generated
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("pub struct User"));
    assert!(code.contains("/// User management commands"));
}

#[test]
fn test_generate_command_with_named_argument() {
    // Arrange
    let mut cmd = Command::new("create".to_string(), "Create resource".to_string());
    cmd.arguments.push(Argument::named(
        "name".to_string(),
        "name".to_string(),
        Some('n'),
        TypeAnnotation::String,
        true,
        "Resource name".to_string(),
    ));

    // Act
    let result = generate_cli_code(&[cmd]);

    // Assert - verify argument is generated correctly
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("pub name: String"));
    assert!(code.contains("#[arg(long = \"name\""));
    assert!(code.contains("short = 'n'"));
    assert!(code.contains("required = true"));
}

#[test]
fn test_generate_command_with_positional_argument() {
    // Arrange
    let mut cmd = Command::new("open".to_string(), "Open file".to_string());
    cmd.arguments.push(Argument::positional(
        "file".to_string(),
        0,
        TypeAnnotation::Path,
        true,
        "File to open".to_string(),
    ));

    // Act
    let result = generate_cli_code(&[cmd]);

    // Assert - verify positional argument is generated
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("pub file: std::path::PathBuf"));
    assert!(code.contains("#[arg(value_name = \"FILE\""));
}

#[test]
fn test_generate_command_with_flag() {
    // Arrange
    let mut cmd = Command::new("build".to_string(), "Build project".to_string());
    cmd.flags.push(Flag::new(
        "verbose".to_string(),
        "verbose".to_string(),
        Some('v'),
        "Enable verbose output".to_string(),
    ));

    // Act
    let result = generate_cli_code(&[cmd]);

    // Assert - verify flag is generated
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("pub verbose: bool"));
    assert!(code.contains("#[arg(long = \"verbose\""));
    assert!(code.contains("short = 'v'"));
}

#[test]
fn test_generate_command_with_subcommands() {
    // Arrange
    let mut main_cmd = Command::new("git".to_string(), "Git CLI".to_string());
    let subcmd = Command::new("clone".to_string(), "Clone repository".to_string());
    main_cmd.subcommands.push(subcmd);

    // Act
    let result = generate_cli_code(&[main_cmd]);

    // Assert - verify subcommand enum is generated
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("pub enum GitSubCommand"));
    assert!(code.contains("Clone(Clone)"));
    assert!(code.contains("pub struct Clone"));
}

#[test]
fn test_generate_multiple_type_annotations() {
    // Arrange
    let mut cmd = Command::new("test".to_string(), "Test command".to_string());
    cmd.arguments.push(Argument::named(
        "count".to_string(),
        "count".to_string(),
        None,
        TypeAnnotation::Integer,
        false,
        "Count value".to_string(),
    ));
    cmd.arguments.push(Argument::named(
        "ratio".to_string(),
        "ratio".to_string(),
        None,
        TypeAnnotation::Float,
        false,
        "Ratio value".to_string(),
    ));
    cmd.arguments.push(Argument::named(
        "enabled".to_string(),
        "enabled".to_string(),
        None,
        TypeAnnotation::Boolean,
        false,
        "Enable feature".to_string(),
    ));

    // Act
    let result = generate_cli_code(&[cmd]);

    // Assert - verify all types are generated
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("pub count: i64"));
    assert!(code.contains("pub ratio: f64"));
    assert!(code.contains("pub enabled: bool"));
}

#[test]
fn test_parse_turtle_empty_file() {
    // Arrange - create temporary empty file
    let mut temp_file = NamedTempFile::new().unwrap();
    writeln!(temp_file, "").unwrap();

    // Act
    let result = parse_turtle(temp_file.path());

    // Assert - verify empty list is returned
    assert!(result.is_ok());
    let commands = result.unwrap();
    assert_eq!(commands.len(), 0);
}

#[test]
fn test_code_generator_produces_valid_rust_syntax() {
    // Arrange
    let generator = CodeGenerator::new();
    let mut cmd = Command::new("app".to_string(), "Application".to_string());
    cmd.arguments.push(Argument::named(
        "config".to_string(),
        "config".to_string(),
        Some('c'),
        TypeAnnotation::Path,
        false,
        "Config file".to_string(),
    ));

    // Act
    let result = generator.generate(&[cmd]);

    // Assert - verify generated code has valid syntax elements
    assert!(result.is_ok());
    let code = result.unwrap();

    // Check for essential Rust syntax elements
    assert!(code.contains("use clap::Parser;"));
    assert!(code.contains("#[derive(Debug, Clone, Parser)]"));
    assert!(code.contains("pub struct App"));
    assert!(code.contains("pub config: std::path::PathBuf"));
}

#[test]
fn test_argument_default_value_generation() {
    // Arrange
    let mut cmd = Command::new("serve".to_string(), "Start server".to_string());
    let mut arg = Argument::named(
        "port".to_string(),
        "port".to_string(),
        Some('p'),
        TypeAnnotation::Integer,
        false,
        "Port number".to_string(),
    );
    arg.default = Some("8080".to_string());
    cmd.arguments.push(arg);

    // Act
    let result = generate_cli_code(&[cmd]);

    // Assert - verify default value is included
    assert!(result.is_ok());
    let code = result.unwrap();
    assert!(code.contains("default_value = \"8080\""));
}
