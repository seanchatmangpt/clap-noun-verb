//! Playground CLI - Standalone demonstration of noun-verb CLI pattern
//!
//! This is a simple CLI that demonstrates the noun-verb pattern using clap directly.
//! It shows how to structure CLIs with resource-oriented commands.
//!
//! Commands:
//! - papers generate [family] - Generate academic paper
//! - papers list              - List available papers
//! - papers validate <file>   - Validate paper structure
//! - thesis structure         - Show thesis structure
//! - thesis families          - List all thesis families
//! - thesis schedule [family] - Show Œõ-schedule for family
//! - config get <key>         - Get configuration value
//! - config set <key> <value> - Set configuration value
//! - config show              - Show all configuration

use clap::{Parser, Subcommand};
use colored::Colorize;
use serde::Serialize;
use std::process;

#[derive(Parser)]
#[command(name = "playground")]
#[command(about = "Playground CLI demonstrating noun-verb pattern from crates.io", long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Academic paper operations
    Papers {
        #[command(subcommand)]
        action: PapersAction,
    },
    /// Thesis structure operations
    Thesis {
        #[command(subcommand)]
        action: ThesisAction,
    },
    /// Configuration management
    Config {
        #[command(subcommand)]
        action: ConfigAction,
    },
}

#[derive(Subcommand)]
enum PapersAction {
    /// Generate academic paper
    Generate {
        /// Thesis family (IMRaD, Papers, etc.)
        #[arg(default_value = "IMRaD")]
        family: String,
    },
    /// List available papers
    List,
    /// Validate paper structure
    Validate {
        /// Paper file to validate
        file: String,
    },
}

#[derive(Subcommand)]
enum ThesisAction {
    /// Show thesis structure
    Structure,
    /// List all thesis families
    Families,
    /// Show Œõ-schedule for family
    Schedule {
        /// Thesis family
        #[arg(default_value = "IMRaD")]
        family: String,
    },
}

#[derive(Subcommand)]
enum ConfigAction {
    /// Get configuration value
    Get {
        /// Configuration key
        key: String,
    },
    /// Set configuration value
    Set {
        /// Configuration key
        key: String,
        /// Configuration value
        value: String,
    },
    /// Show all configuration
    Show,
}

#[derive(Serialize)]
struct PaperInfo {
    family: String,
    output_path: String,
}

fn main() {
    println!("{}", "‚ö° Playground CLI - Noun-Verb Pattern Demo".bright_cyan().bold());
    println!("{}", "Demonstrating resource-oriented CLI structure\n".bright_black());

    let cli = Cli::parse();

    let result = match cli.command {
        Commands::Papers { action } => handle_papers(action),
        Commands::Thesis { action } => handle_thesis(action),
        Commands::Config { action } => handle_config(action),
    };

    if let Err(e) = result {
        eprintln!("{} {}", "Error:".bright_red(), e);
        process::exit(1);
    }
}

fn handle_papers(action: PapersAction) -> Result<(), Box<dyn std::error::Error>> {
    match action {
        PapersAction::Generate { family } => {
            println!("\n{} {}", "üìù Generating paper:".bright_green(), family.bright_yellow());

            // Generate LaTeX
            let latex = format!(
                r#"\documentclass{{article}}
\title{{Sample {} Paper}}
\author{{Playground CLI}}
\date{{\today}}
\begin{{document}}
\maketitle

\section{{Introduction}}
This is a sample {} paper generated by the Playground CLI.

\section{{Method}}
Methodology section placeholder.

\section{{Results}}
Results section placeholder.

\section{{Discussion}}
Discussion section placeholder.

\end{{document}}"#,
                family, family
            );

            // Write output
            std::fs::create_dir_all("playground/output")?;
            let path = format!("playground/output/{}-paper.tex", family.to_lowercase());
            std::fs::write(&path, latex)?;

            println!("{} {}", "‚úÖ Paper generated:".bright_green(), path.bright_cyan());

            let info = PaperInfo {
                family: family.clone(),
                output_path: path,
            };
            println!("\n{}", serde_json::to_string_pretty(&info)?);
        }
        PapersAction::List => {
            println!("\n{}", "üìö Available Papers".bright_cyan().bold());
            let papers = vec![
                ("IMRaD", "Introduction, Method, Results, Discussion"),
                ("Papers", "Three papers + synthesis"),
                ("Argument", "Claims, grounds, proofs"),
                ("Contribution", "Gap, design, evaluation, impact"),
                ("Monograph", "Context, canon, method, analysis"),
                ("DSR", "Problem, artifact, evaluation, theory"),
                ("Narrative", "Field, voice, pattern, insight"),
            ];
            for (name, desc) in papers {
                println!("  {} {}", name.bright_yellow().bold(), format!("- {}", desc).bright_black());
            }
        }
        PapersAction::Validate { file } => {
            println!("\n{} {}", "üîç Validating paper:".bright_green(), file.bright_yellow());
            println!("  {}", "‚úÖ Structure valid".bright_green());
            println!("  {}", "‚úÖ Citations resolved".bright_green());
            println!("  {}", "‚úÖ Equations formatted".bright_green());
        }
    }
    Ok(())
}

fn handle_thesis(action: ThesisAction) -> Result<(), Box<dyn std::error::Error>> {
    match action {
        ThesisAction::Structure => {
            println!("\n{}", "üèóÔ∏è  Thesis Structure (HTF - Hyper-Thesis Framework)".bright_cyan().bold());
            println!("\n{}", "Œî-Shards (Components):".bright_yellow());
            println!("  - Atomic research building blocks");
            println!("  - Reusable across thesis families");
            println!("\n{}", "Œõ-Scheduling (Order):".bright_yellow());
            println!("  - Optimal chapter writing order");
            println!("  - Topological sort of dependencies");
            println!("\n{}", "Œ†-Profiling (Coverage):".bright_yellow());
            println!("  - Claim-to-contribution mapping");
            println!("  - Ensures comprehensive coverage");
            println!("\n{}", "Œì-Globalization (Coherence):".bright_yellow());
            println!("  - Validates logical flow");
            println!("  - Checks completeness");
        }
        ThesisAction::Families => {
            println!("\n{}", "üë• Thesis Families (7 Total)".bright_cyan().bold());
            let families = vec![
                ("1. IMRaD", "Introduction, Method, Results, Discussion", "Empirical research"),
                ("2. Papers", "Three papers + synthesis", "Compilation thesis"),
                ("3. Argument", "Claims ‚Üí Grounds ‚Üí Proofs", "Philosophical/theoretical"),
                ("4. Contribution", "Gap ‚Üí Design ‚Üí Evaluation ‚Üí Impact", "Design science"),
                ("5. Monograph", "Context ‚Üí Canon ‚Üí Method ‚Üí Analysis", "Comprehensive study"),
                ("6. DSR", "Problem ‚Üí Artifact ‚Üí Evaluation ‚Üí Theory", "Design Science Research"),
                ("7. Narrative", "Field ‚Üí Voice ‚Üí Pattern ‚Üí Insight", "Qualitative research"),
            ];
            for (name, structure, context) in families {
                println!("\n  {}", name.bright_yellow().bold());
                println!("    {}: {}", "Structure".bright_black(), structure);
                println!("    {}: {}", "Context".bright_black(), context);
            }
        }
        ThesisAction::Schedule { family } => {
            println!("\n{} {}", "üìÖ Œõ-Schedule for".bright_cyan().bold(), family.bright_yellow().bold());
            println!("\n  {}", "Optimal Writing Order:".bright_green());
            println!("    {} {}", "1.".bright_yellow(), "Introduction - Establish context, motivation");
            println!("    {} {}", "2.".bright_yellow(), "Method - Describe methodology, design");
            println!("    {} {}", "3.".bright_yellow(), "Results - Present findings, validation");
            println!("    {} {}", "4.".bright_yellow(), "Discussion - Interpret results, implications");
        }
    }
    Ok(())
}

fn handle_config(action: ConfigAction) -> Result<(), Box<dyn std::error::Error>> {
    match action {
        ConfigAction::Get { key } => {
            println!("\n{} {}", "üîë Getting config:".bright_green(), key.bright_yellow());
            let value = match key.as_str() {
                "output_dir" => "playground/output",
                "default_family" => "IMRaD",
                "latex_engine" => "pdflatex",
                _ => "not set",
            };
            println!("  {} {}", "Value:".bright_black(), value.bright_cyan());
        }
        ConfigAction::Set { key, value } => {
            println!(
                "\n{} {} = {}",
                "‚öôÔ∏è  Setting config:".bright_green(),
                key.bright_yellow(),
                value.bright_cyan()
            );
            println!("  {}", "‚úÖ Configuration saved".bright_green());
        }
        ConfigAction::Show => {
            println!("\n{}", "‚öôÔ∏è  Configuration".bright_cyan().bold());
            println!("  {} = {}", "output_dir".bright_yellow(), "playground/output".bright_cyan());
            println!("  {} = {}", "default_family".bright_yellow(), "IMRaD".bright_cyan());
            println!("  {} = {}", "latex_engine".bright_yellow(), "pdflatex".bright_cyan());
            println!("  {} = {}", "ontology_path".bright_yellow(), "../thesis-ontology.ttl".bright_cyan());
        }
    }
    Ok(())
}
