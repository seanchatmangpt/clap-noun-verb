//! Domain Logic: Shell Completion Generation
//!
//! Pure functions for generating shell completion scripts.
//! Supports Bash, Zsh, Fish, PowerShell, and Elvish.

use serde::{Deserialize, Serialize};
use super::ontology::CliCapability;

/// Supported shells for completion generation
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum ShellType {
    Bash,
    Zsh,
    Fish,
    PowerShell,
    Elvish,
}

impl ShellType {
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "bash" => Some(Self::Bash),
            "zsh" => Some(Self::Zsh),
            "fish" => Some(Self::Fish),
            "powershell" | "pwsh" => Some(Self::PowerShell),
            "elvish" => Some(Self::Elvish),
            _ => None,
        }
    }

    #[allow(dead_code)] // FUTURE: Used for shell discovery
    pub fn all() -> Vec<Self> {
        vec![Self::Bash, Self::Zsh, Self::Fish, Self::PowerShell, Self::Elvish]
    }

    pub fn name(&self) -> &'static str {
        match self {
            Self::Bash => "bash",
            Self::Zsh => "zsh",
            Self::Fish => "fish",
            Self::PowerShell => "powershell",
            Self::Elvish => "elvish",
        }
    }

    #[allow(dead_code)] // FUTURE: Used when writing completions to files
    pub fn file_extension(&self) -> &'static str {
        match self {
            Self::Bash => "bash",
            Self::Zsh => "zsh",
            Self::Fish => "fish",
            Self::PowerShell => "ps1",
            Self::Elvish => "elv",
        }
    }
}

/// Completion script output
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CompletionScript {
    pub shell: ShellType,
    pub cli_name: String,
    pub script: String,
}

/// Generate completion script for a shell (pure function)
pub fn generate_completion_script(
    cli_name: &str,
    capabilities: &[CliCapability],
    shell: ShellType,
) -> CompletionScript {
    let nouns: Vec<&str> = capabilities.iter()
        .map(|c| c.noun.as_str())
        .collect::<std::collections::HashSet<_>>()
        .into_iter()
        .collect();

    let script = match shell {
        ShellType::Bash => generate_bash_completion(cli_name, &nouns, capabilities),
        ShellType::Zsh => generate_zsh_completion(cli_name, &nouns, capabilities),
        ShellType::Fish => generate_fish_completion(cli_name, &nouns, capabilities),
        ShellType::PowerShell => generate_powershell_completion(cli_name, &nouns, capabilities),
        ShellType::Elvish => generate_elvish_completion(cli_name, &nouns, capabilities),
    };

    CompletionScript {
        shell,
        cli_name: cli_name.to_string(),
        script,
    }
}

fn generate_bash_completion(cli_name: &str, nouns: &[&str], capabilities: &[CliCapability]) -> String {
    let noun_list = nouns.join(" ");
    let mut verbs_by_noun = String::new();

    for noun in nouns {
        let verbs: Vec<&str> = capabilities.iter()
            .filter(|c| c.noun == *noun)
            .map(|c| c.verb.as_str())
            .collect();
        verbs_by_noun.push_str(&format!(
            "            {}) COMPREPLY=($(compgen -W \"{}\" -- \"$cur\")) ;;\n",
            noun, verbs.join(" ")
        ));
    }

    format!(r#"# Bash completion for {cli_name}
# Generated by clap-noun-verb v5

_{cli_name}_completions() {{
    local cur prev words cword
    _init_completion || return

    case "${{#words[@]}}" in
        2)
            COMPREPLY=($(compgen -W "{noun_list}" -- "$cur"))
            ;;
        3)
            case "$prev" in
{verbs_by_noun}            esac
            ;;
    esac
}}

complete -F _{cli_name}_completions {cli_name}
"#)
}

fn generate_zsh_completion(cli_name: &str, nouns: &[&str], capabilities: &[CliCapability]) -> String {
    let mut noun_completions = String::new();
    for noun in nouns {
        let verbs: Vec<String> = capabilities.iter()
            .filter(|c| c.noun == *noun)
            .map(|c| format!("'{}:{}'", c.verb, c.description))
            .collect();
        noun_completions.push_str(&format!(
            "        {})\n            _describe 'verb' '({})'\n            ;;\n",
            noun, verbs.join(" ")
        ));
    }

    let noun_list: Vec<String> = nouns.iter()
        .map(|n| format!("'{}:{} operations'", n, n))
        .collect();

    format!(r#"#compdef {cli_name}
# Zsh completion for {cli_name}
# Generated by clap-noun-verb v5

_{cli_name}() {{
    local -a nouns

    nouns=(
        {noun_list}
    )

    _arguments -C \
        '1:noun:->noun' \
        '2:verb:->verb' \
        '*::arg:->args'

    case $state in
    noun)
        _describe 'noun' nouns
        ;;
    verb)
        case $words[2] in
{noun_completions}        esac
        ;;
    esac
}}

_{cli_name}
"#, noun_list = noun_list.join("\n        "))
}

fn generate_fish_completion(cli_name: &str, nouns: &[&str], capabilities: &[CliCapability]) -> String {
    let mut completions = String::new();

    // Noun completions
    for noun in nouns {
        completions.push_str(&format!(
            "complete -c {} -n '__fish_use_subcommand' -a '{}' -d '{} operations'\n",
            cli_name, noun, noun
        ));
    }

    // Verb completions
    for cap in capabilities {
        completions.push_str(&format!(
            "complete -c {} -n '__fish_seen_subcommand_from {}' -a '{}' -d '{}'\n",
            cli_name, cap.noun, cap.verb, cap.description
        ));
    }

    format!("# Fish completion for {cli_name}\n# Generated by clap-noun-verb v5\n\n{completions}")
}

fn generate_powershell_completion(cli_name: &str, nouns: &[&str], capabilities: &[CliCapability]) -> String {
    let noun_list = nouns.iter()
        .map(|n| format!("'{}'", n))
        .collect::<Vec<_>>()
        .join(", ");

    let mut verb_switches = String::new();
    for noun in nouns {
        let verbs: Vec<String> = capabilities.iter()
            .filter(|c| c.noun == *noun)
            .map(|c| format!("'{}'", c.verb))
            .collect();
        verb_switches.push_str(&format!(
            "        '{}' {{ @({}) }}\n",
            noun, verbs.join(", ")
        ));
    }

    format!(r#"# PowerShell completion for {cli_name}
# Generated by clap-noun-verb v5

Register-ArgumentCompleter -Native -CommandName {cli_name} -ScriptBlock {{
    param($wordToComplete, $commandAst, $cursorPosition)

    $nouns = @({noun_list})
    $verbs = @{{
{verb_switches}    }}

    $tokens = $commandAst.ToString() -split '\s+'

    if ($tokens.Count -eq 1) {{
        $nouns | Where-Object {{ $_ -like "$wordToComplete*" }} | ForEach-Object {{
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
        }}
    }} elseif ($tokens.Count -eq 2) {{
        $noun = $tokens[1]
        if ($verbs.ContainsKey($noun)) {{
            $verbs[$noun] | Where-Object {{ $_ -like "$wordToComplete*" }} | ForEach-Object {{
                [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
            }}
        }}
    }}
}}
"#)
}

fn generate_elvish_completion(cli_name: &str, nouns: &[&str], capabilities: &[CliCapability]) -> String {
    let noun_list = nouns.join(" ");
    let mut verb_maps = String::new();

    for noun in nouns {
        let verbs: Vec<&str> = capabilities.iter()
            .filter(|c| c.noun == *noun)
            .map(|c| c.verb.as_str())
            .collect();
        verb_maps.push_str(&format!(
            "  &{} = [{}]\n",
            noun, verbs.join(" ")
        ));
    }

    format!(r#"# Elvish completion for {cli_name}
# Generated by clap-noun-verb v5

edit:completion:arg-completer[{cli_name}] = {{|@args|
    var nouns = [{noun_list}]
    var verbs = [
{verb_maps}    ]

    if (== (count $args) 2) {{
        put $@nouns
    }} elif (== (count $args) 3) {{
        var noun = $args[1]
        if (has-key $verbs $noun) {{
            put $@verbs[$noun]
        }}
    }}
}}
"#)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::ontology::build_playground_ontology;

    #[test]
    fn test_shell_type_parsing() {
        assert_eq!(ShellType::from_str("bash"), Some(ShellType::Bash));
        assert_eq!(ShellType::from_str("ZSH"), Some(ShellType::Zsh));
        assert_eq!(ShellType::from_str("unknown"), None);
    }

    #[test]
    fn test_generate_bash_completion() {
        let caps = build_playground_ontology();
        let script = generate_completion_script("playground", &caps, ShellType::Bash);
        assert!(script.script.contains("_playground_completions"));
        assert!(script.script.contains("papers"));
    }

    #[test]
    fn test_generate_all_shells() {
        let caps = build_playground_ontology();
        for shell in ShellType::all() {
            let script = generate_completion_script("playground", &caps, shell);
            assert!(!script.script.is_empty(), "Empty script for {:?}", shell);
        }
    }
}
