\chapter{Architectural Design}

\section{Core Components}

\subsection{Type System Foundation}

The architecture rests on three type primitives:

\begin{description}
    \item[CommandHandler] Trait defining command execution semantics
    \item[CommandMetadata] Introspectable command structure
    \item[CommandArgs] Type-safe argument container
    \item[AgentCliBuilder] Stateful CLI construction interface
    \item[AgentCli] Immutable execution environment
\end{description}

\section{Handler Architecture}

\subsection{CommandHandler Trait}

\begin{lstlisting}[language=Rust]
pub trait CommandHandler: Send + Sync {
    fn execute(&self, args: &CommandArgs)
        -> AgentResult<serde_json::Value>;

    fn metadata(&self) -> CommandMetadata;
}
\end{lstlisting}

\textbf{Design Properties}:
\begin{itemize}
    \item \texttt{Send + Sync} for thread-safe execution
    \item JSON output for agent interchange
    \item Metadata for introspection
    \item Immutable after construction (no state mutation)
\end{itemize}

\subsection{Dynamic Dispatch Pattern}

Storage via trait objects:
\begin{lstlisting}[language=Rust]
struct DynamicCommand {
    metadata: CommandMetadata,
    handler: Arc<dyn CommandHandler>,
}

pub struct AgentCli {
    commands: HashMap<String, DynamicCommand>,
    // ...
}
\end{lstlisting}

Single level of indirection for polymorphic dispatch.

\section{Builder Pattern}

\subsection{Stateful Construction}

The \texttt{AgentCliBuilder} provides mutable construction interface:

\begin{lstlisting}[language=Rust]
pub struct AgentCliBuilder {
    name: String,
    description: String,
    commands: HashMap<String, DynamicCommand>,
    version: Option<String>,
}

impl AgentCliBuilder {
    pub fn register_command(
        &mut self,
        name: impl Into<String>,
        description: impl Into<String>,
        handler: Arc<dyn CommandHandler>,
    ) -> AgentResult<&mut Self> {
        // Validation + registration
        Ok(self)
    }

    pub fn build(self) -> AgentResult<AgentCli> {
        // Move semantics - prevents double-build
        Ok(AgentCli { /* ... */ })
    }
}
\end{lstlisting}

\textbf{Design Rationale}:
\begin{itemize}
    \item Mutable self for ergonomics during construction
    \item Consuming \texttt{build()} prevents accidental reuse
    \item Error propagation via \texttt{AgentResult<T>}
\end{itemize}

\section{Command Argument System}

\subsection{CommandArgs Design}

\begin{lstlisting}[language=Rust]
#[derive(Debug, Clone)]
pub struct CommandArgs {
    pub values: HashMap<String, String>,
    pub positional: Vec<String>,
}

impl CommandArgs {
    pub fn contains(&self, name: &str) -> bool { /*...*/ }
    pub fn get(&self, name: &str) -> Option<&str> { /*...*/ }
    pub fn get_all_positional(&self) -> &[String] { /*...*/ }
    pub fn len(&self) -> usize { /*...*/ }
}
\end{lstlisting}

Separate storage for:
\begin{itemize}
    \item \textbf{Named args}: O(1) lookup via HashMap
    \item \textbf{Positional}: Ordered preservation via Vec
    \item \textbf{Total count}: Efficient via both.len() operations
\end{itemize}

\section{Execution Flow}

\subsection{Command Invocation Pipeline}

\begin{figure}[H]
\centering
\begin{verbatim}
┌──────────────────────────┐
│  Agent (CLI Entry)       │
└────────┬─────────────────┘
         │ .execute("cmd", args)
         ▼
┌──────────────────────────┐
│  AgentCli::execute()     │  ← HashMap lookup O(1)
└────────┬─────────────────┘
         │ Get DynamicCommand
         ▼
┌──────────────────────────┐
│  Trait Object Dispatch   │  ← Single vtable indirection
└────────┬─────────────────┘
         │ Call handler.execute()
         ▼
┌──────────────────────────┐
│  Concrete Handler        │  ← Monomorphized code
└────────┬─────────────────┘
         │ Return JSON result
         ▼
┌──────────────────────────┐
│  Agent receives result   │
└──────────────────────────┘
\end{verbatim}
\end{figure}

\textbf{Latency Analysis}:
\begin{align}
\text{Total} &= \text{HashMap lookup} + \text{Trait dispatch} + \text{Handler}\\
&\approx 50\text{ns} + 20\text{ns} + 230\text{ns}\\
&\approx 300\text{ns}
\end{align}

\section{Error Handling}

\subsection{Error Types}

\begin{lstlisting}[language=Rust]
pub enum AgentBuilderError {
    DuplicateCommand(String),
    InvalidCommandName(String),
    NoCommands,
    HandlerFailed(String),
    ValidationFailed(String),
}
\end{lstlisting}

All errors are deterministic, none panic or abort.

\section{Memory Layout}

\subsection{Per-Command Overhead}

\begin{table}[H]
\centering
\begin{tabular}{lrl}
\toprule
Component & Size & Count \\
\midrule
Command name (String) & 24 bytes & 1 \\
Description (String) & 24 bytes & 1 \\
Handler Arc<T> & 8 bytes & 1 \\
Metadata struct & 64 bytes & 1 \\
HashMap entry & 32 bytes & 1 \\
\midrule
\textbf{Total} & \textbf{$\approx$152 bytes} & \textbf{per command} \\
\bottomrule
\end{tabular}
\end{table}

Scales linearly with O(n) complexity.

\section{Type Safety Properties}

\subsection{Compile-Time Guarantees}

\begin{itemize}
    \item Handlers are \texttt{Send + Sync} verified at compile time
    \item No \texttt{unsafe} code in public API
    \item All error paths explicit via \texttt{Result<T>}
    \item Lifetime safety through Rust's borrow checker
\end{itemize}

\subsection{Runtime Invariants}

\begin{itemize}
    \item Commands immutable after \texttt{build()}
    \item No NULL pointer dereference (Option/Result only)
    \item FIFO execution order preserved
    \item JSON serialization lossless
\end{itemize}
