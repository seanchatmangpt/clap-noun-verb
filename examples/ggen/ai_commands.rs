//! AI command implementations with enhanced error handling
//!
//! This module implements ggen's AI commands with user-friendly error messages
//! and comprehensive input validation.

use clap_noun_verb::Result as CnvResult;
use clap_noun_verb_macros::verb;
use serde::Serialize;

use super::errors::UserError;
use super::validators::{
    validate_api_key, validate_model_name, validate_output_path, validate_prompt,
};

// ============================================================================
// Data Types
// ============================================================================

#[derive(Serialize, Debug)]
pub struct GenerateOutput {
    pub description: String,
    pub model: String,
    pub output: String,
    pub success: bool,
    pub content: String,
    pub tokens_used: u32,
}

#[derive(Serialize, Debug)]
pub struct ProjectOutput {
    pub name: String,
    pub description: Option<String>,
    pub model: String,
    pub success: bool,
    pub files_created: Vec<String>,
}

#[derive(Serialize, Debug)]
pub struct GraphOutput {
    pub description: String,
    pub output: String,
    pub success: bool,
    pub triples_count: usize,
    pub format: String,
}

#[derive(Serialize, Debug)]
pub struct SparqlOutput {
    pub description: String,
    pub graph: Option<String>,
    pub success: bool,
    pub query: String,
}

// ============================================================================
// Business Logic (Pure Functions)
// ============================================================================

/// Generate content using AI model
fn generate_ai_content(
    description: &str,
    model: &str,
    output: &str,
) -> Result<GenerateOutput, UserError> {
    // Simulate API call
    // In production, this would call OpenAI/Anthropic API

    let content = format!(
        "// Generated by {} based on: {}\n\
        // This is a simulated output\n\
        \n\
        pub fn example() {{\n\
            // Implementation here\n\
        }}\n",
        model, description
    );

    Ok(GenerateOutput {
        description: description.to_string(),
        model: model.to_string(),
        output: output.to_string(),
        success: true,
        content,
        tokens_used: 150,
    })
}

/// Generate a complete project structure
fn generate_ai_project(
    name: &str,
    description: Option<&str>,
    model: &str,
    template: Option<&str>,
) -> Result<ProjectOutput, UserError> {
    // Validate project name
    if name.trim().is_empty() {
        return Err(UserError::new(
            super::errors::ErrorCategory::Validation,
            "Project name cannot be empty",
            "Provide a valid project name:\n  \
            ggen ai project MyProject --description 'A web service'"
                .to_string(),
        ));
    }

    // Simulate project generation
    let files = if template.is_some() {
        vec![
            format!("{}/src/main.rs", name),
            format!("{}/Cargo.toml", name),
            format!("{}/README.md", name),
            format!("{}/.gitignore", name),
        ]
    } else {
        vec![format!("{}/src/lib.rs", name), format!("{}/Cargo.toml", name)]
    };

    Ok(ProjectOutput {
        name: name.to_string(),
        description: description.map(String::from),
        model: model.to_string(),
        success: true,
        files_created: files,
    })
}

/// Generate RDF ontology graph
fn generate_rdf_graph(
    description: &str,
    output: &str,
    format: &str,
) -> Result<GraphOutput, UserError> {
    // Validate RDF format
    let valid_formats = ["turtle", "rdfxml", "ntriples", "jsonld"];
    if !valid_formats.contains(&format) {
        return Err(UserError::new(
            super::errors::ErrorCategory::Validation,
            format!("Invalid RDF format '{}'", format),
            format!(
                "Use one of the supported formats:\n{}\n\n  \
                Example: ggen ai graph -d 'ontology description' --format turtle",
                valid_formats.iter().map(|f| format!("  - {}", f)).collect::<Vec<_>>().join("\n")
            ),
        )
        .with_docs("https://docs.ggen.io/rdf"));
    }

    Ok(GraphOutput {
        description: description.to_string(),
        output: output.to_string(),
        success: true,
        triples_count: 42,
        format: format.to_string(),
    })
}

/// Generate SPARQL query
fn generate_sparql_query(
    description: &str,
    graph: Option<&str>,
) -> Result<SparqlOutput, UserError> {
    // Validate graph file if provided
    if let Some(graph_path) = graph {
        if !std::path::Path::new(graph_path).exists() {
            return Err(super::errors::file_error(graph_path, "read", "file does not exist"));
        }
    }

    let query = format!(
        "# Generated SPARQL query for: {}\n\
        PREFIX ex: <http://example.org/>\n\
        \n\
        SELECT ?subject ?predicate ?object\n\
        WHERE {{\n\
          ?subject ?predicate ?object .\n\
        }}\n\
        LIMIT 100",
        description
    );

    Ok(SparqlOutput {
        description: description.to_string(),
        graph: graph.map(String::from),
        success: true,
        query,
    })
}

// ============================================================================
// CLI Layer (Input Validation + Delegation)
// ============================================================================

/// Generate code, templates, or content using AI
///
/// # Arguments
/// * `description` - What to generate (required, -d/--description)
/// * `model` - AI model to use (optional, defaults to gpt-4-turbo)
/// * `output` - Output file path (optional, defaults to stdout)
///
/// # Examples
/// ```bash
/// # Generate a REST API handler
/// ggen ai generate -d "REST API handler for user auth" --model gpt-4-turbo
///
/// # Generate to file
/// ggen ai generate -d "Create a CLI parser" --output src/parser.rs
/// ```
#[verb("generate", "ai")]
pub fn ai_generate(
    #[arg(short, long)] description: String,
    #[arg(short, long, default_value = "gpt-4-turbo")] model: String,
    #[arg(short, long, default_value = "stdout")] output: String,
) -> CnvResult<GenerateOutput> {
    // Validate inputs with user-friendly error messages
    let validated_prompt = validate_prompt(&description)
        .map_err(|e| clap_noun_verb::NounVerbError::ValidationFailed(e.to_string()))?;

    let validated_model = validate_model_name(&model)
        .map_err(|e| clap_noun_verb::NounVerbError::ValidationFailed(e.to_string()))?;

    let validated_output = if output != "stdout" {
        validate_output_path(&output)
            .map_err(|e| clap_noun_verb::NounVerbError::ValidationFailed(e.to_string()))?
    } else {
        output.clone()
    };

    // Check API key is configured
    let provider = if validated_model.starts_with("gpt") {
        "openai"
    } else if validated_model.starts_with("claude") {
        "anthropic"
    } else {
        "openai"
    };

    validate_api_key(provider)
        .map_err(|e| clap_noun_verb::NounVerbError::ValidationFailed(e.to_string()))?;

    // Delegate to business logic
    generate_ai_content(&validated_prompt, &validated_model, &validated_output)
        .map_err(|e| clap_noun_verb::NounVerbError::ExecutionError { message: e.to_string() })
}

/// Generate a complete project using AI
///
/// # Arguments
/// * `name` - Project name (required)
/// * `description` - Project description (optional)
/// * `model` - AI model to use (optional)
/// * `template` - Base template to use (optional)
///
/// # Examples
/// ```bash
/// # Generate a Rust web service
/// ggen ai project MyService --description "REST API with authentication"
///
/// # Use specific template
/// ggen ai project MyApp --template rust-axum
/// ```
#[verb("project", "ai")]
pub fn ai_project(
    name: String,
    #[arg(short, long)] description: Option<String>,
    #[arg(short, long, default_value = "gpt-4-turbo")] model: String,
    #[arg(short, long)] template: Option<String>,
) -> CnvResult<ProjectOutput> {
    // Validate model
    let validated_model = validate_model_name(&model)
        .map_err(|e| clap_noun_verb::NounVerbError::ValidationFailed(e.to_string()))?;

    // Validate description if provided
    if let Some(ref desc) = description {
        validate_prompt(desc)
            .map_err(|e| clap_noun_verb::NounVerbError::ValidationFailed(e.to_string()))?;
    }

    // Check API key
    let provider = if validated_model.starts_with("gpt") { "openai" } else { "anthropic" };

    validate_api_key(provider)
        .map_err(|e| clap_noun_verb::NounVerbError::ValidationFailed(e.to_string()))?;

    // Delegate to business logic
    generate_ai_project(&name, description.as_deref(), &validated_model, template.as_deref())
        .map_err(|e| clap_noun_verb::NounVerbError::ExecutionError { message: e.to_string() })
}

/// Generate an RDF ontology graph using AI
///
/// # Arguments
/// * `description` - What the ontology should represent
/// * `output` - Output file path (optional)
/// * `format` - RDF format (turtle, rdfxml, ntriples, jsonld)
///
/// # Examples
/// ```bash
/// # Generate ontology in Turtle format
/// ggen ai graph -d "E-commerce domain model" --format turtle
///
/// # Save to file
/// ggen ai graph -d "Music metadata" -o ontology.ttl
/// ```
#[verb("graph", "ai")]
pub fn ai_graph(
    #[arg(short, long)] description: String,
    #[arg(short, long, default_value = "ontology.ttl")] output: String,
    #[arg(short, long, default_value = "turtle")] format: String,
) -> CnvResult<GraphOutput> {
    // Validate inputs
    let validated_prompt = validate_prompt(&description)
        .map_err(|e| clap_noun_verb::NounVerbError::ValidationFailed(e.to_string()))?;

    let validated_output = validate_output_path(&output)
        .map_err(|e| clap_noun_verb::NounVerbError::ValidationFailed(e.to_string()))?;

    // Delegate to business logic
    generate_rdf_graph(&validated_prompt, &validated_output, &format)
        .map_err(|e| clap_noun_verb::NounVerbError::ExecutionError { message: e.to_string() })
}

/// Generate a SPARQL query using AI
///
/// # Arguments
/// * `description` - What the query should find
/// * `graph` - Graph file to query against (optional)
///
/// # Examples
/// ```bash
/// # Generate SPARQL query
/// ggen ai sparql -d "Find all people and their emails"
///
/// # Query specific graph
/// ggen ai sparql -d "Products under $100" --graph products.ttl
/// ```
#[verb("sparql", "ai")]
pub fn ai_sparql(
    #[arg(short, long)] description: String,
    #[arg(short, long)] graph: Option<String>,
) -> CnvResult<SparqlOutput> {
    // Validate inputs
    let validated_prompt = validate_prompt(&description)
        .map_err(|e| clap_noun_verb::NounVerbError::ValidationFailed(e.to_string()))?;

    // Delegate to business logic
    generate_sparql_query(&validated_prompt, graph.as_deref())
        .map_err(|e| clap_noun_verb::NounVerbError::ExecutionError { message: e.to_string() })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_ai_content_success() {
        let result = generate_ai_content("Create a function", "gpt-4-turbo", "output.rs");
        assert!(result.is_ok());

        let output = result.unwrap();
        assert_eq!(output.model, "gpt-4-turbo");
        assert!(output.content.contains("Generated by"));
    }

    #[test]
    fn test_generate_ai_project_success() {
        let result =
            generate_ai_project("TestProject", Some("A test project"), "gpt-4-turbo", None);
        assert!(result.is_ok());

        let output = result.unwrap();
        assert_eq!(output.name, "TestProject");
        assert!(!output.files_created.is_empty());
    }

    #[test]
    fn test_generate_ai_project_empty_name() {
        let result = generate_ai_project("", None, "gpt-4-turbo", None);
        assert!(result.is_err());
    }

    #[test]
    fn test_generate_rdf_graph_success() {
        let result = generate_rdf_graph("Test ontology", "test.ttl", "turtle");
        assert!(result.is_ok());
    }

    #[test]
    fn test_generate_rdf_graph_invalid_format() {
        let result = generate_rdf_graph("Test ontology", "test.ttl", "invalid");
        assert!(result.is_err());

        let err = result.unwrap_err();
        assert!(err.problem.contains("Invalid RDF format"));
    }

    #[test]
    fn test_generate_sparql_query_success() {
        let result = generate_sparql_query("Find all data", None);
        assert!(result.is_ok());

        let output = result.unwrap();
        assert!(output.query.contains("SELECT"));
    }
}
