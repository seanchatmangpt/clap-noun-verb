# Reference: Complete API Catalog

**Purpose:** Quick lookup of all public types, traits, and functions for AI agents.

**Last Updated:** 2025-11-20
**Target Audience:** AI agents, code generators, automated tooling
**Cognitive Load:** Minimal - structured for fast lookup

---

## Core Types

### Command Registration

#### Noun Decorator
```rust
#[noun(name = "string")]
fn function_name() -> ReturnType
```

**Parameters:**
- `name`: Command name (kebab-case, required)
- `about`: Help text (optional)
- `aliases`: Alternative names (optional)

**Example:**
```rust
#[noun(name = "services")]
fn services_command() -> Result<()> {
    Ok(())
}
```

#### Verb Decorator
```rust
#[verb(name = "string", noun = "parent")]
fn function_name(args...) -> Result<T>
```

**Parameters:**
- `name`: Command name (kebab-case, required)
- `noun`: Parent noun (required)
- `about`: Help text (optional)
- `aliases`: Alternative names (optional)

**Example:**
```rust
#[verb(name = "status", noun = "services")]
fn status_command() -> Result<()> {
    Ok(())
}
```

#### Argument Attributes
```rust
#[arg(
    env = "ENV_VAR",           // Environment variable fallback
    default_value = "value",   // Default value
    index = 0,                 // Positional argument
    short = 'c',               // Short flag
    long = "config",           // Long flag
    value_parser = parser_fn,  // Custom parser
)]
param: Type
```

---

## Type Signatures

### CommandRegistry
```rust
pub struct CommandRegistry {
    // Singleton command registry
}

impl CommandRegistry {
    pub fn new() -> Self
    pub fn with_config(config: RegistryConfig) -> Self

    // Configuration
    pub fn name(self, name: impl Into<String>) -> Self
    pub fn about(self, about: impl Into<String>) -> Self
    pub fn version(self, version: impl Into<String>) -> Self
    pub fn global_args(self, args: Vec<clap::Arg>) -> Self
    pub fn auto_validate(self, enable: bool) -> Self

    // Registration
    pub fn register_noun(self, noun: impl NounCommand + 'static) -> Self
    pub fn register_nouns<I>(self, nouns: I) -> Self

    // Query
    pub fn get_noun(&self, name: &str) -> Option<&dyn NounCommand>
    pub fn noun_names(&self) -> Vec<&str>
    pub fn has_noun(&self, name: &str) -> bool
    pub fn command_structure(&self) -> HashMap<String, Vec<String>>

    // Validation
    pub fn validate(&self) -> Result<()>

    // Execution
    pub fn build_command(&self) -> Command
    pub fn route(&self, matches: &ArgMatches) -> Result<()>
    pub fn run(self) -> Result<()>
    pub fn run_with_args(self, args: Vec<String>) -> Result<()>
}
```

### CliBuilder
```rust
pub struct CliBuilder {
    registry: CommandRegistry,
}

impl CliBuilder {
    pub fn new() -> Self

    // Configuration (builder pattern)
    pub fn name(self, name: impl Into<String>) -> Self
    pub fn about(self, about: impl Into<String>) -> Self
    pub fn version(self, version: impl Into<String>) -> Self
    pub fn global_args(self, args: Vec<clap::Arg>) -> Self
    pub fn auto_validate(self, enable: bool) -> Self

    // Registration
    pub fn noun(self, noun: impl NounCommand + 'static) -> Self
    pub fn nouns<I>(self, nouns: I) -> Self

    // Execution
    pub fn run(self) -> Result<()>
    pub fn run_with_args(self, args: Vec<String>) -> Result<()>
    pub fn build_command(self) -> Command
}
```

### NounCommand
```rust
pub trait NounCommand: Send + Sync {
    fn name(&self) -> &'static str;
    fn about(&self) -> &'static str;
    fn verbs(&self) -> Vec<Box<dyn VerbCommand>>;
    fn sub_nouns(&self) -> Vec<Box<dyn NounCommand>>;
    fn build_command(&self) -> Command;
    fn handle_direct(&self, args: &VerbArgs) -> Result<()>;
    fn handle_verb(&self, verb_name: &str, args: &VerbArgs) -> Result<()>;
    fn handle_sub_noun(&self, sub_noun_name: &str, args: &VerbArgs) -> Result<()>;
}
```

**Implementations:**
- Auto-generated by `#[noun]` macro
- Manual implementation for custom nouns

### VerbCommand
```rust
pub trait VerbCommand: Send + Sync {
    fn name(&self) -> &'static str;
    fn about(&self) -> &'static str;
    fn run(&self, args: &VerbArgs) -> Result<()>;
    fn build_command(&self) -> Command;
    fn additional_args(&self) -> Vec<clap::Arg>;
}
```

**Implementations:**
- Auto-generated by `#[verb]` macro
- Manual implementation for custom verbs

### VerbArgs
```rust
pub struct VerbArgs {
    pub matches: ArgMatches,
    pub parent_matches: Option<ArgMatches>,
    pub context: VerbContext,
}

impl VerbArgs {
    pub fn new(matches: ArgMatches) -> Self
    pub fn with_parent(self, parent: ArgMatches) -> Self
    pub fn with_context(self, context: VerbContext) -> Self

    // String arguments
    pub fn get_one_str(&self, name: &str) -> Result<String>
    pub fn get_one_str_opt(&self, name: &str) -> Option<String>

    // Typed arguments
    pub fn get_one<T: Clone + Send + Sync + 'static>(&self, name: &str) -> Result<T>
    pub fn get_one_opt<T: Clone + Send + Sync + 'static>(&self, name: &str) -> Option<T>
    pub fn get_many<T: Clone + Send + Sync + 'static>(&self, name: &str) -> Result<Vec<T>>
    pub fn get_many_opt<T: Clone + Send + Sync + 'static>(&self, name: &str) -> Vec<T>

    // Flags
    pub fn is_flag_set(&self, name: &str) -> bool
    pub fn get_flag_count(&self, name: &str) -> u8

    // Paths
    pub fn get_path(&self, name: &str) -> Result<PathBuf>
    pub fn get_path_opt(&self, name: &str) -> Option<PathBuf>

    // Global arguments
    pub fn get_global<T: Clone + Send + Sync + 'static>(&self, name: &str) -> Option<T>
    pub fn get_global_str(&self, name: &str) -> Option<String>
    pub fn is_global_flag_set(&self, name: &str) -> bool
    pub fn get_global_flag_count(&self, name: &str) -> u8

    // Context
    pub fn verb(&self) -> &str
    pub fn noun(&self) -> Option<&str>
    pub fn get_context(&self, key: &str) -> Option<&String>
    pub fn arg_names_refs(&self) -> Vec<&str>
}
```

### VerbContext
```rust
pub struct VerbContext {
    pub verb: String,
    pub noun: Option<String>,
    pub data: HashMap<String, String>,
}

impl VerbContext {
    pub fn new(verb: impl Into<String>) -> Self
    pub fn with_noun(self, noun: impl Into<String>) -> Self
    pub fn with_data(self, key: impl Into<String>, value: impl Into<String>) -> Self
    pub fn get_data(&self, key: &str) -> Option<&String>
}
```

---

## Error Types

### NounVerbError
```rust
pub enum NounVerbError {
    CommandNotFound { noun: String },
    VerbNotFound { noun: String, verb: String },
    InvalidStructure { message: String },
    ExecutionError { message: String },
    ArgumentError { message: String },
    PluginError(String),
    ValidationFailed(String),
    MiddlewareError(String),
    TelemetryError(String),
    Generic(String),
}
```

**Constructors:**
```rust
impl NounVerbError {
    pub fn command_not_found(noun: impl Into<String>) -> Self
    pub fn verb_not_found(noun: impl Into<String>, verb: impl Into<String>) -> Self
    pub fn invalid_structure(message: impl Into<String>) -> Self
    pub fn execution_error(message: impl Into<String>) -> Self
    pub fn argument_error(message: impl Into<String>) -> Self
    pub fn missing_argument(name: impl Into<String>) -> Self
    pub fn validation_error(name: impl Into<String>, value: impl Into<String>, constraints: Option<&str>) -> Self
    pub fn validation_range_error(name: impl Into<String>, value: impl Into<String>, min: Option<&str>, max: Option<&str>) -> Self
    pub fn validation_length_error(name: impl Into<String>, value: impl Into<String>, min: Option<usize>, max: Option<usize>) -> Self
}
```

**Conversion:**
```rust
// Auto-implemented via thiserror:
impl std::fmt::Display for NounVerbError
impl std::error::Error for NounVerbError
```

### Result Type
```rust
pub type Result<T> = std::result::Result<T, NounVerbError>;
```

---

## Macro System

### #[noun]

**Signature:**
```rust
#[noun(
    name = "string",        // Required: Command name (kebab-case)
    about = "description",  // Optional: Help text
    aliases = ["a", "b"],   // Optional: Alternative names
)]
fn handler() -> Result<T>
```

**Generated:**
- Static `CommandRegistry` entry via `linkme`
- `NounCommand` trait implementation
- Help text integration
- Automatic discovery at compile time

**Example:**
```rust
#[noun(name = "services", about = "Manage services")]
fn services() -> Result<()> {
    Ok(())
}
```

### #[verb]

**Signature:**
```rust
#[verb(
    name = "string",        // Required: Command name (kebab-case)
    noun = "parent",        // Required: Parent noun name
    about = "description",  // Optional: Help text
    aliases = ["a", "b"],   // Optional: Alternative names
)]
fn handler(args...) -> Result<T>
```

**Argument Types (auto-inferred):**
- Primitives: `i32`, `u64`, `String`, `bool`
- Paths: `PathBuf`
- Options: `Option<T>`
- Vectors: `Vec<T>`
- Custom: `impl FromStr + Clone + Send + Sync + 'static`

**Generated:**
- Static `CommandRegistry` entry via `linkme`
- `VerbCommand` trait implementation
- Argument parsing from function signature
- Help text integration

**Example:**
```rust
#[verb(name = "status", noun = "services", about = "Show service status")]
fn status(
    #[arg(short = 'f', long = "format", default_value = "json")]
    format: String,
    #[arg(long = "verbose")]
    verbose: bool,
) -> Result<()> {
    Ok(())
}
```

### #[arg]

**Signature:**
```rust
#[arg(
    short = 'c',                    // Short flag (e.g., -c)
    long = "config",                // Long flag (e.g., --config)
    env = "CONFIG_FILE",            // Environment variable fallback
    default_value = "config.toml",  // Default value
    index = 0,                      // Positional argument (0-indexed)
    value_parser = parser_fn,       // Custom parser function
    help = "Help text",             // Help text for this arg
)]
```

**Applied to:** Function parameters in `#[verb]` functions

---

## v5 Autonomic API

### TelemetryCollector
```rust
pub struct TelemetryCollector {
    metrics: MetricsCollector,
    tracing: TracingCollector,
    enabled: bool,
}

impl TelemetryCollector {
    pub fn new() -> Self

    // Control
    pub fn enable(&mut self)
    pub fn disable(&mut self)
    pub fn is_enabled(&self) -> bool

    // Access collectors
    pub fn metrics(&self) -> &MetricsCollector
    pub fn metrics_mut(&mut self) -> &mut MetricsCollector
    pub fn tracing(&self) -> &TracingCollector
    pub fn tracing_mut(&mut self) -> &mut TracingCollector

    // Recording
    pub fn record_command(&self, command: &str, duration_ms: u64) -> Result<()>
    pub fn record_error(&self, command: &str, error: &str) -> Result<()>

    // Span creation
    pub fn span(&self, name: impl Into<String>) -> SpanBuilder

    // Export
    pub fn export_metrics<E: MetricsExporter>(&self, exporter: &E) -> Result<String>
}
```

### Span
```rust
pub struct Span {
    name: String,
    id: String,
    parent_id: Option<String>,
    trace_id: String,
    start_time: u64,
    end_time: Option<u64>,
    status: SpanStatus,
    attributes: HashMap<String, String>,
    events: Vec<SpanEvent>,
}

impl Span {
    pub fn new(name: impl Into<String>, trace_id: impl Into<String>) -> Self
    pub fn with_parent(self, parent_id: impl Into<String>) -> Self
    pub fn with_attribute(self, key: impl Into<String>, value: impl Into<String>) -> Self

    pub fn end_ok(&mut self)
    pub fn end_error(&mut self, error: impl Into<String>)
    pub fn add_event(&mut self, name: impl Into<String>)

    // Getters
    pub fn name(&self) -> &str
    pub fn id(&self) -> &str
    pub fn trace_id(&self) -> &str
    pub fn parent_id(&self) -> Option<&str>
    pub fn status(&self) -> SpanStatus
    pub fn duration_ms(&self) -> Option<u64>
    pub fn attributes(&self) -> &HashMap<String, String>
    pub fn events(&self) -> &[SpanEvent]
}
```

### SpanBuilder
```rust
pub struct SpanBuilder {
    name: String,
    parent_id: Option<String>,
    attributes: HashMap<String, String>,
}

impl SpanBuilder {
    pub fn new(name: impl Into<String>) -> Self
    pub fn with_parent(self, parent_id: impl Into<String>) -> Self
    pub fn with_attribute(self, key: impl Into<String>, value: impl Into<String>) -> Self
    pub fn build(self, trace_id: impl Into<String>) -> Span
}
```

### SpanStatus
```rust
pub enum SpanStatus {
    Unset,   // Span is running
    Ok,      // Span completed successfully
    Error,   // Span encountered an error
}
```

### TracingCollector
```rust
pub struct TracingCollector {
    spans: Vec<Span>,
    current_trace_id: String,
}

impl TracingCollector {
    pub fn new() -> Self
    pub fn new_trace(&mut self)
    pub fn current_trace_id(&self) -> &str
    pub fn add_span(&mut self, span: Span)
    pub fn spans(&self) -> &[Span]
    pub fn span_count(&self) -> usize
    pub fn clear(&mut self)
    pub fn spans_by_status(&self, status: SpanStatus) -> Vec<&Span>
    pub fn total_duration_ms(&self) -> u64
}
```

### MetricsCollector
```rust
pub struct MetricsCollector {
    // Internal state
}

impl MetricsCollector {
    pub fn new() -> Self
    pub fn record_command_execution(&self, command: &str, duration_ms: u64) -> Result<()>
    pub fn record_command_error(&self, command: &str, error: &str) -> Result<()>
    pub fn command_count(&self) -> usize
}
```

---

## Type Inference

The macro system infers argument types from function signatures:

| Rust Type | Clap Type | CLI Example | Notes |
|-----------|-----------|-------------|-------|
| `String` | `value` | `"hello"` | Required string value |
| `PathBuf` | `value` | `"file.txt"` | Path argument |
| `i32`, `u64` | `value` | `42` | Numeric value |
| `bool` | `flag` | `--verbose` | Boolean flag (SetTrue) |
| `usize` | `count` | `-vvv` | Count flag (Count action) |
| `Option<T>` | `optional` | `--output <file>` | Optional argument |
| `Vec<T>` | `multiple` | `--tags a b c` | Multiple values |

**Auto-inference rules:**
- `bool` → `SetTrue` action (flag present = true)
- `usize` → `Count` action (flag count: -v = 1, -vv = 2, etc.)
- `Option<T>` → Optional argument (not required)
- `Vec<T>` → Multiple values allowed

---

## Memory Layout

All types are:
- ✅ `Send + Sync` (thread-safe, can be shared across threads)
- ✅ Zero-cost (macro-generated at compile time)
- ✅ No runtime overhead vs. raw clap
- ✅ Static lifetime for string constants (via `Box::leak`)

**Performance characteristics:**
- Command registration: Compile-time only (zero runtime cost)
- Command routing: O(1) hashmap lookup
- Argument parsing: Same as raw clap (zero overhead)

---

## Feature Flags

```toml
[dependencies.clap-noun-verb]
version = "5.0.0"
features = [
    "autonomic",  # v5 machine-grade API (telemetry, observability)
    "mcp",        # Model Context Protocol support
    "rdf",        # RDF/SPARQL support for ontology control
    "plugins",    # Plugin system
    "middleware", # Middleware system
]
```

**Default features:** None (minimal by default)

**Feature dependencies:**
- `autonomic` → requires `telemetry`, `tracing`
- `mcp` → requires `serde`, `serde_json`
- `rdf` → requires `sophia`, `sparql`

---

## Quick Reference

### Most Common Operations

**Define commands:**
```rust
#[noun(name = "services")]
fn services() -> Result<()> { Ok(()) }

#[verb(name = "status", noun = "services")]
fn status() -> Result<()> { Ok(()) }
```

**Parse arguments:**
```rust
fn my_verb(
    #[arg(short = 'n', long = "name")] name: String,
    #[arg(long = "verbose")] verbose: bool,
) -> Result<()> {
    println!("Name: {}, Verbose: {}", name, verbose);
    Ok(())
}
```

**Run CLI:**
```rust
fn main() -> Result<()> {
    run_cli()  // Auto-discovers all #[noun] and #[verb] functions
}
```

**Return types:**
- `Result<T>` - For failable operations (recommended)
- `T` where `T: Serialize` - For automatic JSON output

### Type Lookup (Fast Index)

**Commands:**
- `CommandRegistry` - Central registry for all commands
- `CliBuilder` - Builder pattern for CLI construction

**Traits:**
- `NounCommand` - Define noun commands
- `VerbCommand` - Define verb commands

**Arguments:**
- `VerbArgs` - Access parsed arguments
- `VerbContext` - Execution context

**Errors:**
- `NounVerbError` - Error type for all operations
- `Result<T>` - Alias for `std::result::Result<T, NounVerbError>`

**Telemetry (v5):**
- `TelemetryCollector` - Main telemetry facade
- `Span` - Distributed tracing span
- `SpanBuilder` - Builder for creating spans
- `TracingCollector` - Span collection and management
- `MetricsCollector` - Metrics collection

**Macros:**
- `#[noun]` - Define noun command
- `#[verb]` - Define verb command
- `#[arg]` - Configure arguments

---

## Entry Points

### For Human Developers
```rust
use clap_noun_verb::{CliBuilder, noun, verb, VerbArgs, Result};

fn main() -> Result<()> {
    CliBuilder::new()
        .name("myapp")
        .about("My application")
        .run()
}
```

### For AI Agents (Auto-Discovery)
```rust
use clap_noun_verb::run_cli;

// Define commands with macros
#[noun(name = "services")]
fn services() -> Result<()> { Ok(()) }

#[verb(name = "status", noun = "services")]
fn status() -> Result<()> { Ok(()) }

// Run with auto-discovery
fn main() -> Result<()> {
    run_cli()  // Automatically discovers all commands
}
```

---

## Conventions

### Naming
- **Nouns:** kebab-case (e.g., `"user-profile"`, `"services"`)
- **Verbs:** kebab-case (e.g., `"get-status"`, `"list"`)
- **Arguments:** kebab-case for long flags (e.g., `--output-format`)
- **Functions:** snake_case (Rust convention)

### Return Types
- Use `Result<()>` for operations that can fail
- Use `Result<T>` where `T: Serialize` for automatic JSON output
- Never use `panic!`, `unwrap()`, or `expect()` in verb handlers

### Error Handling
- Always return `Result<T, NounVerbError>`
- Use `NounVerbError::execution_error()` for general errors
- Use `NounVerbError::argument_error()` for validation errors
- Use `NounVerbError::validation_error()` for detailed validation

### Thread Safety
- All types are `Send + Sync` (thread-safe)
- Command handlers can be called from any thread
- No shared mutable state (use `Arc<Mutex<T>>` if needed)

---

**End of API Catalog**
**Total Types Documented:** 15 core types, 50+ methods
**Coverage:** Complete public API surface
